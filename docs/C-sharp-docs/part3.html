<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Csharp3 - KnowledgeBase</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Scrapy/Scrapy.html"><strong aria-hidden="true">1.</strong> Scrapy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Scrapy/Scrapy1.html"><strong aria-hidden="true">1.1.</strong> Scrapy1</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy2.html"><strong aria-hidden="true">1.2.</strong> Scrapy2</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy3.html"><strong aria-hidden="true">1.3.</strong> Scrapy3</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy4.html"><strong aria-hidden="true">1.4.</strong> Scrapy4</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy5.html"><strong aria-hidden="true">1.5.</strong> Scrapy5</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy6.html"><strong aria-hidden="true">1.6.</strong> Scrapy6</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy7.html"><strong aria-hidden="true">1.7.</strong> Scrapy7</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy8.html"><strong aria-hidden="true">1.8.</strong> Scrapy8</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy9.html"><strong aria-hidden="true">1.9.</strong> Scrapy9</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy10.html"><strong aria-hidden="true">1.10.</strong> Scrapy10</a></li></ol></li><li class="chapter-item expanded "><a href="../ThinkPython/ThinkPython.html"><strong aria-hidden="true">2.</strong> ThinkPython</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ThinkPython/part_1.html"><strong aria-hidden="true">2.1.</strong> ThinkPython1</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_2.html"><strong aria-hidden="true">2.2.</strong> ThinkPython2</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_3.html"><strong aria-hidden="true">2.3.</strong> ThinkPython3</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_4.html"><strong aria-hidden="true">2.4.</strong> ThinkPython4</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_5.html"><strong aria-hidden="true">2.5.</strong> ThinkPython5</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_6.html"><strong aria-hidden="true">2.6.</strong> ThinkPython6</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_7.html"><strong aria-hidden="true">2.7.</strong> ThinkPython7</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_8.html"><strong aria-hidden="true">2.8.</strong> ThinkPython8</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_9.html"><strong aria-hidden="true">2.9.</strong> ThinkPython9</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_10.html"><strong aria-hidden="true">2.10.</strong> ThinkPython10</a></li></ol></li><li class="chapter-item expanded "><a href="../C-sharp-docs/C-sharp-docs.html"><strong aria-hidden="true">3.</strong> C-sharp-docs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C-sharp-docs/part1.html"><strong aria-hidden="true">3.1.</strong> Csharp1</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part2.html"><strong aria-hidden="true">3.2.</strong> Csharp2</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part3.html" class="active"><strong aria-hidden="true">3.3.</strong> Csharp3</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part4.html"><strong aria-hidden="true">3.4.</strong> Csharp4</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part5.html"><strong aria-hidden="true">3.5.</strong> Csharp5</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part6.html"><strong aria-hidden="true">3.6.</strong> Csharp6</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part7.html"><strong aria-hidden="true">3.7.</strong> Csharp7</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part8.html"><strong aria-hidden="true">3.8.</strong> Csharp8</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part9.html"><strong aria-hidden="true">3.9.</strong> Csharp9</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part10.html"><strong aria-hidden="true">3.10.</strong> Csharp10</a></li></ol></li><li class="chapter-item expanded "><a href="../php-docs/php-docs.html"><strong aria-hidden="true">4.</strong> php-docs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../php-docs/part1.html"><strong aria-hidden="true">4.1.</strong> php1</a></li><li class="chapter-item expanded "><a href="../php-docs/part2.html"><strong aria-hidden="true">4.2.</strong> php2</a></li><li class="chapter-item expanded "><a href="../php-docs/part3.html"><strong aria-hidden="true">4.3.</strong> php3</a></li><li class="chapter-item expanded "><a href="../php-docs/part4.html"><strong aria-hidden="true">4.4.</strong> php4</a></li><li class="chapter-item expanded "><a href="../php-docs/part5.html"><strong aria-hidden="true">4.5.</strong> php5</a></li><li class="chapter-item expanded "><a href="../php-docs/part6.html"><strong aria-hidden="true">4.6.</strong> php6</a></li><li class="chapter-item expanded "><a href="../php-docs/part7.html"><strong aria-hidden="true">4.7.</strong> php7</a></li><li class="chapter-item expanded "><a href="../php-docs/part8.html"><strong aria-hidden="true">4.8.</strong> php8</a></li><li class="chapter-item expanded "><a href="../php-docs/part9.html"><strong aria-hidden="true">4.9.</strong> php9</a></li><li class="chapter-item expanded "><a href="../php-docs/part10.html"><strong aria-hidden="true">4.10.</strong> php10</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">KnowledgeBase</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>tutorial
.NET 5 or later SDK
Integrated development environment (IDE)
We recommend Visual S tudio or Visual S tudio Code
Replace the existing Main method with the following:
C#Updating an existing .NET console application ＂
Scheduling a cancellation ＂
Prerequisites
Update application entry point
static async Task Main()
{
Console.WriteLine( &quot;Application started.&quot; );
try
{
s_cts.CancelAfter( 3500);
await SumPageSizesAsync();
}
catch (OperationCanceledException)
{The updated Main method writes a few instructional messages to the console. Within
the try-catch , a call to CancellationT okenSource.CancelAfter(Int32)  schedules a
cancellation. This will signal cancellation after a period of time.
Next, the SumPageSizesAsync method is awaited. If processing all of the URLs occurs
faster than the scheduled cancellation, the application ends. However, if the scheduled
cancellation is triggered before all of the URLs are processed, a
OperationCanceledException  is thrown.
Console
The following code is the complete text of the Program.cs  file for the example.
C#        Console.WriteLine( &quot;\nTasks cancelled: timed out.\n&quot; );
}
finally
{
s_cts.Dispose();
}
Console.WriteLine( &quot;Application ending.&quot; );
}
Example application output
Application started.
https://learn.microsoft.com                                       37,357
https://learn.microsoft.com/aspnet/core                           85,589
https://learn.microsoft.com/azure                                398,939
https://learn.microsoft.com/azure/devops                          73,663
Tasks cancelled: timed out.
Application ending.
Complete example
using System.Diagnostics;
class Program
{
static readonly  CancellationTokenSource s_cts = new 
CancellationTokenSource();    static readonly  HttpClient s_client = new HttpClient
{
MaxResponseContentBufferSize = 1_000_000
};
static readonly  IEnumerable&lt; string&gt; s_urlList = new string[]
{
&quot;https://learn.microsoft.com&quot; ,
&quot;https://learn.microsoft.com/aspnet/core&quot; ,
&quot;https://learn.microsoft.com/azure&quot; ,
&quot;https://learn.microsoft.com/azure/devops&quot; ,
&quot;https://learn.microsoft.com/dotnet&quot; ,
&quot;https://learn.microsoft.com/dynamics365&quot; ,
&quot;https://learn.microsoft.com/education&quot; ,
&quot;https://learn.microsoft.com/enterprise-mobility-security&quot; ,
&quot;https://learn.microsoft.com/gaming&quot; ,
&quot;https://learn.microsoft.com/graph&quot; ,
&quot;https://learn.microsoft.com/microsoft-365&quot; ,
&quot;https://learn.microsoft.com/office&quot; ,
&quot;https://learn.microsoft.com/powershell&quot; ,
&quot;https://learn.microsoft.com/sql&quot; ,
&quot;https://learn.microsoft.com/surface&quot; ,
&quot;https://learn.microsoft.com/system-center&quot; ,
&quot;https://learn.microsoft.com/visualstudio&quot; ,
&quot;https://learn.microsoft.com/windows&quot; ,
&quot;https://learn.microsoft.com/xamarin&quot;
};
static async Task Main()
{
Console.WriteLine( &quot;Application started.&quot; );
try
{
s_cts.CancelAfter( 3500);
await SumPageSizesAsync();
}
catch (OperationCanceledException)
{
Console.WriteLine( &quot;\nTasks cancelled: timed out.\n&quot; );
}
finally
{
s_cts.Dispose();
}
Console.WriteLine( &quot;Application ending.&quot; );
}
static async Task SumPageSizesAsync ()
{
var stopwatch = Stopwatch.StartNew();
int total = 0;CancellationT oken
CancellationT okenSource
Asynchronous programming with async and await (C#)
Cancel a list of tasks (C#)        foreach (string url in s_urlList)
{
int contentLength = await ProcessUrlAsync(url, s_client,<br />
s_cts.Token);
total += contentLength;
}
stopwatch.Stop();
Console.WriteLine( $&quot;\nTotal bytes returned:  {total:#,#} &quot;);
Console.WriteLine( $&quot;Elapsed time:          {stopwatch.Elapsed} \n&quot;);
}
static async Task<int> ProcessUrlAsync (string url, HttpClient client,<br />
CancellationToken token )
{
HttpResponseMessage response = await client.GetAsync(url, token);
byte[] content = await response.Content.ReadAsByteArrayAsync(token);
Console.WriteLine( $&quot;{url,-60} {content.Length, 10:#,#}&quot;);
return content.Length;
}
}
See alsoTutorial: Gen erate and consume async
streams using C# and .NET
Article •03/25/2023
Async str eams  model a streaming source of data. Data streams often retrieve or
generate elements asynchronously. They provide a natural programming model for
asynchronous streaming data sources.
In this tutorial, you'll learn how to:
You'll need to set up your machine to run .NET, including the C# compiler. The C#
compiler is available with Visual S tudio 2022  or the .NET SDK .
You'll need to create a GitHub access token  so that you can access the GitHub
GraphQL endpoint. Select the following permissions for your GitHub Access T oken:
repo:status
public_repo
Save the access token in a safe place so you can use it to gain access to the GitHub API
endpoint.
This tutorial assumes you're familiar with C# and .NET, including either Visual S tudio or
the .NET CLI.Create a data source that generates a sequence of data elements asynchronously.＂
Consume that data source asynchronously.＂
Support cancellation and captured contexts for asynchronous streams.＂
Recognize when the new interface and data source are preferred to earlier
synchronous data sequences.＂
Prerequisites
２ Warning
Keep your personal access token secure. Any software with your personal access
token could make GitHub API calls using your access rights.
Run the starter applicationYou can get the code for the starter application used in this tutorial from the
dotnet/docs  repository in the asynchronous-programming/snippets  folder.
The starter application is a console application that uses the GitHub GraphQL
interface to retrieve recent issues written in the dotnet/docs  repository. S tart by
looking at the following code for the starter app Main method:
C#
static async Task Main(string[] args)
{
//Follow these steps to create a GitHub Access Token
// https://help.github.com/articles/creating-a-personal-access-token-
for-the-command-line/#creating-a-token
//Select the following permissions for your GitHub Access Token:
// - repo:status
// - public_repo
// Replace the 3rd parameter to the following code with your GitHub<br />
access token.
var key = GetEnvVariable( &quot;GitHubKey&quot; ,
&quot;You must store your GitHub key in the 'GitHubKey' environment<br />
variable&quot; ,
&quot;&quot;);
var client = new GitHubClient( new 
Octokit.ProductHeaderValue( &quot;IssueQueryDemo&quot; ))
{
Credentials = new Octokit.Credentials(key)
};
var progressReporter = new progressStatus((num) =&gt;
{
Console.WriteLine( $&quot;Received {num} issues in total&quot; );
});
CancellationTokenSource cancellationSource = new 
CancellationTokenSource();
try
{
var results = await RunPagedQueryAsync(client, PagedIssueQuery, 
&quot;docs&quot;,
cancellationSource.Token, progressReporter);
foreach(var issue in results)
Console.WriteLine(issue);
}
catch (OperationCanceledException)
{
Console.WriteLine( &quot;Work has been cancelled&quot; );
}
}You can either set a GitHubKey environment variable to your personal access token, or
you can replace the last argument in the call to GetEnvVariable with your personal
access token. Don't put your access code in source code if you'll be sharing the source
with others. Never upload access codes to a shared source repository.
After creating the GitHub client, the code in Main creates a progress reporting object
and a cancellation token. Once those objects are created, Main calls RunPagedQueryAsync
to retrieve the most recent 250 created issues. After that task has finished, the results
are displayed.
When you run the starter application, you can make some important observations about
how this application runs. Y ou'll see progress reported for each page returned from
GitHub. Y ou can observe a noticeable pause before GitHub returns each new page of
issues. Finally, the issues are displayed only after all 10 pages have been retrieved from
GitHub.
The implementation reveals why you observed the behavior discussed in the previous
section. Examine the code for RunPagedQueryAsync:
C#Examine the implementation
private static async Task<JArray> RunPagedQueryAsync (GitHubClient client, 
string queryText, string repoName, CancellationToken cancel, IProgress&lt; int&gt; 
progress )
{
var issueAndPRQuery = new GraphQLRequest
{
Query = queryText
};
issueAndPRQuery.Variables[ &quot;repo_name&quot; ] = repoName;
JArray finalResults = new JArray();
bool hasMorePages = true;
int pagesReturned = 0;
int issuesReturned = 0;
// Stop with 10 pages, because these are large repos:
while (hasMorePages &amp;&amp; (pagesReturned++ &lt; 10))
{
var postBody = issueAndPRQuery.ToJsonText();
var response = await client.Connection.Post&lt; string&gt;(new 
Uri(&quot;https://api.github.com/graphql&quot; ),
postBody, &quot;application/json&quot; , &quot;application/json&quot; );
JObject results =  The very first thing this method does is to create the POST object, using the
GraphQLRequest class:
C#
which helps to form the POST object body, and correctly convert it to JSON presented
as single string with the ToJsonText method, which removes all newline characters from
your request body marking them with the \ (backslash) escape character.
Let's concentrate on the paging algorithm and async structure of the preceding code.
(You can consult the GitHub GraphQL documentation  for details on the GitHub
GraphQL API.) The RunPagedQueryAsync method enumerates the issues from most recent
to oldest. It requests 25 issues per page and examines the pageInfo structure of the
response to continue with the previous page. That follows GraphQL's standard paging
support for multi-page responses. The response includes a pageInfo object that
includes a hasPreviousPages value and a startCursor value used to request theJObject.Parse(response.HttpResponse.Body.ToString()!);
int totalCount = ( int)issues(results)[ &quot;totalCount&quot; ]!;
hasMorePages = ( bool)pageInfo(results)[ &quot;hasPreviousPage&quot; ]!;
issueAndPRQuery.Variables[ &quot;start_cursor&quot; ] = pageInfo(results)
[&quot;startCursor&quot; ]!.ToString();
issuesReturned += issues(results)[ &quot;nodes&quot;]!.Count();
finalResults.Merge(issues(results)[ &quot;nodes&quot;]!);
progress?.Report(issuesReturned);
cancel.ThrowIfCancellationRequested();
}
return finalResults;
JObject issues(JObject result ) =&gt; (JObject)result[ &quot;data&quot;]!
[&quot;repository&quot; ]![&quot;issues&quot; ]!;
JObject pageInfo (JObject result ) =&gt; (JObject)issues(result)
[&quot;pageInfo&quot; ]!;
}
public class GraphQLRequest
{
[JsonProperty( &quot;query&quot;)]
public string? Query { get; set; }
[JsonProperty( &quot;variables&quot; )]
public IDictionary&lt; string, object&gt; Variables { get; } = new 
Dictionary&lt; string, object&gt;();
public string ToJsonText () =&gt;
JsonConvert.SerializeObject( this);
}
previous page. The issues are in the nodes array. The RunPagedQueryAsync method
appends these nodes to an array that contains all the results from all pages.
After retrieving and restoring a page of results, RunPagedQueryAsync reports progress
and checks for cancellation. If cancellation has been requested, RunPagedQueryAsync
throws an OperationCanceledException .
There are several elements in this code that can be improved. Most importantly,
RunPagedQueryAsync must allocate storage for all the issues returned. This sample stops
at 250 issues because retrieving all open issues would require much more memory to
store all the retrieved issues. The protocols for supporting progress reports and
cancellation make the algorithm harder to understand on its first reading. More types
and APIs are involved. Y ou must trace the communications through the
CancellationT okenSource  and its associated CancellationT oken  to understand where
cancellation is requested and where it's granted.
Async streams and the associated language support address all those concerns. The
code that generates the sequence can now use yield return to return elements in a
method that was declared with the async modifier. Y ou can consume an async stream
using an await foreach loop just as you consume any sequence using a foreach loop.
These new language features depend on three new interfaces added to .NET S tandard
2.1 and implemented in .NET Core 3.0:
System.Collections.Generic.IAsyncEnumerable<T>
System.Collections.Generic.IAsyncEnumerator<T>
System.IAsyncDisposable
These three interfaces should be familiar to most C# developers. They behave in a
manner similar to their synchronous counterparts:
System.Collections.Generic.IEnumerable<T>
System.Collections.Generic.IEnumerator<T>
System.IDisposable
One type that may be unfamiliar is System.Threading.T asks.V alueT ask. The ValueTask
struct provides a similar API to the System.Threading.T asks.T ask class. ValueTask is used
in these interfaces for performance reasons.Async streams provide a better wayNext, convert the RunPagedQueryAsync method to generate an async stream. First,
change the signature of RunPagedQueryAsync to return an IAsyncEnumerable<JToken>, and
remove the cancellation token and progress objects from the parameter list as shown in
the following code:
C#
The starter code processes each page as the page is retrieved, as shown in the following
code:
C#
Replace those three lines with the following code:
C#
You can also remove the declaration of finalResults earlier in this method and the
return statement that follows the loop you modified.
You've finished the changes to generate an async stream. The finished method should
resemble the following code:
C#Convert to async streams
private static async IAsyncEnumerable<JToken> 
RunPagedQueryAsync (GitHubClient client,
string queryText, string repoName )
finalResults.Merge(issues(results)[ &quot;nodes&quot;]!);
progress?.Report(issuesReturned);
cancel.ThrowIfCancellationRequested();
foreach (JObject issue in issues(results)[&quot;nodes&quot;]!)
yield return issue;
private static async IAsyncEnumerable<JToken> 
RunPagedQueryAsync (GitHubClient client,
string queryText, string repoName )
{
var issueAndPRQuery = new GraphQLRequest
{
Query = queryText
};
issueAndPRQuery.Variables[ &quot;repo_name&quot; ] = repoName;Next, you change the code that consumes the collection to consume the async stream.
Find the following code in Main that processes the collection of issues:
C#    bool hasMorePages = true;
int pagesReturned = 0;
int issuesReturned = 0;
// Stop with 10 pages, because these are large repos:
while (hasMorePages &amp;&amp; (pagesReturned++ &lt; 10))
{
var postBody = issueAndPRQuery.ToJsonText();
var response = await client.Connection.Post&lt; string&gt;(new 
Uri(&quot;https://api.github.com/graphql&quot; ),
postBody, &quot;application/json&quot; , &quot;application/json&quot; );
JObject results =<br />
JObject.Parse(response.HttpResponse.Body.ToString()!);
int totalCount = ( int)issues(results)[ &quot;totalCount&quot; ]!;
hasMorePages = ( bool)pageInfo(results)[ &quot;hasPreviousPage&quot; ]!;
issueAndPRQuery.Variables[ &quot;start_cursor&quot; ] = pageInfo(results)
[&quot;startCursor&quot; ]!.ToString();
issuesReturned += issues(results)[ &quot;nodes&quot;]!.Count();
foreach (JObject issue in issues(results)[&quot;nodes&quot;]!)
yield return issue;
}
JObject issues(JObject result ) =&gt; (JObject)result[ &quot;data&quot;]!
[&quot;repository&quot; ]![&quot;issues&quot; ]!;
JObject pageInfo (JObject result ) =&gt; (JObject)issues(result)
[&quot;pageInfo&quot; ]!;
}
var progressReporter = new progressStatus((num) =&gt;
{
Console.WriteLine( $&quot;Received {num} issues in total&quot; );
});
CancellationTokenSource cancellationSource = new CancellationTokenSource();
try
{
var results = await RunPagedQueryAsync(client, PagedIssueQuery, &quot;docs&quot;,
cancellationSource.Token, progressReporter);
foreach(var issue in results)
Console.WriteLine(issue);
}
catch (OperationCanceledException)
{Replace that code with the following await foreach loop:
C#
The new interface IAsyncEnumerator<T>  derives from IAsyncDisposable . That means the
preceding loop will asynchronously dispose the stream when the loop finishes. Y ou can
imagine the loop looks like the following code:
C#
By default, stream elements are processed in the captured context. If you want to
disable capturing of the context, use the
TaskAsyncEnumerableExtensions.ConfigureA wait extension method. For more
information about synchronization contexts and capturing the current context, see the
article on consuming the T ask-based asynchronous pattern .
Async streams support cancellation using the same protocol as other async methods.
You would modify the signature for the async iterator method as follows to support
cancellation:    Console.WriteLine( &quot;Work has been cancelled&quot; );
}
int num = 0;
await foreach (var issue in RunPagedQueryAsync (client, PagedIssueQuery, 
&quot;docs&quot;))
{
Console.WriteLine(issue);
Console.WriteLine( $&quot;Received {++num} issues in total&quot; );
}
int num = 0;
var enumerator = RunPagedQueryAsync(client, PagedIssueQuery, 
&quot;docs&quot;).GetAsyncEnumerator();
try
{
while (await enumerator.MoveNextAsync())
{
var issue = enumerator.Current;
Console.WriteLine(issue);
Console.WriteLine( $&quot;Received {++num} issues in total&quot; );
}
} finally
{
if (enumerator != null)
await enumerator.DisposeAsync();
}C#
The System.Runtime.CompilerServices.EnumeratorCancellationAttribute  attribute causes
the compiler to generate code for the IAsyncEnumerator<T>  that makes the token
passed to GetAsyncEnumerator visible to the body of the async iterator as that argument.
Inside runQueryAsync, you could examine the state of the token and cancel further work
if requested.private static async IAsyncEnumerable<JToken> 
RunPagedQueryAsync (GitHubClient client,
string queryText, string repoName, [EnumeratorCancellation]<br />
CancellationToken cancellationToken = default)
{
var issueAndPRQuery = new GraphQLRequest
{
Query = queryText
};
issueAndPRQuery.Variables[ &quot;repo_name&quot; ] = repoName;
bool hasMorePages = true;
int pagesReturned = 0;
int issuesReturned = 0;
// Stop with 10 pages, because these are large repos:
while (hasMorePages &amp;&amp; (pagesReturned++ &lt; 10))
{
var postBody = issueAndPRQuery.ToJsonText();
var response = await client.Connection.Post&lt; string&gt;(new 
Uri(&quot;https://api.github.com/graphql&quot; ),
postBody, &quot;application/json&quot; , &quot;application/json&quot; );
JObject results =<br />
JObject.Parse(response.HttpResponse.Body.ToString()!);
int totalCount = ( int)issues(results)[ &quot;totalCount&quot; ]!;
hasMorePages = ( bool)pageInfo(results)[ &quot;hasPreviousPage&quot; ]!;
issueAndPRQuery.Variables[ &quot;start_cursor&quot; ] = pageInfo(results)
[&quot;startCursor&quot; ]!.ToString();
issuesReturned += issues(results)[ &quot;nodes&quot;]!.Count();
foreach (JObject issue in issues(results)[&quot;nodes&quot;]!)
yield return issue;
}
JObject issues(JObject result ) =&gt; (JObject)result[ &quot;data&quot;]!
[&quot;repository&quot; ]![&quot;issues&quot; ]!;
JObject pageInfo (JObject result ) =&gt; (JObject)issues(result)
[&quot;pageInfo&quot; ]!;
}You use another extension method, WithCancellation , to pass the cancellation token to
the async stream. Y ou would modify the loop enumerating the issues as follows:
C#
You can get the code for the finished tutorial from the dotnet/docs  repository in the
asynchronous-programming/snippets  folder.
Run the application again. Contrast its behavior with the behavior of the starter
application. The first page of results is enumerated as soon as it's available. There's an
observable pause as each new page is requested and retrieved, then the next page's
results are quickly enumerated. The try / catch block isn't needed to handle
cancellation: the caller can stop enumerating the collection. Progress is clearly reported
because the async stream generates results as each page is downloaded. The status for
each issue returned is seamlessly included in the await foreach loop. Y ou don't need a
callback object to track progress.
You can see improvements in memory use by examining the code. Y ou no longer need
to allocate a collection to store all the results before they're enumerated. The caller can
determine how to consume the results and if a storage collection is needed.
Run both the starter and finished applications and you can observe the differences
between the implementations for yourself. Y ou can delete the GitHub access token you
created when you started this tutorial after you've finished. If an attacker gained access
to that token, they could access GitHub APIs using your credentials.
In this tutorial, you used async streams to read a individual items from a network API
that returns pages of data. Async streams can also read from &quot;never ending streams&quot;private static async Task EnumerateWithCancellation (GitHubClient client )
{
int num = 0;
var cancellation = new CancellationTokenSource();
await foreach (var issue in RunPagedQueryAsync (client, PagedIssueQuery, 
&quot;docs&quot;)
.WithCancellation (cancellation.Token ))
{
Console.WriteLine(issue);
Console.WriteLine( $&quot;Received {++num} issues in total&quot; );
}
}
Run the finished applicationlike a stock ticker, or sensor device. The call to MoveNextAsync returns the next item as
soon as it's available.
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide ..NET feedb ack
The .NET documentation is open
source. Provide feedback here.
 Open a documentation issue
 Provide product feedbackNullable reference types
Article •02/15/2023
In a nullable oblivious context, all reference types were nullable. Nullable r eference types
refers to a group of features enabled in a nullable aware context that minimize the
likelihood that your code causes the runtime to throw System.NullR eferenceException .
Nullable r eference types  includes three features that help you avoid these exceptions,
including the ability to explicitly mark a reference type as nullable :
Improved static flow analysis that determines if a variable may be null before
dereferencing it.
Attributes that annotate APIs so that the flow analysis determines null-st ate.
Variable annotations that developers use to explicitly declare the intended null-
state for a variable.
Null-state analysis and variable annotations are disabled by default for existing projects
—meaning that all reference types continue to be nullable. S tarting in .NET 6, they're
enabled by default for new projects. For information about enabling these features by
declaring a nullable annot ation c ontext, see Nullable contexts .
The rest of this article describes how those three feature areas work to produce
warnings when your code may be dereferencing  a null value. Dereferencing a variable
means to access one of its members using the . (dot) operator, as shown in the
following example:
C#
When you dereference a variable whose value is null, the runtime throws a
System.NullR eferenceException .
You can also explore these concepts in our Learn module on Nullable safety in C# .
Null-st ate analysis  tracks the null-st ate of references. This static analysis emits warnings
when your code may dereference null. You can address these warnings to minimize
incidences when the runtime throws a System.NullR eferenceException . The compilerstring message = &quot;Hello, World!&quot; ; 
int length = message.Length; // dereferencing &quot;message&quot;<br />
Null state analysisuses static analysis to determine the null-st ate of a variable. A variable is either not-null
or maybe-null . The compiler determines that a variable is not-null in two ways:</p>
<ol>
<li>
<p>The variable has been assigned a value that is known to be not null .</p>
</li>
<li>
<p>The variable has been checked against null and hasn't been modified since that
check.
Any variable that the compiler hasn't determined as not-null is considered maybe-null .
The analysis provides warnings in situations where you may accidentally dereference a
null value. The compiler produces warnings based on the null-st ate.
When a variable is not-null, that variable may be dereferenced safely.
When a variable is maybe-null , that variable must be checked to ensure that it isn't
null before dereferencing it.
Consider the following example:
C#
In the preceding example, the compiler determines that message is maybe-null  when the
first message is printed. There's no warning for the second message. The final line of
code produces a warning because originalMessage might be null. The following
example shows a more practical use for traversing a tree of nodes to the root,
processing each node during the traversal:
C#string message = null; 
// warning: dereference null.<br />
Console.WriteLine( $&quot;The length of the message is {message.Length} &quot;); 
var originalMessage = message;<br />
message = &quot;Hello, World!&quot; ; 
// No warning. Analysis determined &quot;message&quot; is not null.<br />
Console.WriteLine( $&quot;The length of the message is {message.Length} &quot;); 
// warning!<br />
Console.WriteLine(originalMessage.Length);<br />
void FindRoot (Node node, Action<Node> processNode ) 
{ 
for (var current = node; current != null; current = current.Parent)<br />
{ 
processNode(current);  The previous code doesn't generate any warnings for dereferencing the variable
current. Static analysis determines that current is never dereferenced when it's maybe-
null. The variable current is checked against null before current.Parent is accessed,
and before passing current to the ProcessNode action. The previous examples show
how the compiler determines null-st ate for local variables when initialized, assigned, or
compared to null.
The null state analysis doesn't trace into called methods. As a result, fields initialized in a
common helper method called by constructors will generate a warning with the
following template:
Non-nullable property ' name ' must contain a non-null value when exiting
constructor.
You can address these warnings in one of two ways: Constr uctor chaining , or nullable
attributes on the helper method. The following code shows an example of each. The
Person class uses a common constructor called by all other constructors. The Student
class has a helper method annotated with the
System.Diagnostics.CodeAnalysis.MemberNotNullAttribute  attribute:
C#    } 
} 
using System.Diagnostics.CodeAnalysis;<br />
public class Person 
{ 
public string FirstName { get; set; } 
public string LastName { get; set; } 
public Person(string firstName, string lastName ) 
{ 
FirstName = firstName;<br />
LastName = lastName;<br />
} 
public Person() : this(&quot;John&quot;, &quot;Doe&quot;) { } 
} 
public class Student : Person 
{ 
public string Major { get; set; } 
public Student(string firstName, string lastName, string major) Nullable state analysis and the warnings the compiler generates help you avoid program
errors by dereferencing null. The article on resolving nullable warnings  provides
techniques for correcting the warnings you'll likely see in your code.
The null state analysis needs hints from developers to understand the semantics of APIs.
Some APIs provide null checks, and should change the null-st ate of a variable from
maybe-null  to not-null. Other APIs return expressions that are not-null or maybe-null
depending on the null-st ate of the input arguments. For example, consider the following
code that displays a message:
C#        : base(firstName, lastName ) 
{ 
SetMajor(major);<br />
} 
public Student(string firstName, string lastName ) : 
base(firstName, lastName ) 
{ 
SetMajor();<br />
} 
public Student() 
{ 
SetMajor();<br />
} 
[MemberNotNull(nameof(Major)) ] 
private void SetMajor (string? major = default) 
{ 
Major = major ?? &quot;Undeclared&quot; ; 
} 
} 
７ Note
A number of improvements to definite assignment and null state analysis were
added in C# 10. When you upgrade to C# 10, you may find fewer nullable warnings
that are false positives. Y ou can learn more about the improvements in the featur es
specification for definit e assignment impr ovements .
Attributes on API signatures
public void PrintMessage (string message ) 
{ Based on inspection, any developer would consider this code safe, and shouldn't
generate warnings. The compiler doesn't know that IsNullOrWhiteSpace provides a null
check. When IsNullOrWhitespace returns false, the null-st ate of the string is not-null.
When IsNullOrWhitespace returns true, the null-st ate isn't changed. In the previous
example, the signature includes the NotNullWhen  to indicate the null state of message:
C#
Attributes provide detailed information about the null state of arguments, return values,
and members of the object instance used to invoke a member. The details on each
attribute can be found in the language reference article on nullable reference attributes .
The .NET runtime APIs have all been annotated in .NET 5. Y ou improve the static analysis
by annotating your APIs to provide semantic information about the null-st ate of
arguments and return values.
The null-st ate analysis provides robust analysis for most variables. The compiler needs
more information from you for member variables. The compiler can't make assumptions
about the order in which public members are accessed. Any public member could be
accessed in any order. Any of the accessible constructors could be used to initialize the
object. If a member field might ever be set to null, the compiler must assume its null-
state is maybe-null  at the start of each method.
You use annotations that can declare whether a variable is a nullable r eference type  or a
non-nullable r eference type . These annotations make important statements about the
null-st ate for variables:
A reference isn 't supposed t o be null . The default state of a nonnullable reference
variable is not-null. The compiler enforces rules that ensure it's safe to dereference
these variables without first checking that it isn't null:
The variable must be initialized to a non-null value.
The variable can never be assigned the value null. The compiler issues a
warning when code assigns a maybe-null  expression to a variable that shouldn't    if (!string.IsNullOrWhiteSpace(message))<br />
{ 
Console.WriteLine( $&quot;{DateTime.Now} : {message} &quot;);
} 
} 
public static bool IsNullOrWhiteSpace ([NotNullWhen( false)] string message) ; 
Nullable variable annotationsbe null.
A reference may be null . The default state of a nullable reference variable is
maybe-null . The compiler enforces rules to ensure that you've correctly checked
for a null reference:
The variable may only be dereferenced when the compiler can guarantee that
the value isn't null.
These variables may be initialized with the default null value and may be
assigned the value null in other code.
The compiler doesn't issue warnings when code assigns a maybe-null
expression to a variable that may be null.
Any reference variable that isn't supposed to be null has a null-st ate of not-null. Any
reference variable that may be null initially has the null-st ate of maybe-null .
A nullable r eference type  is noted using the same syntax as nullable value types : a ? is
appended to the type of the variable. For example, the following variable declaration
represents a nullable string variable, name:
C#
Any variable where the ? isn't appended to the type name is a non-nullable r eference
type. That includes all reference type variables in existing code when you've enabled this
feature. However, any implicitly typed local variables (declared using var) are nullable
reference types . As the preceding sections showed, static analysis determines the null-
state of local variables to determine if they're maybe-null .
Sometimes you must override a warning when you know a variable isn't null, but the
compiler determines its null-st ate is maybe-null . You use the null-forgiving operator  !
following a variable name to force the null-st ate to be not-null. For example, if you know
the name variable isn't null but the compiler issues a warning, you can write the
following code to override the compiler's analysis:
C#
Nullable reference types and nullable value types provide a similar semantic concept: A
variable can represent a value or object, or that variable may be null. However, nullable
reference types and nullable value types are implemented differently: nullable valuestring? name; 
name!.Length;  types are implemented using System.Nullable<T> , and nullable reference types are
implemented by attributes read by the compiler. For example, string? and string are
both represented by the same type: System.S tring . However, int? and int are
represented by System.Nullable&lt;System.Int32&gt; and System.Int32 , respectively.
Nullable reference types are a compile time feature. That means it's possible for callers
to ignore warnings, intentionally use null as an argument to a method expecting a non
nullable reference. Library authors should include runtime checks against null argument
values. The ArgumentNullException.ThrowIfNull  is the preferred option for checking a
parameter against null at run time.
Generics require detailed rules to handle T? for any type parameter T. The rules are
necessarily detailed because of history and the different implementation for a nullable
value type and a nullable reference type. Nullable value types  are implemented using
the System.Nullable<T>  struct. Nullable reference types  are implemented as type
annotations that provide semantic rules to the compiler.
If the type argument for T is a reference type, T? references the corresponding
nullable reference type. For example, if T is a string, then T? is a string?.
If the type argument for T is a value type, T? references the same value type, T.
For example, if T is an int, the T? is also an int.
If the type argument for T is a nullable reference type, T? references that same
nullable reference type. For example, if T is a string?, then T? is also a string?.
If the type argument for T is a nullable value type, T? references that same
nullable value type. For example, if T is a int?, then T? is also a int?.
For return values, T? is equivalent to [MaybeNull]T; for argument values, T? is
equivalent to [AllowNull]T. For more information, see the article on Attributes for null-
state analysis  in the language reference.
You can specify different behavior using constraints :） Impor tant
Enabling nullable annotations can change how Entity Framework Core determines if
a data member is required. Y ou can learn more details in the article on Entity
Framew ork Cor e Fundamentals: W orking with Nullable R eference T ypes .
GenericsThe class constraint means that T must be a non-nullable reference type (for
example string). The compiler produces a warning if you use a nullable reference
type, such as string? for T.
The class? constraint means that T must be a reference type, either non-nullable
(string) or a nullable reference type (for example string?). When the type
parameter is a nullable reference type, such as string?, an expression of T?
references that same nullable reference type, such as string?.
The notnull constraint means that T must be a non-nullable reference type, or a
non-nullable value type. If you use a nullable reference type or a nullable value
type for the type parameter, the compiler produces a warning. Furthermore, when
T is a value type, the return value is that value type, not the corresponding
nullable value type.
These constraints help provide more information to the compiler on how T will be used.
That helps when developers choose the type for T, and provides better null-st ate
analysis when an instance of the generic type is used.
The new features that protect against throwing a System.NullR eferenceException  can be
disruptive when turned on in an existing codebase:
All explicitly typed reference variables are interpreted as non-nullable reference
types.
The meaning of the class constraint in generics changed to mean a non-nullable
reference type.
New warnings are generated because of these new rules.
You must explicitly opt in to use these features in your existing projects. That provides a
migration path and preserves backwards compatibility. Nullable contexts enable fine-
grained control for how the compiler interprets reference type variables. The nullable
annotation cont ext determines the compiler's behavior. There are four values for the
nullable annotation cont ext:
disable: The code is nullable oblivious .
Nullable warnings are disabled.
All reference type variables are nullable reference types.
You can't declare a variable as a nullable reference type using the ? suffix on
the type.
You can use the null forgiving operator, !, but it has no effect.
enable : The compiler enables all null reference analysis and all language features.Nullable contextsAll new nullable warnings are enabled.
You can use the ? suffix to declare a nullable reference type.
All other reference type variables are non-nullable reference types.
The null forgiving operator suppresses warnings for a possible assignment to
null.
warnings : The compiler performs all null analysis and emits warnings when code
might dereference null.
All new nullable warnings are enabled.
Use of the ? suffix to declare a nullable reference type produces a warning.
All reference type variables are allowed to be null. However, members have the
null-st ate of not-null at the opening brace of all methods unless declared with
the ? suffix.
You can use the null forgiving operator, !.
annot ations : The compiler doesn't perform null analysis or emit warnings when
code might dereference null.
All new nullable warnings are disabled.
You can use the ? suffix to declare a nullable reference type.
All other reference type variables are non-nullable reference types.
You can use the null forgiving operator, !, but it has no effect.
The nullable annotation context and nullable warning context can be set for a project
using the <Nullable>  element  in your .csproj file. This element configures how the
compiler interprets the nullability of types and what warnings are emitted. The following
table shows the allowable values and summarizes the contexts they specify.
Cont ext Dereference
warningsAssignment
warningsReference types ? suffix ! operat or
disable Disabled Disabled All are nullable Can't be
usedHas no
effect
enable Enabled Enabled Non-nullable unless
declared with ?Declares
nullable
typeSuppresses
warnings
for possible
null
assignment
warnings Enabled Not
applicableAll are nullable, but
members are considered
not null  at opening brace
of methodsProduces
a
warningSuppresses
warnings
for possible
null
assignmentCont ext Dereference
warningsAssignment
warningsReference types ? suffix ! operat or
annotationsDisabled Disabled Non-nullable unless
declared with ?Declares
nullable
typeHas no
effect
Reference type variables in code compiled in a disabled  context are nullable-oblivious .
You can assign a null literal or a maybe-null  variable to a variable that is nullable
oblivious . However, the default state of a nullable-oblivious  variable is not-null.
You can choose which setting is best for your project:
Choose disable for legacy projects that you don't want to update based on
diagnostics or new features.
Choose warnings  to determine where your code may throw
System.NullR eferenceException s. You can address those warnings before
modifying code to enable non-nullable reference types.
Choose annot ations  to express your design intent before enabling warnings.
Choose enable  for new projects and active projects where you want to protect
against null reference exceptions.
Example :
XML
You can also use directives to set these same contexts anywhere in your source code.
These are most useful when you're migrating a large codebase.
#nullable enable: Sets the nullable annotation context and nullable warning
context to enable .
#nullable disable: Sets the nullable annotation context and nullable warning
context to disable .
#nullable restore: Restores the nullable annotation context and nullable warning
context to the project settings.
#nullable disable warnings: Set the nullable warning context to disable .
#nullable enable warnings: Set the nullable warning context to enable .
#nullable restore warnings: Restores the nullable warning context to the project
settings.
#nullable disable annotations: Set the nullable annotation context to disable .
#nullable enable annotations: Set the nullable annotation context to enable .<Nullable >enable</Nullable > #nullable restore annotations: Restores the annotation warning context to the
project settings.
For any line of code, you can set any of the following combinations:
Warning cont ext Annotation cont ext Use
project default project default Default
enable disable Fix analysis warnings
enable project default Fix analysis warnings
project default enable Add type annotations
enable enable Code already migrated
disable enable Annotate code before fixing warnings
disable disable Adding legacy code to migrated project
project default disable Rarely
disable project default Rarely
Those nine combinations provide you with fine-grained control over the diagnostics the
compiler emits for your code. Y ou can enable more features in any area you're updating,
without seeing additional warnings you aren't ready to address yet.
） Impor tant
The global nullable context does not apply for generated code files. Under either
strategy, the nullable context is disabled  for any source file marked as generated.
This means any APIs in generated files are not annotated. There are four ways a file
is marked as generated:</p>
</li>
<li>
<p>In the .editorconfig, specify generated_code = true in a section that applies to
that file.</p>
</li>
<li>
<p>Put <auto-generated> or <auto-generated/> in a comment at the top of the
file. It can be on any line in that comment, but the comment block must be
the first element in the file.</p>
</li>
<li>
<p>Start the file name with Tempor aryGener atedFile_</p>
</li>
<li>
<p>End the file name with .designer .cs, .gener ated.cs , .g.cs, or .g.i.cs .
Generators can opt-in using the #nullable  preprocessor directive.By default, nullable annotation and warning contexts are disabled . That means that your
existing code compiles without changes and without generating any new warnings.
Beginning with .NET 6, new projects include the <Nullable>enable</Nullable> element
in all project templates.
These options provide two distinct strategies to update an existing codebase  to use
nullable reference types.
Arrays and structs that contain reference types are known pitfalls in nullable references
and the static analysis that determines null safety. In both situations, a non-nullable
reference may be initialized to null, without generating warnings.
A struct that contains non-nullable reference types allows assigning default for it
without any warnings. Consider the following example:
C#
In the preceding example, there's no warning in PrintStudent(default) while the non-
nullable reference types FirstName and LastName are null.Known pitfalls
Structs
using System;<br />
#nullable enable<br />
public struct Student<br />
{ 
public string FirstName;<br />
public string? MiddleName;<br />
public string LastName;<br />
} 
public static class Program 
{ 
public static void PrintStudent (Student student ) 
{ 
Console.WriteLine( $&quot;First name: {student.FirstName.ToUpper()} &quot;); 
Console.WriteLine( $&quot;Middle name: {student.MiddleName?.ToUpper()} &quot;); 
Console.WriteLine( $&quot;Last name: {student.LastName.ToUpper()} &quot;); 
} 
public static void Main() =&gt; PrintStudent( default); 
} Another more common case is when you deal with generic structs. Consider the
following example:
C#
In the preceding example, the property Bar is going to be null at run time, and it's
assigned to non-nullable string without any warnings.
Arrays are also a known pitfall in nullable reference types. Consider the following
example that doesn't produce any warnings:
C#
In the preceding example, the declaration of the array shows it holds non-nullable
strings, while its elements are all initialized to null. Then, the variable s is assigned a#nullable enable<br />
public struct Foo<T> 
{ 
public T Bar { get; set; } 
} 
public static class Program 
{ 
public static void Main() 
{ 
string s = default(Foo<string>).Bar; 
} 
} 
Arrays
using System;<br />
#nullable enable<br />
public static class Program 
{ 
public static void Main() 
{ 
string[] values = new string[10]; 
string s = values[ 0]; 
Console.WriteLine(s.ToUpper());<br />
} 
} null value (the first element of the array). Finally, the variable s is dereferenced causing
a runtime exception.
Nullable reference types proposal
Draft nullable reference types specification
Unconstrained type parameter annotations
Intro to nullable references tutorial
Nullable  (C# Compiler option)See alsoUpdate a codebase with nullable
reference types to improve null
diagnostic warnings
Article •09/21/2022
Nullable reference types  enable you to declare if variables of a reference type should or
shouldn't be assigned a null value. The compiler's static analysis and warnings when
your code might dereference null are the most important benefit of this feature. Once
enabled, the compiler generates warnings that help you avoid throwing a
System.NullR eferenceException  when your code runs.
If your codebase is relatively small, you can turn on the feature in your project , address
warnings, and enjoy the benefits of the improved diagnostics. Larger codebases may
require a more structured approach to address warnings over time, enabling the feature
for some as you address warnings in different types or files. This article describes
different strategies to update a codebase and the tradeoffs associated with these
strategies. Before starting your migration, read the conceptual overview of nullable
reference types . It covers the compiler's static analysis, null-st ate values of maybe-null
and not-null and the nullable annotations. Once you're familiar with those concepts and
terms, you're ready to migrate your code.
Regardless of how you update your codebase, the goal is that nullable warnings and
nullable annotations are enabled in your project. Once you reach that goal, you'll have
the <nullable>Enable</nullable> setting in your project. Y ou won't need any of the
preprocessor directives to adjust settings elsewhere.
The first choice is setting the default for the project. Y our choices are:</p>
</li>
<li>
<p>Nullable dis able as the default : disable is the default if you don't add a Nullable
element to your project file. Use this default when you're not actively adding new
files to the codebase. The main activity is to update the library to use nullable
reference types. Using this default means you add a nullable preprocessor directive
to each file as you update its code.</p>
</li>
<li>
<p>Nullable enable as the default : Set this default when you're actively developing
new features. Y ou want all new code to benefit from nullable reference types and
nullable static analysis. Using this default means you must add a #nullablePlan your migrationdisable to the top of each file. Y ou'll remove these preprocessor directives as you
address the warnings in each file.</p>
</li>
<li>
<p>Nullable war nings as the default : Choose this default for a two-phase migration.
In the first phase, address warnings. In the second phase, turn on annotations for
declaring a variable's expected null-st ate. Using this default means you must add a
#nullable disable to the top of each file.</p>
</li>
<li>
<p>Nullable annot ations  as the default. Annotate code before addressing warnings.
Enabling nullable as the default creates more up-front work to add the preprocessor
directives to every file. The advantage is that every new code file added to the project
will be nullable enabled. Any new work will be nullable aware; only existing code must
be updated. Disabling nullable as the default works better if the library is stable, and the
main focus of the development is to adopt nullable reference types. Y ou turn on nullable
reference types as you annotate APIs. When you've finished, you enable nullable
reference types for the entire project. When you create a new file, you must add the
preprocessor directives and make it nullable aware. If any developers on your team
forget, that new code is now in the backlog of work to make all code nullable aware.
Which of these strategies you pick depends on how much active development is taking
place in your project. The more mature and stable your project, the better the second
strategy. The more features being developed, the better the first strategy.
） Impor tant
The global nullable context does not apply for generated code files. Under either
strategy, the nullable context is disabled  for any source file marked as generated.
This means any APIs in generated files are not annotated. There are four ways a file
is marked as generated:</p>
</li>
<li>
<p>In the .editorconfig, specify generated_code = true in a section that applies to
that file.</p>
</li>
<li>
<p>Put <auto-generated> or <auto-generated/> in a comment at the top of the
file. It can be on any line in that comment, but the comment block must be
the first element in the file.</p>
</li>
<li>
<p>Start the file name with Tempor aryGener atedFile_</p>
</li>
<li>
<p>End the file name with .designer .cs, .gener ated.cs , .g.cs, or .g.i.cs .
Generators can opt-in using the #nullable  preprocessor directive.
Understand contexts and warningsEnabling warnings and annotations control how the compiler views reference types and
nullability. Every type has one of three nullabilities:
oblivious : All reference types are nullable oblivious  when the annotation context is
disabled.
nonnullable : An unannotated reference type, C is nonnullable  when the annotation
context is enabled.
nullable : An annotated reference type, C?, is nullable , but a warning may be issued
when the annotation context is disabled. V ariables declared with var are nullable
when the annotation context is enabled.
The compiler generates warnings based on that nullability:
nonnullable  types cause warnings if a potential null value is assigned to them.
nullable  types cause warnings if they dereferenced when maybe-null .
oblivious  types cause warnings if they're dereferenced when maybe-null  and the
warning context is enabled.
Each variable has a default nullable state that depends on its nullability:
Nullable variables have a default null-st ate of maybe-null .
Non-nullable variables have a default null-st ate of not-null.
Nullable oblivious variables have a default null-st ate of not-null.
Before you enable nullable reference types, all declarations in your codebase are
nullable oblivious . That's important because it means all reference types have a default
null-st ate of not-null.
If your project uses Entity Framework Core, you should read their guidance on Working
with nullable reference types .
When you start your migration, you should start by enabling warnings only. All
declarations remain nullable oblivious , but you'll see warnings when you dereference a
value after its null-st ate changes to maybe-null . As you address these warnings, you'll be
checking against null in more locations, and your codebase becomes more resilient. T o
learn specific techniques for different situations, see the article on Techniques to resolve
nullable warnings .
You can address warnings and enable annotations in each file or class before continuing
with other code. However, it's often more efficient to address the warnings generatedAddress warningswhile the context is warnings  before enabling the type annotations. That way, all types
are oblivious  until you've addressed the first set of warnings.
After addressing the first set of warnings, you can enable the annot ation c ontext. This
changes reference types from oblivious  to nonnullable . All variables declared with var
are nullable . This change often introduces new warnings. The first step in addressing the
compiler warnings is to use ? annotations on parameter and return types to indicate
when arguments or return values may be null. As you do this task, your goal isn't just
to fix warnings. The more important goal is to make the compiler understand your
intent for potential null values.
Several attributes have been added to express additional information about the null
state of variables. The rules for your APIs are likely more complicated than not-null or
maybe-null  for all parameters and return values. Many of your APIs have more complex
rules for when variables can or can't be null. In these cases, you'll use attributes to
express those rules. The attributes that describe the semantics of your API are found in
the article on Attributes that affect nullable analysis .
Once you've addressed all warnings after enabling annotations, you can set the default
context for your project to enabled . If you added any pragmas in your code for the
nullable annotation or warning context, you can remove them. Over time, you may see
new warnings. Y ou may write code that introduces warnings. A library dependency may
be updated for nullable reference types. Those updates will change the types in that
library from nullable oblivious  to either nonnullable  or nullable .
You can also explore these concepts in our Learn module on Nullable safety in C# .Enable type annotations
Attributes extend type annotations
Next stepsMethods in C#
Article •02/13/2023
A method is a code block that contains a series of statements. A program causes the
statements to be executed by calling the method and specifying any required method
arguments. In C#, every executed instruction is performed in the context of a method.
The Main method is the entry point for every C# application and it's called by the
common language runtime (CLR) when the program is started.
Methods are declared in a class, record, or struct by specifying:
An optional access level, such as public or private. The default is private.
Optional modifiers such as abstract or sealed.
The return value, or void if the method has none.
The method name.
Any method parameters. Method parameters are enclosed in parentheses and are
separated by commas. Empty parentheses indicate that the method requires no
parameters.
These parts together form the method signature.
The following example defines a class named Motorcycle that contains five methods:
C#７ Note
This topic discusses named methods. For information about anonymous functions,
see Lambda expr essions .
Method signatures
） Impor tant
A return type of a method is not part of the signature of the method for the
purposes of method overloading. However, it is part of the signature of the method
when determining the compatibility between a delegate and the method that it
points to.The Motorcycle class includes an overloaded method, Drive. Two methods have the
same name, but must be differentiated by their parameter types.
Methods can be either instance or static. Invoking an instance method requires that you
instantiate an object and call the method on that object; an instance method operates
on that instance and its data. Y ou invoke a static method by referencing the name of the
type to which the method belongs; static methods don't operate on instance data.
Attempting to call a static method through an object instance generates a compiler
error.
Calling a method is like accessing a field. After the object name (if you're calling an
instance method) or the type name (if you're calling a static method), add a period,
the name of the method, and parentheses. Arguments are listed within the parentheses
and are separated by commas.
The method definition specifies the names and types of any parameters that are
required. When a caller invokes the method, it provides concrete values, called
arguments, for each parameter. The arguments must be compatible with the parameter
type, but the argument name, if one is used in the calling code, doesn't have to be the
same as the parameter named defined in the method. In the following example, the
Square method includes a single parameter of type int named i. The first method callusing System;
abstract  class Motorcycle
{
// Anyone can call this.
public void StartEngine () {/* Method statements here <em>/  }
// Only derived classes can call this.
protected  void AddGas(int gallons ) { /</em> Method statements here <em>/  }
// Derived classes can override the base class implementation.
public virtual int Drive(int miles, int speed) { /</em> Method statements<br />
here <em>/ return 1; }
// Derived classes can override the base class implementation.
public virtual int Drive(TimeSpan time, int speed) { /</em> Method<br />
statements here */  return 0; }
// Derived classes must implement this.
public abstract  double GetTopSpeed ();
}
Method invocationpasses the Square method a variable of type int named num; the second, a numeric
constant; and the third, an expression.
C#
The most common form of method invocation used positional arguments; it supplies
arguments in the same order as method parameters. The methods of the Motorcycle
class can therefore be called as in the following example. The call to the Drive method,
for example, includes two arguments that correspond to the two parameters in the
method's syntax. The first becomes the value of the miles parameter, the second the
value of the speed parameter.
C#public class SquareExample
{
public static void Main()
{
// Call with an int variable.
int num = 4;
int productA = Square(num);
// Call with an integer literal.
int productB = Square( 12);
// Call with an expression that evaluates to int.
int productC = Square(productA * 3);
}
static int Square(int i)
{
// Store input argument in a local variable.
int input = i;
return input * input;
}
}
class TestMotorcycle  : Motorcycle
{
public override  double GetTopSpeed ()
{
return 108.4;
}
static void Main()
{
TestMotorcycle moto = new TestMotorcycle();
moto.StartEngine();You can also use named ar guments  instead of positional arguments when invoking a
method. When using named arguments, you specify the parameter name followed by a
colon (&quot;:&quot;) and the argument. Arguments to the method can appear in any order, as long
as all required arguments are present. The following example uses named arguments to
invoke the TestMotorcycle.Drive method. In this example, the named arguments are
passed in the opposite order from the method's parameter list.
C#
You can invoke a method using both positional arguments and named arguments.
However, positional arguments can only follow named arguments when the named
arguments are in the correct positions. The following example invokes the
TestMotorcycle.Drive method from the previous example using one positional
argument and one named argument.        moto.AddGas( 15);
moto.Drive( 5, 20);
double speed = moto.GetTopSpeed();
Console.WriteLine( &quot;My top speed is {0}&quot; , speed);
}
}
using System;
class TestMotorcycle  : Motorcycle
{
public override  int Drive(int miles, int speed)
{
return (int)Math.Round((( double)miles) / speed, 0);
}
public override  double GetTopSpeed ()
{
return 108.4;
}
static void Main()
{
TestMotorcycle moto = new TestMotorcycle();
moto.StartEngine();
moto.AddGas( 15);
var travelTime = moto.Drive(speed: 60, miles: 170);
Console.WriteLine( &quot;Travel time: approx. {0} hours&quot; , travelTime);
}
}
// The example displays the following output:
//      Travel time: approx. 3 hoursC#
In addition to the members that are explicitly defined in a type, a type inherits members
defined in its base classes. Since all types in the managed type system inherit directly or
indirectly from the Object  class, all types inherit its members, such as Equals(Object) ,
GetType() , and ToString() . The following example defines a Person class, instantiates two
Person objects, and calls the Person.Equals method to determine whether the two
objects are equal. The Equals method, however, isn't defined in the Person class; it's
inherited from Object .
C#
Types can override inherited members by using the override keyword and providing an
implementation for the overridden method. The method signature must be the same as
that of the overridden method. The following example is like the previous one, except
that it overrides the Equals(Object)  method. (It also overrides the GetHashCode()
method, since the two methods are intended to provide consistent results.)
C#var travelTime = moto.Drive( 170, speed: 55);
Inherited and overridden methods
using System;
public class Person
{
public String FirstName;
}
public class ClassTypeExample
{
public static void Main()
{
var p1 = new Person();
p1.FirstName = &quot;John&quot;;
var p2 = new Person();
p2.FirstName = &quot;John&quot;;
Console.WriteLine( &quot;p1 = p2: {0}&quot; , p1.Equals(p2));
}
}
// The example displays the following output:
//      p1 = p2: FalseTypes in C# are either value types  or reference types . For a list of built-in value types, see
Types. By default, both value types and reference types are passed to a method by
value.
When a value type is passed to a method by value, a copy of the object instead of the
object itself is passed to the method. Therefore, changes to the object in the called
method have no effect on the original object when control returns to the caller.using System;
public class Person
{
public String FirstName;
public override  bool Equals(object obj)
{
var p2 = obj as Person;
if (p2 == null)
return false;
else
return FirstName.Equals(p2.FirstName);
}
public override  int GetHashCode ()
{
return FirstName.GetHashCode();
}
}
public class Example
{
public static void Main()
{
var p1 = new Person();
p1.FirstName = &quot;John&quot;;
var p2 = new Person();
p2.FirstName = &quot;John&quot;;
Console.WriteLine( &quot;p1 = p2: {0}&quot; , p1.Equals(p2));
}
}
// The example displays the following output:
//      p1 = p2: True
Passing parameters
Passing parameters by valueThe following example passes a value type to a method by value, and the called method
attempts to change the value type's value. It defines a variable of type int, which is a
value type, initializes its value to 20, and passes it to a method named ModifyValue that
changes the variable's value to 30. When the method returns, however, the variable's
value remains unchanged.
C#
When an object of a reference type is passed to a method by value, a reference to the
object is passed by value. That is, the method receives not the object itself, but an
argument that indicates the location of the object. If you change a member of the
object by using this reference, the change is reflected in the object when control returns
to the calling method. However, replacing the object passed to the method has no
effect on the original object when control returns to the caller.
The following example defines a class (which is a reference type) named SampleRefType.
It instantiates a SampleRefType object, assigns 44 to its value field, and passes the
object to the ModifyObject method. This example does essentially the same thing as the
previous example—it passes an argument by value to a method. But because a
reference type is used, the result is different. The modification that is made in
ModifyObject to the obj.value field also changes the value field of the argument, rt,
in the Main method to 33, as the output from the example shows.using System;
public class ByValueExample
{
public static void Main()
{
int value = 20;
Console.WriteLine( &quot;In Main, value = {0}&quot; , value);
ModifyValue( value);
Console.WriteLine( &quot;Back in Main, value = {0}&quot; , value);
}
static void ModifyValue (int i)
{
i = 30;
Console.WriteLine( &quot;In ModifyValue, parameter value = {0}&quot; , i);
return;
}
}
// The example displays the following output:
//      In Main, value = 20
//      In ModifyValue, parameter value = 30
//      Back in Main, value = 20C#
You pass a parameter by reference when you want to change the value of an argument
in a method and want to reflect that change when control returns to the calling method.
To pass a parameter by reference, you use the ref or out keyword. Y ou can also pass a
value by reference to avoid copying but still prevent modifications using the in keyword.
The following example is identical to the previous one, except the value is passed by
reference to the ModifyValue method. When the value of the parameter is modified in
the ModifyValue method, the change in value is reflected when control returns to the
caller.
C#using System;
public class SampleRefType
{
public int value;
}
public class ByRefTypeExample
{
public static void Main()
{
var rt = new SampleRefType();
rt.value = 44;
ModifyObject(rt);
Console.WriteLine(rt. value);
}
static void ModifyObject (SampleRefType obj )
{
obj.value = 33;
}
}
Passing parameters by reference
using System;
public class ByRefExample
{
public static void Main()
{
int value = 20;
Console.WriteLine( &quot;In Main, value = {0}&quot; , value);
ModifyValue( ref value);
Console.WriteLine( &quot;Back in Main, value = {0}&quot; , value);A common pattern that uses by ref parameters involves swapping the values of
variables. Y ou pass two variables to a method by reference, and the method swaps their
contents. The following example swaps integer values.
C#
Passing a reference-type parameter allows you to change the value of the reference
itself, rather than the value of its individual elements or fields.   }
static void ModifyValue (ref int i)
{
i = 30;
Console.WriteLine( &quot;In ModifyValue, parameter value = {0}&quot; , i);
return;
}
}
// The example displays the following output:
//      In Main, value = 20
//      In ModifyValue, parameter value = 30
//      Back in Main, value = 30
using System;
public class RefSwapExample
{
static void Main()
{
int i = 2, j = 3;
System.Console.WriteLine( &quot;i = {0}  j = {1}&quot;  , i, j);
Swap(ref i, ref j);
System.Console.WriteLine( &quot;i = {0}  j = {1}&quot;  , i, j);
}
static void Swap(ref int x, ref int y)
{
int temp = x;
x = y;
y = temp;
}
}
// The example displays the following output:
//      i = 2  j = 3
//      i = 3  j = 2
Parameter arraysSometimes, the requirement that you specify the exact number of arguments to your
method is restrictive. By using the params keyword to indicate that a parameter is a
parameter array, you allow your method to be called with a variable number of
arguments. The parameter tagged with the params keyword must be an array type, and
it must be the last parameter in the method's parameter list.
A caller can then invoke the method in either of four ways:
By passing an array of the appropriate type that contains the desired number of
elements.
By passing a comma-separated list of individual arguments of the appropriate type
to the method.
By passing null.
By not providing an argument to the parameter array.
The following example defines a method named GetVowels that returns all the vowels
from a parameter array. The Main method illustrates all four ways of invoking the
method. Callers aren't required to supply any arguments for parameters that include the
params modifier. In that case, the parameter is an empty array.
C#
using System;
using System.Linq;
class ParamsExample
{
static void Main()
{
string fromArray = GetVowels( new[] { &quot;apple&quot;, &quot;banana&quot; , &quot;pear&quot; });
Console.WriteLine( $&quot;Vowels from array: ' {fromArray} '&quot;);
string fromMultipleArguments = GetVowels( &quot;apple&quot;, &quot;banana&quot; , &quot;pear&quot;);
Console.WriteLine( $&quot;Vowels from multiple arguments:<br />
'{fromMultipleArguments} '&quot;);</p>
<pre><code> string fromNull = GetVowels( null);
 Console.WriteLine( $&quot;Vowels from null: ' {fromNull} '&quot;);
 string fromNoValue = GetVowels();
 Console.WriteLine( $&quot;Vowels from no value: ' {fromNoValue} '&quot;);
</code></pre>
<p>}
static string GetVowels (params string[] input )
{
if (input == null || input.Length == 0)
{
return string.Empty;
}A method definition can specify that its parameters are required or that they're optional.
By default, parameters are required. Optional parameters are specified by including the
parameter's default value in the method definition. When the method is called, if no
argument is supplied for an optional parameter, the default value is used instead.
The parameter's default value must be assigned by one of the following kinds of
expressions:
A constant, such as a literal string or number.
An expression of the form default(SomeType), where SomeType can be either a
value type or a reference type. If it's a reference type, it's effectively the same as
specifying null. You can use the default literal, as the compiler can infer the type
from the parameter's declaration.
An expression of the form new ValType(), where ValType is a value type. This
invokes the value type's implicit parameterless constructor, which isn't an actual
member of the type.        var vowels = new char[] { 'A', 'E', 'I', 'O', 'U' };
return string.Concat(
input.SelectMany(
word =&gt; word.Where(letter =&gt;<br />
vowels.Contains( char.ToUpper(letter)))));
}
}
// The example displays the following output:
//     Vowels from array: 'aeaaaea'
//     Vowels from multiple arguments: 'aeaaaea'
//     Vowels from null: ''
//     Vowels from no value: ''
Optional parameters and arguments
７ Note
In C# 10 and later, when an expression of the form new ValType() invokes the
explicitly defined parameterless constructor of a value type, the compiler
generates an error as the default parameter value must be a compile-time
constant. Use the default(ValType) expression or the default literal to
provide the default parameter value. For more information aboutIf a method includes both required and optional parameters, optional parameters are
defined at the end of the parameter list, after all required parameters.
The following example defines a method, ExampleMethod, that has one required and two
optional parameters.
C#
If a method with multiple optional arguments is invoked using positional arguments, the
caller must supply an argument for all optional parameters from the first one to the last
one for which an argument is supplied. In the case of the ExampleMethod method, for
example, if the caller supplies an argument for the description parameter, it must also
supply one for the optionalInt parameter. opt.ExampleMethod(2, 2, &quot;Addition of 2 and
2&quot;); is a valid method call; opt.ExampleMethod(2, , &quot;Addition of 2 and 0&quot;); generates
an &quot;Argument missing&quot; compiler error.
If a method is called using named arguments or a combination of positional and named
arguments, the caller can omit any arguments that follow the last positional argument in
the method call.
The following example calls the ExampleMethod method three times. The first two
method calls use positional arguments. The first omits both optional arguments, while
the second omits the last argument. The third method call supplies a positional
argument for the required parameter but uses a named argument to supply a value to
the description parameter while omitting the optionalInt argument.
C#parameterless constructors, see the Struct initialization and default v alues
section of the Structur e types  article.
using System;
public class Options
{
public void ExampleMethod (int required, int optionalInt = default,
string? description = default)
{
var msg = $&quot;{description ?? &quot;N/A&quot;}: {required}  + {optionalInt}  = 
{required + optionalInt} &quot;;
Console.WriteLine(msg);
}
}The use of optional parameters affects overload resolution , or the way in which the C#
compiler determines which particular overload should be invoked by a method call, as
follows:
A method, indexer, or constructor is a candidate for execution if each of its
parameters either is optional or corresponds, by name or by position, to a single
argument in the calling statement, and that argument can be converted to the
type of the parameter.
If more than one candidate is found, overload resolution rules for preferred
conversions are applied to the arguments that are explicitly specified. Omitted
arguments for optional parameters are ignored.
If two candidates are judged to be equally good, preference goes to a candidate
that doesn't have optional parameters for which arguments were omitted in the
call. This is a consequence of a general preference in overload resolution for
candidates that have fewer parameters.
Methods can return a value to the caller. If the return type (the type listed before the
method name) isn't void, the method can return the value by using the return
keyword. A statement with the return keyword followed by a variable, constant, or
expression that matches the return type will return that value to the method caller.
Methods with a non-void return type are required to use the return keyword to return
a value. The return keyword also stops the execution of the method.
If the return type is void, a return statement without a value is still useful to stop the
execution of the method. Without the return keyword, the method will stop executing
when it reaches the end of the code block.public class OptionsExample
{
public static void Main()
{
var opt = new Options();
opt.ExampleMethod( 10);
opt.ExampleMethod( 10, 2);
opt.ExampleMethod( 12, description: &quot;Addition with zero:&quot; );
}
}
// The example displays the following output:
//      N/A: 10 + 0 = 10
//      N/A: 10 + 2 = 12
//      Addition with zero:: 12 + 0 = 12
Return valuesFor example, these two methods use the return keyword to return integers:
C#
To use a value returned from a method, the calling method can use the method call
itself anywhere a value of the same type would be sufficient. Y ou can also assign the
return value to a variable. For example, the following two code examples accomplish the
same goal:
C#
C#
Using a local variable, in this case, result, to store a value is optional. It may help the
readability of the code, or it may be necessary if you need to store the original value of
the argument for the entire scope of the method.
Sometimes, you want your method to return more than a single value. Y ou can do this
easily by using tuple types  and tuple lit erals. The tuple type defines the data types of the
tuple's elements. Tuple literals provide the actual values of the returned tuple. In the
following example, (string, string, string, int) defines the tuple type that is
returned by the GetPersonalInfo method. The expression (per.FirstName,class SimpleMath
{
public int AddTwoNumbers (int number1, int number2 )
{
return number1 + number2;
}
public int SquareANumber (int number)
{
return number * number;
}
}
int result = obj.AddTwoNumbers( 1, 2);
result = obj.SquareANumber(result);
// The result is 9.
Console.WriteLine(result);
result = obj.SquareANumber(obj.AddTwoNumbers( 1, 2));
// The result is 9.
Console.WriteLine(result);per.MiddleName, per.LastName, per.Age) is the tuple literal; the method returns the first,
middle, and last name, along with the age, of a PersonInfo object.
C#
The caller can then consume the returned tuple with code like the following:
C#
Names can also be assigned to the tuple elements in the tuple type definition. The
following example shows an alternate version of the GetPersonalInfo method that uses
named elements:
C#
The previous call to the GetPersonalInfo method can then be modified as follows:
C#
If a method is passed an array as an argument and modifies the value of individual
elements, it isn't necessary for the method to return the array, although you may choose
to do so for good style or functional flow of values. This is because C# passes all
reference types by value, and the value of an array reference is the pointer to the array.
In the following example, changes to the contents of the values array that are made in
the DoubleValues method are observable by any code that has a reference to the array.public (string, string, string, int) GetPersonalInfo( string id)
{
PersonInfo per = PersonInfo.RetrieveInfoById(id);
return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
var person = GetPersonalInfo( &quot;111111111&quot; );
Console.WriteLine( $&quot;{person.Item1}  {person.Item3} : age = {person.Item4} &quot;);
public (string FName, string MName, string LName, int Age) 
GetPersonalInfo( string id)
{
PersonInfo per = PersonInfo.RetrieveInfoById(id);
return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
var person = GetPersonalInfo( &quot;111111111&quot; );
Console.WriteLine( $&quot;{person.FName}  {person.LName} : age = {person.Age} &quot;);C#
Ordinarily, there are two ways to add a method to an existing type:
Modify the source code for that type. Y ou can't do this, of course, if you don't own
the type's source code. And this becomes a breaking change if you also add any
private data fields to support the method.
Define the new method in a derived class. A method can't be added in this way
using inheritance for other types, such as structures and enumerations. Nor can it
be used to &quot;add&quot; a method to a sealed class.
Extension methods let you &quot;add&quot; a method to an existing type without modifying the
type itself or implementing the new method in an inherited type. The extension method
also doesn't have to reside in the same assembly as the type it extends. Y ou call an
extension method as if it were a defined member of a type.
For more information, see Extension Methods .
By using the async feature, you can invoke asynchronous methods without using explicit
callbacks or manually splitting your code across multiple methods or lambdausing System;
public class ArrayValueExample
{
static void Main(string[] args)
{
int[] values = { 2, 4, 6, 8 };
DoubleValues(values);
foreach (var value in values)
Console.Write( &quot;{0}  &quot;, value);
}
public static void DoubleValues (int[] arr)
{
for (int ctr = 0; ctr &lt;= arr.GetUpperBound( 0); ctr++)
arr[ctr] = arr[ctr] * 2;
}
}
// The example displays the following output:
//       4  8  12  16
Extension methods
Async Methodsexpressions.
If you mark a method with the async  modifier, you can use the await  operator in the
method. When control reaches an await expression in the async method, control
returns to the caller if the awaited task isn't completed, and progress in the method with
the await keyword is suspended until the awaited task completes. When the task is
complete, execution can resume in the method.
An async method typically has a return type of Task<TR esult> , Task,
IAsyncEnumerable<T> or void. The void return type is used primarily to define event
handlers, where a void return type is required. An async method that returns void can't
be awaited, and the caller of a void-returning method can't catch exceptions that the
method throws. An async method can have any task-like return type .
In the following example, DelayAsync is an async method that has a return statement
that returns an integer. Because it's an async method, its method declaration must have
a return type of Task<int>. Because the return type is Task<int>, the evaluation of the
await expression in DoSomethingAsync produces an integer, as the following int result
= await delayTask statement demonstrates.
C#７ Note
An async method returns to the caller when either it encounters the first awaited
object that's not yet complete or it gets to the end of the async method, whichever
occurs first.
class Program
{
static Task Main() =&gt; DoSomethingAsync();
static async Task DoSomethingAsync ()
{
Task<int> delayTask = DelayAsync();
int result = await delayTask;
// The previous two statements may be combined into
// the following statement.
//int result = await DelayAsync();
Console.WriteLine( $&quot;Result: {result} &quot;);
}
static async Task<int> DelayAsync ()
{An async method can't declare any in, ref, or out parameters, but it can call methods
that have such parameters.
For more information about async methods, see Asynchronous programming with async
and await  and Async return types .
It's common to have method definitions that simply return immediately with the result
of an expression, or that have a single statement as the body of the method. There's a
syntax shortcut for defining such methods using =&gt;:
C#
If the method returns void or is an async method, the body of the method must be a
statement expression (same as with lambdas). For properties and indexers, they must be
read-only, and you don't use the get accessor keyword.
An iterator performs a custom iteration over a collection, such as a list or an array. An
iterator uses the yield return  statement to return each element one at a time. When a
yield return statement is reached, the current location is remembered so that the
caller can request the next element in the sequence.
The return type of an iterator can be IEnumerable , IEnumerable<T> ,
IAsyncEnumerable<T> , IEnumerator , or IEnumerator<T> .
For more information, see Iterators .        await Task.Delay( 100);
return 5;
}
}
// Example output:
//   Result: 5
Expression-bodied members
public Point Move(int dx, int dy) =&gt; new Point(x + dx, y + dy);
public void Print() =&gt; Console.WriteLine(First + &quot; &quot; + Last);
// Works with operators, properties, and indexers too.
public static Complex operator  +(Complex a, Complex b) =&gt; a.Add(b);
public string Name =&gt; First + &quot; &quot; + Last;
public Customer this[long id] =&gt; store.LookupCustomer(id);
IteratorsAccess Modifiers
Static Classes and S tatic Class Members
Inheritance
Abstract and Sealed Classes and Class Members
params
out
ref
in
Passing P arametersSee also
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide ..NET feedb ack
The .NET documentation is open
source. Provide feedback here.
 Open a documentation issue
 Provide product feedbackProperties
Article •09/29/2022
Properties are first class citizens in C#. The language defines syntax that enables
developers to write code that accurately expresses their design intent.
Properties behave like fields when they're accessed. However, unlike fields, properties
are implemented with accessors that define the statements executed when a property is
accessed or assigned.
The syntax for properties is a natural extension to fields. A field defines a storage
location:
C#
A property definition contains declarations for a get and set accessor that retrieves
and assigns the value of that property:
C#
The syntax shown above is the auto property syntax. The compiler generates the storage
location for the field that backs up the property. The compiler also implements the body
of the get and set accessors.
Sometimes, you need to initialize a property to a value other than the default for its
type. C# enables that by setting a value after the closing brace for the property. Y ou mayProperty syntax
public class Person
{
public string? FirstName;
// Omitted for brevity.
}
public class Person
{
public string? FirstName { get; set; }
// Omitted for brevity.
}prefer the initial value for the FirstName property to be the empty string rather than
null. You would specify that as shown below:
C#
Specific initialization is most useful for read-only properties, as you'll see later in this
article.
You can also define the storage yourself, as shown below:
C#
When a property implementation is a single expression, you can use expression-bodied
member s for the getter or setter:
C#public class Person
{
public string FirstName { get; set; } = string.Empty;
// Omitted for brevity.
}
public class Person
{
public string? FirstName
{
get { return _firstName; }
set { _firstName = value; }
}
private string? _firstName;
// Omitted for brevity.
}
public class Person
{
public string? FirstName
{
get =&gt; _firstName;
set =&gt; _firstName = value;
}
private string? _firstName;
// Omitted for brevity.
}This simplified syntax will be used where applicable throughout this article.
The property definition shown above is a read-write property. Notice the keyword value
in the set accessor. The set accessor always has a single parameter named value. The
get accessor must return a value that is convertible to the type of the property ( string
in this example).
That's the basics of the syntax. There are many different variations that support various
different design idioms. Let's explore, and learn the syntax options for each.
The examples above showed one of the simplest cases of property definition: a read-
write property with no validation. By writing the code you want in the get and set
accessors, you can create many different scenarios.
You can write code in the set accessor to ensure that the values represented by a
property are always valid. For example, suppose one rule for the Person class is that the
name can't be blank or white space. Y ou would write that as follows:
C#
The preceding example can be simplified by using a throw expression as part of the
property setter validation:
C#Validation
public class Person
{
public string? FirstName
{
get =&gt; _firstName;
set
{
if (string.IsNullOrWhiteSpace( value))
throw new ArgumentException( &quot;First name must not be blank&quot; );
_firstName = value;
}
}
private string? _firstName;
// Omitted for brevity.
}
public class Person
{The example above enforces the rule that the first name must not be blank or white
space. If a developer writes
C#
That assignment throws an ArgumentException. Because a property set accessor must
have a void return type, you report errors in the set accessor by throwing an exception.
You can extend this same syntax to anything needed in your scenario. Y ou can check the
relationships between different properties, or validate against any external conditions.
Any valid C# statements are valid in a property accessor.
Up to this point, all the property definitions you have seen are read/write properties
with public accessors. That's not the only valid accessibility for properties. Y ou can create
read-only properties, or give different accessibility to the set and get accessors. Suppose
that your Person class should only enable changing the value of the FirstName property
from other methods in that class. Y ou could give the set accessor private accessibility
instead of public:
C#    public string? FirstName
{
get =&gt; _firstName;
set =&gt; _firstName = (! string.IsNullOrWhiteSpace( value)) ? value : 
throw new ArgumentException( &quot;First name must not be blank&quot; );
}
private string? _firstName;
// Omitted for brevity.
}
hero.FirstName = &quot;&quot;;
Access control
public class Person
{
public string? FirstName { get; private set; }
// Omitted for brevity.
}Now, the FirstName property can be accessed from any code, but it can only be
assigned from other code in the Person class.
You can add any restrictive access modifier to either the set or get accessors. Any access
modifier you place on the individual accessor must be more limited than the access
modifier on the property definition. The above is legal because the FirstName property
is public, but the set accessor is private. You couldn't declare a private property with
a public accessor. Property declarations can also be declared protected, internal,
protected internal, or, even private.
It's also legal to place the more restrictive modifier on the get accessor. For example,
you could have a public property, but restrict the get accessor to private. That
scenario is rarely done in practice.
You can also restrict modifications to a property so that it can only be set in a
constructor. Y ou can modify the Person class so as follows:
C#
The preceding example requires callers to use the constructor that includes the
FirstName parameter. Callers can't use object initializers  to assign a value to the
property. T o support initializers, you can make the set accessor an init accessor, as
shown in the following code:
C#Read-only
public class Person
{
public Person(string firstName ) =&gt; FirstName = firstName;
public string FirstName { get; }
// Omitted for brevity.
}
Init-only
public class Person
{
public Person() { }
public Person(string firstName ) =&gt; FirstName = firstName;The preceding example allows a caller to create a Person using the default constructor,
even when that code doesn't set the FirstName property. Beginning in C# 11, you can
requir e callers to set that property:
C#
The preceding code makes two additions to the Person class. First, the FirstName
property declaration includes the required modifier. That means any code that creates a
new Person must set this property. Second, the constructor that takes a firstName
parameter has the System.Diagnostics.CodeAnalysis.SetsR equiredMembersAttribute
attribute. This attribute informs the compiler that this constructor sets all required
members.
Callers must either use the constructor with SetsRequiredMembers or set the FirstName
property using an object initializer, as shown in the following code:
C#    public string? FirstName { get; init; }
// Omitted for brevity.
}
public class Person
{
public Person() { }
[SetsRequiredMembers ]
public Person(string firstName ) =&gt; FirstName = firstName;
public required string FirstName { get; init; }
// Omitted for brevity.
}
） Impor tant
Don't confuse required with non-nullable . It's valid to set a required property to
null or default. If the type is non-nullable, such as string in these examples, the
compiler issues a warning.
var person = new VersionNinePoint2.Person( &quot;John&quot;);
person = new VersionNinePoint2.Person{ FirstName = &quot;John&quot;};A property doesn't need to simply return the value of a member field. Y ou can create
properties that return a computed value. Let's expand the Person object to return the
full name, computed by concatenating the first and last names:
C#
The example above uses the string interpolation  feature to create the formatted string
for the full name.
You can also use an expression-bodied member , which provides a more succinct way to
create the computed FullName property:
C#
Expression-bodied member s use the lambda expr ession  syntax to define methods that
contain a single expression. Here, that expression returns the full name for the person
object.// Error CS9035: Required member <code>Person.FirstName</code> must be set:
//person = new VersionNinePoint2.Person();
Computed properties
public class Person
{
public string? FirstName { get; set; }
public string? LastName { get; set; }
public string FullName { get { return $&quot;{FirstName}  {LastName} &quot;; } }
}
public class Person
{
public string? FirstName { get; set; }
public string? LastName { get; set; }
public string FullName =&gt; $&quot;{FirstName}  {LastName} &quot;;
}
Cached evaluated propertiesYou can mix the concept of a computed property with storage and create a cached
evaluat ed pr operty. For example, you could update the FullName property so that the
string formatting only happened the first time it was accessed:
C#
The above code contains a bug though. If code updates the value of either the
FirstName or LastName property, the previously evaluated fullName field is invalid. Y ou
modify the set accessors of the FirstName and LastName property so that the fullName
field is calculated again:
C#public class Person
{
public string? FirstName { get; set; }
public string? LastName { get; set; }
private string? _fullName;
public string FullName
{
get
{
if (_fullName is null)
_fullName = $&quot;{FirstName}  {LastName} &quot;;
return _fullName;
}
}
}
public class Person
{
private string? _firstName;
public string? FirstName
{
get =&gt; _firstName;
set
{
_firstName = value;
_fullName = null;
}
}
private string? _lastName;
public string? LastName
{
get =&gt; _lastName;
set
{This final version evaluates the FullName property only when needed. If the previously
calculated version is valid, it's used. If another state change invalidates the previously
calculated version, it will be recalculated. Developers that use this class don't need to
know the details of the implementation. None of these internal changes affect the use
of the P erson object. That's the key reason for using Properties to expose data members
of an object.
Field attributes can be attached to the compiler generated backing field in auto-
implemented properties. For example, consider a revision to the Person class that adds
a unique integer Id property. Y ou write the Id property using an auto-implemented
property, but your design doesn't call for persisting the Id property. The
NonSerializedAttribute  can only be attached to fields, not properties. Y ou can attach the
NonSerializedAttribute  to the backing field for the Id property by using the field:
specifier on the attribute, as shown in the following example:
C#            _lastName = value;
_fullName = null;
}
}
private string? _fullName;
public string FullName
{
get
{
if (_fullName is null)
_fullName = $&quot;{FirstName}  {LastName} &quot;;
return _fullName;
}
}
}
Attaching attributes to auto-implemented
properties
public class Person
{
public string? FirstName { get; set; }
public string? LastName { get; set; }
[field:NonSerialized ]
public int Id { get; set; }This technique works for any attribute you attach to the backing field on the auto-
implemented property.
A final scenario where you need to write code in a property accessor is to support the
INotifyPropertyChanged  interface used to notify data binding clients that a value has
changed. When the value of a property changes, the object raises the
INotifyPropertyChanged.PropertyChanged  event to indicate the change. The data
binding libraries, in turn, update display elements based on that change. The code
below shows how you would implement INotifyPropertyChanged for the FirstName
property of this person class.
C#
The ?. operator is called the null c onditional oper ator. It checks for a null reference
before evaluating the right side of the operator. The end result is that if there are no
subscribers to the PropertyChanged event, the code to raise the event doesn't execute. It
would throw a NullReferenceException without this check in that case. For more
information, see events . This example also uses the new nameof operator to convert    public string FullName =&gt; $&quot;{FirstName}  {LastName} &quot;;
}
Implementing  INotifyPropertyChanged
public class Person : INotifyPropertyChanged
{
public string? FirstName
{
get =&gt; _firstName;
set
{
if (string.IsNullOrWhiteSpace( value))
throw new ArgumentException( &quot;First name must not be blank&quot; );
if (value != _firstName)
{
_firstName = value;
PropertyChanged?.Invoke( this,
new PropertyChangedEventArgs( nameof(FirstName)));
}
}
}
private string? _firstName;
public event PropertyChangedEventHandler? PropertyChanged;
}from the property name symbol to its text representation. Using nameof can reduce
errors where you've mistyped the name of the property.
Again, implementing INotifyPropertyChanged  is an example of a case where you can
write code in your accessors to support the scenarios you need.
Properties are a form of smart fields in a class or object. From outside the object, they
appear like fields in the object. However, properties can be implemented using the full
palette of C# functionality. Y ou can provide validation, different accessibility, lazy
evaluation, or any requirements your scenarios need.Summing upIndexers
Article •12/04/2021
Index ers are similar to properties. In many ways indexers build on the same language
features as properties . Indexers enable index ed properties: properties referenced using
one or more arguments. Those arguments provide an index into some collection of
values.
You access an indexer through a variable name and square brackets. Y ou place the
indexer arguments inside the brackets:
C#
You declare indexers using the this keyword as the property name, and declaring the
arguments within square brackets. This declaration would match the usage shown in the
previous paragraph:
C#
From this initial example, you can see the relationship between the syntax for properties
and for indexers. This analogy carries through most of the syntax rules for indexers.
Indexers can have any valid access modifiers (public, protected internal, protected,
internal, private or private protected). They may be sealed, virtual, or abstract. As with
properties, you can specify different access modifiers for the get and set accessors in an
indexer. Y ou may also specify read-only indexers (by omitting the set accessor), or write-
only indexers (by omitting the get accessor).
You can apply almost everything you learn from working with properties to indexers.
The only exception to that rule is auto implement ed pr operties. The compiler cannot
always generate the correct storage for an indexer.Indexer Syntax
var item = someObject[ &quot;key&quot;]; 
someObject[ &quot;AnotherKey&quot; ] = item;<br />
public int this[string key] 
{ 
get { return storage.Find(key); }<br />
set { storage.SetAt(key, value); } 
} The presence of arguments to reference an item in a set of items distinguishes indexers
from properties. Y ou may define multiple indexers on a type, as long as the argument
lists for each indexer is unique. Let's explore different scenarios where you might use
one or more indexers in a class definition.
You would define index ers in your type when its API models some collection where you
define the arguments to that collection. Y our indexers may or may not map directly to
the collection types that are part of the .NET core framework. Y our type may have other
responsibilities in addition to modeling a collection. Indexers enable you to provide the
API that matches your type's abstraction without exposing the inner details of how the
values for that abstraction are stored or computed.
Let's walk through some of the common scenarios for using index ers. You can access the
sample folder for indexers . For download instructions, see Samples and Tutorials .
One of the most common scenarios for creating indexers is when your type models an
array, or a vector. Y ou can create an indexer to model an ordered list of data.
The advantage of creating your own indexer is that you can define the storage for that
collection to suit your needs. Imagine a scenario where your type models historical data
that is too large to load into memory at once. Y ou need to load and unload sections of
the collection based on usage. The example following models this behavior. It reports
on how many data points exist. It creates pages to hold sections of the data on demand.
It removes pages from memory to make room for pages needed by more recent
requests.
C#Scenarios
Arrays and Vectors
public class DataSamples<br />
{ 
private class Page 
{ 
private readonly  List<Measurements> pageData = new 
List<Measurements>();<br />
private readonly  int startingIndex;<br />
private readonly  int length;<br />
private bool dirty; 
private DateTime lastAccess;<br />
public Page(int startingIndex, int length) 
{              this.startingIndex = startingIndex;<br />
this.length = length;<br />
lastAccess = DateTime.Now;<br />
// This stays as random stuff:<br />
var generator = new Random();<br />
for(int i=0; i &lt; length; i++)<br />
{<br />
var m = new Measurements<br />
{<br />
HiTemp = generator.Next( 50, 95), 
LoTemp = generator.Next( 12, 49), 
AirPressure = 28.0 + generator.NextDouble() * 4 
};<br />
pageData.Add(m);<br />
}<br />
}<br />
public bool HasItem(int index) =&gt; 
((index &gt;= startingIndex) &amp;&amp;<br />
(index &lt; startingIndex + length));<br />
public Measurements this[int index] 
{<br />
get 
{<br />
lastAccess = DateTime.Now;<br />
return pageData[index - startingIndex];<br />
}<br />
set 
{<br />
pageData[index - startingIndex] = value; 
dirty = true; 
lastAccess = DateTime.Now;<br />
}<br />
}<br />
public bool Dirty =&gt; dirty;<br />
public DateTime LastAccess =&gt; lastAccess;<br />
} 
private readonly  int totalSize;<br />
private readonly  List<Page> pagesInMemory = new List<Page>();<br />
public DataSamples (int totalSize ) 
{ 
this.totalSize = totalSize;<br />
} 
public Measurements this[int index] 
{ 
get 
{<br />
if (index &lt; 0) 
throw new IndexOutOfRangeException( &quot;Cannot index less than<br />
0&quot;);             if (index &gt;= totalSize)<br />
throw new IndexOutOfRangeException( &quot;Cannot index past the<br />
end of storage&quot; ); 
var page = updateCachedPagesForAccess(index);<br />
return page[index];<br />
}<br />
set 
{<br />
if (index &lt; 0) 
throw new IndexOutOfRangeException( &quot;Cannot index less than<br />
0&quot;); 
if (index &gt;= totalSize)<br />
throw new IndexOutOfRangeException( &quot;Cannot index past the<br />
end of storage&quot; ); 
var page = updateCachedPagesForAccess(index);<br />
page[index] = value; 
}<br />
} 
private Page updateCachedPagesForAccess (int index) 
{ 
foreach (var p in pagesInMemory)<br />
{<br />
if (p.HasItem(index))<br />
{<br />
return p; 
}<br />
}<br />
var startingIndex = (index / 1000) * 1000; 
var newPage = new Page(startingIndex, 1000); 
addPageToCache(newPage);<br />
return newPage;<br />
} 
private void addPageToCache (Page p) 
{ 
if (pagesInMemory.Count &gt; 4) 
{<br />
// remove oldest non-dirty page:<br />
var oldest = pagesInMemory<br />
.Where(page =&gt; !page.Dirty)<br />
.OrderBy(page =&gt; page.LastAccess)<br />
.FirstOrDefault();<br />
// Note that this may keep more than 5 pages in memory
// if too much is dirty<br />
if (oldest != null) 
pagesInMemory.Remove(oldest);<br />
}<br />
pagesInMemory.Add(p);<br />
} 
} You can follow this design idiom to model any sort of collection where there are good
reasons not to load the entire set of data into an in-memory collection. Notice that the
Page class is a private nested class that is not part of the public interface. Those details
are hidden from any users of this class.
Another common scenario is when you need to model a dictionary or a map. This
scenario is when your type stores values based on key, typically text keys. This example
creates a dictionary that maps command line arguments to lambda expressions  that
manage those options. The following example shows two classes: an ArgsActions class
that maps a command line option to an Action delegate, and an ArgsProcessor that
uses the ArgsActions to execute each Action when it encounters that option.
C#Dictionaries
public class ArgsProcessor<br />
{ 
private readonly  ArgsActions actions;<br />
public ArgsProcessor (ArgsActions actions ) 
{ 
this.actions = actions;<br />
} 
public void Process(string[] args) 
{ 
foreach(var arg in args) 
{<br />
actions[arg]?.Invoke();<br />
}<br />
} 
} 
public class ArgsActions<br />
{ 
readonly  private Dictionary&lt; string, Action&gt; argsActions = new 
Dictionary&lt; string, Action&gt;();<br />
public Action this[string s] 
{ 
get 
{<br />
Action action;<br />
Action defaultAction = () =&gt; {} ;<br />
return argsActions.TryGetValue(s, out action) ? action :<br />
defaultAction;<br />
}<br />
} In this example, the ArgsAction collection maps closely to the underlying collection. The
get determines if a given option has been configured. If so, it returns the Action
associated with that option. If not, it returns an Action that does nothing. The public
accessor does not include a set accessor. Rather, the design is using a public method
for setting options.
You can create indexers that use multiple arguments. In addition, those arguments are
not constrained to be the same type. Let's look at two examples.
The first example shows a class that generates values for a Mandelbrot set. For more
information on the mathematics behind the set, read this article . The indexer uses two
doubles to define a point in the X, Y plane. The get accessor computes the number of
iterations until a point is determined to be not in the set. If the maximum iterations is
reached, the point is in the set, and the class's maxIterations value is returned. (The
computer generated images popularized for the Mandelbrot set define colors for the
number of iterations necessary to determine that a point is outside the set.)
C#    public void SetOption (string s, Action a ) 
{ 
argsActions[s] = a;<br />
} 
} 
Multi-Dimensional Maps
public class Mandelbrot
{ 
readonly  private int maxIterations;<br />
public Mandelbrot (int maxIterations ) 
{ 
this.maxIterations = maxIterations;<br />
} 
public int this [double x, double y] 
{ 
get 
{<br />
var iterations = 0; 
var x0 = x;<br />
var y0 = y;<br />
while ((x*x + y * y &lt; 4) &amp;&amp; 
(iterations &lt; maxIterations))  The Mandelbrot Set defines values at every (x,y) coordinate for real number values. That
defines a dictionary that could contain an infinite number of values. Therefore, there is
no storage behind the set. Instead, this class computes the value for each point when
code calls the get accessor. There's no underlying storage used.
Let's examine one last use of indexers, where the indexer takes multiple arguments of
different types. Consider a program that manages historical temperature data. This
indexer uses a city and a date to set or get the high and low temperatures for that
location:
C#            {<br />
var newX = x * x - y * y + x0;<br />
y = 2 * x * y + y0;<br />
x = newX;<br />
iterations++;<br />
}<br />
return iterations;<br />
}<br />
} 
} 
using DateMeasurements =<br />
System.Collections.Generic.Dictionary&lt;System.DateTime,<br />
IndexersSamples.Common.Measurements&gt;;<br />
using CityDataMeasurements =<br />
System.Collections.Generic.Dictionary&lt; string, 
System.Collections.Generic.Dictionary&lt;System.DateTime,<br />
IndexersSamples.Common.Measurements&gt;&gt;;<br />
public class HistoricalWeatherData<br />
{ 
readonly  CityDataMeasurements storage = new CityDataMeasurements();<br />
public Measurements this[string city, DateTime date]<br />
{ 
get 
{<br />
var cityData = default(DateMeasurements);<br />
if (!storage.TryGetValue(city, out cityData))<br />
throw new ArgumentOutOfRangeException( nameof(city), &quot;City 
not found&quot; ); 
// strip out any time portion:<br />
var index = date.Date;<br />
var measure = default(Measurements);<br />
if (cityData.TryGetValue(index, out measure))<br />
return measure;<br />
throw new ArgumentOutOfRangeException( nameof(date), &quot;Date not  This example creates an indexer that maps weather data on two different arguments: a
city (represented by a string) and a date (represented by a DateTime). The internal
storage uses two Dictionary classes to represent the two-dimensional dictionary. The
public API no longer represents the underlying storage. Rather, the language features of
indexers enables you to create a public interface that represents your abstraction, even
though the underlying storage must use different core collection types.
There are two parts of this code that may be unfamiliar to some developers. These two
using directives:
C#
create an alias for a constructed generic type. Those statements enable the code later to
use the more descriptive DateMeasurements and CityDataMeasurements names instead of
the generic construction of Dictionary&lt;DateTime, Measurements&gt; and
Dictionary&lt;string, Dictionary&lt;DateTime, Measurements&gt; &gt;. This construct does require
using the fully qualified type names on the right side of the = sign.
The second technique is to strip off the time portions of any DateTime object used to
index into the collections. .NET doesn't include a date-only type. Developers use thefound&quot;); 
}<br />
set 
{<br />
var cityData = default(DateMeasurements);<br />
if (!storage.TryGetValue(city, out cityData))<br />
{<br />
cityData = new DateMeasurements();<br />
storage.Add(city, cityData);<br />
}<br />
// Strip out any time portion:<br />
var index = date.Date;<br />
cityData[index] = value; 
}<br />
} 
} 
using DateMeasurements =<br />
System.Collections.Generic.Dictionary&lt;System.DateTime,<br />
IndexersSamples.Common.Measurements&gt;;<br />
using CityDataMeasurements = System.Collections.Generic.Dictionary&lt; string, 
System.Collections.Generic.Dictionary&lt;System.DateTime,<br />
IndexersSamples.Common.Measurements&gt;&gt;;  DateTime type, but use the Date property to ensure that any DateTime object from that
day are equal.
You should create indexers anytime you have a property-like element in your class
where that property represents not a single value, but rather a collection of values
where each individual item is identified by a set of arguments. Those arguments can
uniquely identify which item in the collection should be referenced. Indexers extend the
concept of properties , where a member is treated like a data item from outside the class,
but like a method on the inside. Indexers allow arguments to find a single item in a
property that represents a set of items.Summing UpIterators
Article •11/10/2021
Almost every program you write will have some need to iterate over a collection. Y ou'll
write code that examines every item in a collection.
You'll also create iterator methods, which are methods that produce an iterator for the
elements of that class. An iterator is an object that traverses a container, particularly lists.
Iterators can be used for:
Performing an action on each item in a collection.
Enumerating a custom collection.
Extending LINQ  or other libraries.
Creating a data pipeline where data flows efficiently through iterator methods.
The C# language provides features for both generating and consuming sequences.
These sequences can be produced and consumed synchronously or asynchronously.
This article provides an overview of those features.
Enumerating a collection is simple: The foreach keyword enumerates a collection,
executing the embedded statement once for each element in the collection:
C#
That's all. T o iterate over all the contents of a collection, the foreach statement is all you
need. The foreach statement isn't magic, though. It relies on two generic interfaces
defined in the .NET core library to generate the code necessary to iterate a collection:
IEnumerable<T> and IEnumerator<T>. This mechanism is explained in more detail below.
Both of these interfaces also have non-generic counterparts: IEnumerable and
IEnumerator. The generic  versions are preferred for modern code.
When a sequence is generated asynchronously, you can use the await foreach
statement to asynchronously consume the sequence:Iterating with foreach
foreach (var item in collection)<br />
{ 
Console.WriteLine(item?.ToString());<br />
} C#
When a sequence is an System.Collections.Generic.IEnumerable<T> , you use foreach.
When a sequence is an System.Collections.Generic.IAsyncEnumerable<T> , you use
await foreach. In the latter case, the sequence is generated asynchronously.
Another great feature of the C# language enables you to build methods that create a
source for an enumeration. These methods are referred to as iterator methods . An
iterator method defines how to generate the objects in a sequence when requested. Y ou
use the yield return contextual keywords to define an iterator method.
You could write this method to produce the sequence of integers from 0 through 9:
C#
The code above shows distinct yield return statements to highlight the fact that you
can use multiple discrete yield return statements in an iterator method. Y ou can (and
often do) use other language constructs to simplify the code of an iterator method. The
method definition below produces the exact same sequence of numbers:
C#await foreach (var item in asyncSequence)<br />
{ 
Console.WriteLine(item?.ToString());<br />
} 
Enum eration sources with iterator methods
public IEnumerable&lt; int&gt; GetSingleDigitNumbers () 
{ 
yield return 0; 
yield return 1; 
yield return 2; 
yield return 3; 
yield return 4; 
yield return 5; 
yield return 6; 
yield return 7; 
yield return 8; 
yield return 9; 
} 
public IEnumerable&lt; int&gt; GetSingleDigitNumbersLoop () 
{ 
int index = 0; You don't have to decide one or the other. Y ou can have as many yield return
statements as necessary to meet the needs of your method:
C#
All of these preceding examples would have an asynchronous counterpart. In each case,
you'd replace the return type of IEnumerable<T> with an IAsyncEnumerable<T>. For
example, the previous example would have the following asynchronous version:
C#
That's the syntax for both synchronous and asynchronous iterators. Let's consider a real
world example. Imagine you're on an IoT project and the device sensors generate a very    while (index &lt; 10) 
yield return index++;<br />
} 
public IEnumerable&lt; int&gt; GetSetsOfNumbers () 
{ 
int index = 0; 
while (index &lt; 10) 
yield return index++;<br />
yield return 50; 
index = 100; 
while (index &lt; 110)
yield return index++;<br />
} 
public async IAsyncEnumerable&lt; int&gt; GetSetsOfNumbersAsync () 
{ 
int index = 0; 
while (index &lt; 10) 
yield return index++;<br />
await Task.Delay( 500); 
yield return 50; 
await Task.Delay( 500); 
index = 100; 
while (index &lt; 110)
yield return index++;<br />
} large stream of data. T o get a feel for the data, you might write a method that samples
every Nth data element. This small iterator method does the trick:
C#
If reading from the IoT device produces an asynchronous sequence, you'd modify the
method as the following method shows:
C#
There's one important restriction on iterator methods: you can't have both a return
statement and a yield return statement in the same method. The following code won't
compile:
C#public static IEnumerable<T> Sample<T>( this IEnumerable<T> sourceSequence,<br />
int interval)<br />
{ 
int index = 0; 
foreach (T item in sourceSequence)<br />
{ 
if (index++ % interval == 0) 
yield return item; 
} 
} 
public static async IAsyncEnumerable<T> Sample<T>( this IAsyncEnumerable<T><br />
sourceSequence, int interval)<br />
{ 
int index = 0; 
await foreach (T item in sourceSequence)<br />
{ 
if (index++ % interval == 0) 
yield return item; 
} 
} 
public IEnumerable&lt; int&gt; GetSingleDigitNumbers () 
{ 
int index = 0; 
while (index &lt; 10) 
yield return index++;<br />
yield return 50; 
// generates a compile time error:<br />
var items = new int[] {100, 101, 102, 103, 104, 105, 106, 107, 108, 109 
}; This restriction normally isn't a problem. Y ou have a choice of either using yield return
throughout the method, or separating the original method into multiple methods, some
using return, and some using yield return.
You can modify the last method slightly to use yield return everywhere:
C#
Sometimes, the right answer is to split an iterator method into two different methods.
One that uses return, and a second that uses yield return. Consider a situation where
you might want to return an empty collection, or the first five odd numbers, based on a
boolean argument. Y ou could write that as these two methods:
C#    return items; 
} 
public IEnumerable&lt; int&gt; GetFirstDecile () 
{ 
int index = 0; 
while (index &lt; 10) 
yield return index++;<br />
yield return 50; 
var items = new int[] {100, 101, 102, 103, 104, 105, 106, 107, 108, 109 
}; 
foreach (var item in items) 
yield return item; 
} 
public IEnumerable&lt; int&gt; GetSingleDigitOddNumbers (bool getCollection ) 
{ 
if (getCollection == false) 
return new int[0]; 
else 
return IteratorMethod();<br />
} 
private IEnumerable&lt; int&gt; IteratorMethod () 
{ 
int index = 0; 
while (index &lt; 10) 
{ 
if (index % 2 == 1) 
yield return index; 
index++;  Look at the methods above. The first uses the standard return statement to return
either an empty collection, or the iterator created by the second method. The second
method uses the yield return statement to create the requested sequence.
The foreach statement expands into a standard idiom that uses the IEnumerable<T> and
IEnumerator<T> interfaces to iterate across all elements of a collection. It also minimizes
errors developers make by not properly managing resources.
The compiler translates the foreach loop shown in the first example into something
similar to this construct:
C#
The exact code generated by the compiler is more complicated, and handles situations
where the object returned by GetEnumerator() implements the IDisposable interface.
The full expansion generates code more like this:
C#    } 
} 
Deeper dive into foreach
IEnumerator&lt; int&gt; enumerator = collection.GetEnumerator();<br />
while (enumerator.MoveNext())<br />
{ 
var item = enumerator.Current;<br />
Console.WriteLine(item.ToString());<br />
} 
{ 
var enumerator = collection.GetEnumerator();<br />
try 
{ 
while (enumerator.MoveNext())<br />
{<br />
var item = enumerator.Current;<br />
Console.WriteLine(item.ToString());<br />
}<br />
} 
finally 
{ 
// dispose of enumerator.
} 
} The compiler translates the first asynchronous sample into something similar to this
construct:
C#
The manner in which the enumerator is disposed of depends on the characteristics of
the type of enumerator. In the general synchronous case, the finally clause expands to:
C#
The general asynchronous case expands to:
C#
However, if the type of enumerator is a sealed type and there's no implicit conversion
from the type of enumerator to IDisposable or IAsyncDisposable, the finally clause
expands to an empty block:
C#{ 
var enumerator = collection.GetAsyncEnumerator();<br />
try 
{ 
while (await enumerator.MoveNextAsync())<br />
{<br />
var item = enumerator.Current;<br />
Console.WriteLine(item.ToString());<br />
}<br />
} 
finally 
{ 
// dispose of async enumerator.<br />
} 
} 
finally 
{ 
(enumerator as IDisposable)?.Dispose();<br />
} 
finally 
{ 
if (enumerator is IAsyncDisposable asyncDisposable)<br />
await asyncDisposable.DisposeAsync();<br />
} If there's an implicit conversion from the type of enumerator to IDisposable, and
enumerator is a non-nullable value type, the finally clause expands to:
C#
Thankfully, you don't need to remember all these details. The foreach statement
handles all those nuances for you. The compiler will generate the correct code for any of
these constructs.finally 
{ 
} 
finally 
{ 
((IDisposable)enumerator).Dispose();<br />
} Introduction to delegates and events in
C#
Article •03/31/2022
Delegates provide a late binding  mechanism in .NET. Late Binding means that you create
an algorithm where the caller also supplies at least one method that implements part of
the algorithm.
For example, consider sorting a list of stars in an astronomy application. Y ou may
choose to sort those stars by their distance from the earth, or the magnitude of the star,
or their perceived brightness.
In all those cases, the Sort() method does essentially the same thing: arranges the items
in the list based on some comparison. The code that compares two stars is different for
each of the sort orderings.
These kinds of solutions have been used in software for half a century. The C# language
delegate concept provides first class language support, and type safety around the
concept.
As you'll see later in this series, the C# code you write for algorithms like this is type
safe. The compiler ensures that the types match for arguments and return types.
Function pointers  support similar scenarios, where you need more control over the
calling convention. The code associated with a delegate is invoked using a virtual
method added to a delegate type. Using function pointers, you can specify different
conventions.
The language designers enumerated several goals for the feature that eventually
became delegates.
The team wanted a common language construct that could be used for any late binding
algorithms. Delegates enable developers to learn one concept, and use that same
concept across many different software problems.
Second, the team wanted to support both single and multicast method calls. (Multicast
delegates are delegates that chain together multiple method calls. Y ou'll see examples
later in this series .)Language Design Goals for DelegatesThe team wanted delegates to support the same type safety that developers expect
from all C# constructs.
Finally, the team recognized an event pattern is one specific pattern where delegates, or
any late binding algorithm, is useful. The team wanted to ensure the code for delegates
could provide the basis for the .NET event pattern.
The result of all that work was the delegate and event support in C# and .NET.
The remaining articles in this series will cover language features, library support, and
common idioms used when you work with delegates and events. Y ou'll learn about:
The delegate keyword and what code it generates.
The features in the System.Delegate class, and how those features are used.
How to create type-safe delegates.
How to create methods that can be invoked through delegates.
How to work with delegates and events by using lambda expressions.
How delegates become one of the building blocks for LINQ.
How delegates are the basis for the .NET event pattern, and how they're different.
Let's get started.
Next
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide ..NET feedb ack
The .NET documentation is open
source. Provide feedback here.
 Open a documentation issue
 Provide product feedbackSystem.Delegate and the delegate
keyword
Article •09/15/2021
Previous
This article covers the classes in .NET that support delegates, and how those map to the
delegate keyword.
Let's start with the 'delegate' keyword, because that's primarily what you will use as you
work with delegates. The code that the compiler generates when you use the delegate
keyword will map to method calls that invoke members of the Delegate  and
MulticastDelegate  classes.
You define a delegate type using syntax that is similar to defining a method signature.
You just add the delegate keyword to the definition.
Let's continue to use the List.Sort() method as our example. The first step is to create a
type for the comparison delegate:
C#
The compiler generates a class, derived from System.Delegate that matches the
signature used (in this case, a method that returns an integer, and has two arguments).
The type of that delegate is Comparison. The Comparison delegate type is a generic type.
For details on generics see here.
Notice that the syntax may appear as though it is declaring a variable, but it is actually
declaring a type. You can define delegate types inside classes, directly inside
namespaces, or even in the global namespace.Define delegate types
// From the .NET Core library<br />
// Define the delegate type:<br />
public delegate  int Comparison&lt; in T&gt;(T left, T right);<br />
７ NoteThe compiler also generates add and remove handlers for this new type so that clients
of this class can add and remove methods from an instance's invocation list. The
compiler will enforce that the signature of the method being added or removed
matches the signature used when declaring the method.
After defining the delegate, you can create an instance of that type. Like all variables in
C#, you cannot declare delegate instances directly in a namespace, or in the global
namespace.
C#
The type of the variable is Comparison<T>, the delegate type defined earlier. The name of
the variable is comparator.
That code snippet above declared a member variable inside a class. Y ou can also declare
delegate variables that are local variables, or arguments to methods.
You invoke the methods that are in the invocation list of a delegate by calling that
delegate. Inside the Sort() method, the code will call the comparison method to
determine which order to place objects:
C#
In the line above, the code invokes the method attached to the delegate. Y ou treat the
variable as a method name, and invoke it using normal method call syntax.
That line of code makes an unsafe assumption: There's no guarantee that a target has
been added to the delegate. If no targets have been attached, the line above wouldDeclaring delegate types (or other types) directly in the global namespace is not
recommended.
Declare instances of delegates
// inside a class definition:<br />
// Declare an instance of that type:<br />
public Comparison<T> comparator;<br />
Invoke delegates
int result = comparator(left, right);  cause a NullReferenceException to be thrown. The idioms used to address this problem
are more complicated than a simple null-check, and are covered later in this series .
That's how a delegate type is defined, and how delegate instances are declared and
invoked.
Developers that want to use the List.Sort() method need to define a method whose
signature matches the delegate type definition, and assign it to the delegate used by
the sort method. This assignment adds the method to the invocation list of that
delegate object.
Suppose you wanted to sort a list of strings by their length. Y our comparison function
might be the following:
C#
The method is declared as a private method. That's fine. Y ou may not want this method
to be part of your public interface. It can still be used as the comparison method when
attached to a delegate. The calling code will have this method attached to the target list
of the delegate object, and can access it through that delegate.
You create that relationship by passing that method to the List.Sort() method:
C#
Notice that the method name is used, without parentheses. Using the method as an
argument tells the compiler to convert the method reference into a reference that can
be used as a delegate invocation target, and attach that method as an invocation target.
You could also have been explicit by declaring a variable of type Comparison<string>
and doing an assignment:
C#Assign, add, and remove invocation targets
private static int CompareLength (string left, string right) =&gt; 
left.Length.CompareTo(right.Length);<br />
phrases.Sort(CompareLength);<br />
Comparison&lt; string&gt; comparer = CompareLength;<br />
phrases.Sort(comparer);  In uses where the method being used as a delegate target is a small method, it's
common to use lambda expression  syntax to perform the assignment:
C#
Using lambda expressions for delegate targets is covered more in a later section .
The Sort() example typically attaches a single target method to the delegate. However,
delegate objects do support invocation lists that have multiple target methods attached
to a delegate object.
The language support described above provides the features and support you'll typically
need to work with delegates. These features are built on two classes in the .NET Core
framework: Delegate  and MulticastDelegate .
The System.Delegate class and its single direct subclass, System.MulticastDelegate,
provide the framework support for creating delegates, registering methods as delegate
targets, and invoking all methods that are registered as a delegate target.
Interestingly, the System.Delegate and System.MulticastDelegate classes are not
themselves delegate types. They do provide the basis for all specific delegate types. That
same language design process mandated that you cannot declare a class that derives
from Delegate or MulticastDelegate. The C# language rules prohibit it.
Instead, the C# compiler creates instances of a class derived from MulticastDelegate
when you use the C# language keyword to declare delegate types.
This design has its roots in the first release of C# and .NET. One goal for the design team
was to ensure that the language enforced type safety when using delegates. That meant
ensuring that delegates were invoked with the right type and number of arguments.
And, that any return type was correctly indicated at compile time. Delegates were part of
the 1.0 .NET release, which was before generics.
The best way to enforce this type safety was for the compiler to create the concrete
delegate classes that represented the method signature being used.Comparison&lt; string&gt; comparer = (left, right) =&gt;<br />
left.Length.CompareTo(right.Length);<br />
phrases.Sort(comparer);<br />
Delegate and MulticastDelegate classesEven though you cannot create derived classes directly, you will use the methods
defined on these classes. Let's go through the most common methods that you will use
when you work with delegates.
The first, most important fact to remember is that every delegate you work with is
derived from MulticastDelegate. A multicast delegate means that more than one
method target can be invoked when invoking through a delegate. The original design
considered making a distinction between delegates where only one target method
could be attached and invoked, and delegates where multiple target methods could be
attached and invoked. That distinction proved to be less useful in practice than originally
thought. The two different classes were already created, and have been in the
framework since its initial public release.
The methods that you will use the most with delegates are Invoke() and BeginInvoke()
/ EndInvoke(). Invoke() will invoke all the methods that have been attached to a
particular delegate instance. As you saw above, you typically invoke delegates using the
method call syntax on the delegate variable. As you'll see later in this series , there are
patterns that work directly with these methods.
Now that you've seen the language syntax and the classes that support delegates, let's
examine how strongly typed delegates are used, created, and invoked.
NextStrongly Typed Delegates
Article •09/15/2021
Previous
In the previous article, you saw that you create specific delegate types using the
delegate keyword.
The abstract Delegate class provides the infrastructure for loose coupling and
invocation. Concrete Delegate types become much more useful by embracing and
enforcing type safety for the methods that are added to the invocation list for a
delegate object. When you use the delegate keyword and define a concrete delegate
type, the compiler generates those methods.
In practice, this would lead to creating new delegate types whenever you need a
different method signature. This work could get tedious after a time. Every new feature
requires new delegate types.
Thankfully, this isn't necessary. The .NET Core framework contains several types that you
can reuse whenever you need delegate types. These are generic  definitions so you can
declare customizations when you need new method declarations.
The first of these types is the Action  type, and several variations:
C#
The in modifier on the generic type argument is covered in the article on covariance.
There are variations of the Action delegate that contain up to 16 arguments such as
Action&lt;T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16&gt; . It's important that
these definitions use different generic arguments for each of the delegate arguments:
That gives you maximum flexibility. The method arguments need not be, but may be,
the same type.
Use one of the Action types for any delegate type that has a void return type.
The framework also includes several generic delegate types that you can use for
delegate types that return values:public delegate  void Action(); 
public delegate  void Action&lt; in T&gt;(T arg);<br />
public delegate  void Action&lt; in T1, in T2&gt;(T1 arg1, T2 arg2);<br />
// Other variations removed for brevity.  C#
The out modifier on the result generic type argument is covered in the article on
covariance.
There are variations of the Func delegate with up to 16 input arguments such as
Func&lt;T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,TR esult&gt; . The type of the
result is always the last type parameter in all the Func declarations, by convention.
Use one of the Func types for any delegate type that returns a value.
There's also a specialized Predicate<T>  type for a delegate that returns a test on a
single value:
C#
You may notice that for any Predicate type, a structurally equivalent Func type exists
For example:
C#
You might think these two types are equivalent. They are not. These two variables
cannot be used interchangeably. A variable of one type cannot be assigned the other
type. The C# type system uses the names of the defined types, not the structure.
All these delegate type definitions in the .NET Core Library should mean that you do not
need to define a new delegate type for any new feature you create that requires
delegates. These generic definitions should provide all the delegate types you need
under most situations. Y ou can simply instantiate one of these types with the required
type parameters. In the case of algorithms that can be made generic, these delegates
can be used as generic types.
This should save time, and minimize the number of new types that you need to create in
order to work with delegates.public delegate  TResult Func&lt; out TResult&gt;();<br />
public delegate  TResult Func&lt; in T1, out TResult&gt;(T1 arg);<br />
public delegate  TResult Func&lt; in T1, in T2, out TResult&gt;(T1 arg1, T2 arg2);<br />
// Other variations removed for brevity<br />
public delegate  bool Predicate&lt; in T&gt;(T obj);<br />
Func&lt;string, bool&gt; TestForString;<br />
Predicate&lt; string&gt; AnotherTestForString;  In the next article, you'll see several common patterns for working with delegates in
practice.
NextCommo n patterns for delegates
Article •09/15/2021
Previous
Delegates provide a mechanism that enables software designs involving minimal
coupling between components.
One excellent example for this kind of design is LINQ. The LINQ Query Expression
Pattern relies on delegates for all of its features. Consider this simple example:
C#
This filters the sequence of numbers to only those less than the value 10. The Where
method uses a delegate that determines which elements of a sequence pass the filter.
When you create a LINQ query, you supply the implementation of the delegate for this
specific purpose.
The prototype for the Where method is:
C#
This example is repeated with all the methods that are part of LINQ. They all rely on
delegates for the code that manages the specific query. This API design pattern is a
powerful one to learn and understand.
This simple example illustrates how delegates require very little coupling between
components. Y ou don't need to create a class that derives from a particular base class.
You don't need to implement a specific interface. The only requirement is to provide the
implementation of one method that is fundamental to the task at hand.
Let's build on that example by creating a component using a design that relies on
delegates.var smallNumbers = numbers.Where(n =&gt; n &lt; 10); 
public static IEnumerable<TSource> Where<TSource> ( this IEnumerable<TSource><br />
source, Func&lt;TSource, bool&gt; predicate);<br />
Build Your Own Components with DelegatesLet's define a component that could be used for log messages in a large system. The
library components could be used in many different environments, on multiple different
platforms. There are a lot of common features in the component that manages the logs.
It will need to accept messages from any component in the system. Those messages will
have different priorities, which the core component can manage. The messages should
have timestamps in their final archived form. For more advanced scenarios, you could
filter messages by the source component.
There is one aspect of the feature that will change often: where messages are written. In
some environments, they may be written to the error console. In others, a file. Other
possibilities include database storage, OS event logs, or other document storage.
There are also combinations of output that might be used in different scenarios. Y ou
may want to write messages to the console and to a file.
A design based on delegates will provide a great deal of flexibility, and make it easy to
support storage mechanisms that may be added in the future.
Under this design, the primary log component can be a non-virtual, even sealed class.
You can plug in any set of delegates to write the messages to different storage media.
The built-in support for multicast delegates makes it easy to support scenarios where
messages must be written to multiple locations (a file, and a console).
Let's start small: the initial implementation will accept new messages, and write them
using any attached delegate. Y ou can start with one delegate that writes messages to
the console.
C#
The static class above is the simplest thing that can work. W e need to write the single
implementation for the method that writes messages to the console:A First Implementation
public static class Logger 
{ 
public static Action&lt; string&gt;? WriteMessage;<br />
public static void LogMessage (string msg) 
{ 
if (WriteMessage is not null) 
WriteMessage(msg);<br />
} 
} C#
Finally, you need to hook up the delegate by attaching it to the WriteMessage delegate
declared in the logger:
C#
Our sample so far is fairly simple, but it still demonstrates some of the important
guidelines for designs involving delegates.
Using the delegate types defined in the core framework makes it easier for users to
work with the delegates. Y ou don't need to define new types, and developers using your
library do not need to learn new, specialized delegate types.
The interfaces used are as minimal and as flexible as possible: T o create a new output
logger, you must create one method. That method may be a static method, or an
instance method. It may have any access.
Let's make this first version a bit more robust, and then start creating other logging
mechanisms.
Next, let's add a few arguments to the LogMessage() method so that your log class
creates more structured messages:
C#public static class LoggingMethods<br />
{ 
public static void LogToConsole (string message ) 
{ 
Console.Error.WriteLine(message);<br />
} 
} 
Logger.WriteMessage += LoggingMethods.LogToConsole;<br />
Practices
Format Output
public enum Severity<br />
{ 
Verbose,<br />
Trace,<br />
Information,  C#
Next, let's make use of that Severity argument to filter the messages that are sent to
the log's output.
C#
You've added new features to the logging infrastructure. Because the logger component
is very loosely coupled to any output mechanism, these new features can be added with
no impact on any of the code implementing the logger delegate.    Warning,<br />
Error,<br />
Critical<br />
} 
public static class Logger 
{ 
public static Action&lt; string&gt;? WriteMessage;<br />
public static void LogMessage (Severity s, string component, string msg) 
{ 
var outputMsg = $&quot;{DateTime.Now} \t{s}\t{component} \t{msg}&quot;; 
if (WriteMessage is not null) 
WriteMessage(outputMsg);<br />
} 
} 
public static class Logger 
{ 
public static Action&lt; string&gt;? WriteMessage;<br />
public static Severity LogLevel { get; set; } = Severity.Warning;<br />
public static void LogMessage (Severity s, string component, string msg) 
{ 
if (s &lt; LogLevel)<br />
return; 
var outputMsg = $&quot;{DateTime.Now} \t{s}\t{component} \t{msg}&quot;; 
if (WriteMessage is not null) 
WriteMessage(outputMsg);<br />
} 
} 
PracticesAs you keep building this, you'll see more examples of how this loose coupling enables
greater flexibility in updating parts of the site without any changes to other locations. In
fact, in a larger application, the logger output classes might be in a different assembly,
and not even need to be rebuilt.
The Log component is coming along well. Let's add one more output engine that logs
messages to a file. This will be a slightly more involved output engine. It will be a class
that encapsulates the file operations, and ensures that the file is always closed after each
write. That ensures that all the data is flushed to disk after each message is generated.
Here is that file-based logger:
C#Build a Second Output Engine
public class FileLogger
{ 
private readonly  string logPath;<br />
public FileLogger (string path) 
{ 
logPath = path;<br />
Logger.WriteMessage += LogMessage;<br />
} 
public void DetachLog () =&gt; Logger.WriteMessage -= LogMessage;<br />
// make sure this can't throw.<br />
private void LogMessage (string msg) 
{ 
try 
{<br />
using (var log = File.AppendText(logPath))<br />
{<br />
log.WriteLine(msg);<br />
log.Flush();<br />
}<br />
}<br />
catch (Exception)<br />
{<br />
// Hmm. We caught an exception while<br />
// logging. We can't really log the<br />
// problem (since it's the log that's failing).<br />
// So, while normally, catching an exception<br />
// and doing nothing isn't wise, it's really the<br />
// only reasonable option here.<br />
}<br />
} 
} Once you've created this class, you can instantiate it and it attaches its LogMessage
method to the Logger component:
C#
These two are not mutually exclusive. Y ou could attach both log methods and generate
messages to the console and a file:
C#
Later, even in the same application, you can remove one of the delegates without any
other issues to the system:
C#
Now, you've added a second output handler for the logging subsystem. This one needs
a bit more infrastructure to correctly support the file system. The delegate is an instance
method. It's also a private method. There's no need for greater accessibility because the
delegate infrastructure can connect the delegates.
Second, the delegate-based design enables multiple output methods without any extra
code. Y ou don't need to build any additional infrastructure to support multiple output
methods. They simply become another method on the invocation list.
Pay special attention to the code in the file logging output method. It is coded to ensure
that it does not throw any exceptions. While this isn't always strictly necessary, it's often
a good practice. If either of the delegate methods throws an exception, the remaining
delegates that are on the invocation won't be invoked.
As a last note, the file logger must manage its resources by opening and closing the file
on each log message. Y ou could choose to keep the file open and implement
IDisposable to close the file when you are completed. Either method has its advantages
and disadvantages. Both do create a bit more coupling between the classes.var file = new FileLogger( &quot;log.txt&quot; ); 
var fileOutput = new FileLogger( &quot;log.txt&quot; ); 
Logger.WriteMessage += LoggingMethods.LogToConsole; // LoggingMethods is the<br />
static class we utilized earlier<br />
Logger.WriteMessage -= LoggingMethods.LogToConsole;<br />
PracticesNone of the code in the Logger class would need to be updated in order to support
either scenario.
Finally, let's update the LogMessage method so that it is robust for those cases when no
output mechanism is selected. The current implementation will throw a
NullReferenceException when the WriteMessage delegate does not have an invocation
list attached. Y ou may prefer a design that silently continues when no methods have
been attached. This is easy using the null conditional operator, combined with the
Delegate.Invoke() method:
C#
The null conditional operator ( ?.) short-circuits when the left operand ( WriteMessage in
this case) is null, which means no attempt is made to log a message.
You won't find the Invoke() method listed in the documentation for System.Delegate or
System.MulticastDelegate. The compiler generates a type safe Invoke method for any
delegate type declared. In this example, that means Invoke takes a single string
argument, and has a void return type.
You've seen the beginnings of a log component that could be expanded with other
writers, and other features. By using delegates in the design, these different components
are loosely coupled. This provides several advantages. It's easy to create new output
mechanisms and attach them to the system. These other mechanisms only need one
method: the method that writes the log message. It's a design that's resilient when new
features are added. The contract required for any writer is to implement one method.
That method could be a static or instance method. It could be public, private, or any
other legal access.
The Logger class can make any number of enhancements or changes without
introducing breaking changes. Like any class, you cannot modify the public API without
the risk of breaking changes. But, because the coupling between the logger and anyHandle Null Delegates
public static void LogMessage (string msg) 
{ 
WriteMessage?.Invoke(msg);<br />
} 
Summary of Practicesoutput engines is only through the delegate, no other types (like interfaces or base
classes) are involved. The coupling is as small as possible.
NextIntroduction to events
Article •09/15/2021
Previous
Events are, like delegates, a late binding  mechanism. In fact, events are built on the
language support for delegates.
Events are a way for an object to broadcast (to all interested components in the system)
that something has happened. Any other component can subscribe to the event, and be
notified when an event is raised.
You've probably used events in some of your programming. Many graphical systems
have an event model to report user interaction. These events would report mouse
movement, button presses and similar interactions. That's one of the most common, but
certainly not the only scenario where events are used.
You can define events that should be raised for your classes. One important
consideration when working with events is that there may not be any object registered
for a particular event. Y ou must write your code so that it does not raise events when no
listeners are configured.
Subscribing to an event also creates a coupling between two objects (the event source,
and the event sink). Y ou need to ensure that the event sink unsubscribes from the event
source when no longer interested in events.
The language design for events targets these goals:
Enable very minimal coupling between an event source and an event sink. These
two components may not be written by the same organization, and may even be
updated on totally different schedules.
It should be very simple to subscribe to an event, and to unsubscribe from that
same event.
Event sources should support multiple event subscribers. It should also support
having no event subscribers attached.
You can see that the goals for events are very similar to the goals for delegates. That's
why the event language support is built on the delegate language support.Design goals for event supportThe syntax for defining events, and subscribing or unsubscribing from events is an
extension of the syntax for delegates.
To define an event you use the event keyword:
C#
The type of the event ( EventHandler<FileListArgs> in this example) must be a delegate
type. There are a number of conventions that you should follow when declaring an
event. T ypically, the event delegate type has a void return. Event declarations should be
a verb, or a verb phrase. Use past tense when the event reports something that has
happened. Use a present tense verb (for example, Closing) to report something that is
about to happen. Often, using present tense indicates that your class supports some
kind of customization behavior. One of the most common scenarios is to support
cancellation. For example, a Closing event may include an argument that would indicate
if the close operation should continue, or not. Other scenarios may enable callers to
modify behavior by updating properties of the event arguments. Y ou may raise an event
to indicate a proposed next action an algorithm will take. The event handler may
mandate a different action by modifying properties of the event argument.
When you want to raise the event, you call the event handlers using the delegate
invocation syntax:
C#
As discussed in the section on delegates , the ?. operator makes it easy to ensure that
you do not attempt to raise the event when there are no subscribers to that event.
You subscribe to an event by using the += operator:
C#Language support for events
public event EventHandler<FileListArgs> Progress;<br />
Progress?.Invoke( this, new FileListArgs(file));<br />
EventHandler<FileListArgs> onProgress = (sender, eventArgs) =&gt;<br />
Console.WriteLine(eventArgs.FoundFile);<br />
fileLister.Progress += onProgress;  The handler method typically has the prefix 'On' followed by the event name, as shown
above.
You unsubscribe using the -= operator:
C#
It's important that you declare a local variable for the expression that represents the
event handler. That ensures the unsubscribe removes the handler. If, instead, you used
the body of the lambda expression, you are attempting to remove a handler that has
never been attached, which does nothing.
In the next article, you'll learn more about typical event patterns, and different variations
on this example.
NextfileLister.Progress -= onProgress;  Standard .NET event patterns
Article •09/08/2022
Previous
.NET events generally follow a few known patterns. S tandardizing on these patterns
means that developers can leverage knowledge of those standard patterns, which can
be applied to any .NET event program.
Let's go through these standard patterns so you will have all the knowledge you need to
create standard event sources, and subscribe and process standard events in your code.
The standard signature for a .NET event delegate is:
C#
The return type is void. Events are based on delegates and are multicast delegates. That
supports multiple subscribers for any event source. The single return value from a
method doesn't scale to multiple event subscribers. Which return value does the event
source see after raising an event? Later in this article you'll see how to create event
protocols that support event subscribers that report information to the event source.
The argument list contains two arguments: the sender, and the event arguments. The
compile-time type of sender is System.Object, even though you likely know a more
derived type that would always be correct. By convention, use object.
The second argument has typically been a type that is derived from System.EventArgs.
(You'll see in the next section  that this convention is no longer enforced.) If your event
type does not need any additional arguments, you will still provide both arguments.
There is a special value, EventArgs.Empty that you should use to denote that your event
does not contain any additional information.
Let's build a class that lists files in a directory, or any of its subdirectories that follow a
pattern. This component raises an event for each file found that matches the pattern.
Using an event model provides some design advantages. Y ou can create multiple event
listeners that perform different actions when a sought file is found. Combining theEvent delegate signatures
void EventRaised (object sender, EventArgs args ); different listeners can create more robust algorithms.
Here is the initial event argument declaration for finding a sought file:
C#
Even though this type looks like a small, data-only type, you should follow the
convention and make it a reference ( class) type. That means the argument object will
be passed by reference, and any updates to the data will be viewed by all subscribers.
The first version is an immutable object. Y ou should prefer to make the properties in
your event argument type immutable. That way, one subscriber cannot change the
values before another subscriber sees them. (There are exceptions to this, as you'll see
below.)
Next, we need to create the event declaration in the FileSearcher class. Leveraging the
EventHandler<T> type means that you don't need to create yet another type definition.
You simply use a generic specialization.
Let's fill out the FileSearcher class to search for files that match a pattern, and raise the
correct event when a match is discovered.
C#public class FileFoundArgs  : EventArgs<br />
{ 
public string FoundFile { get; } 
public FileFoundArgs (string fileName ) =&gt; FoundFile = fileName;<br />
} 
public class FileSearcher<br />
{ 
public event EventHandler<FileFoundArgs>? FileFound;<br />
public void Search(string directory, string searchPattern ) 
{ 
foreach (var file in Directory.EnumerateFiles(directory,<br />
searchPattern))<br />
{<br />
RaiseFileFound(file);
}<br />
} </p>
<p>private void RaiseFileFound (string file) =&gt; 
FileFound?.Invoke( this, new FileFoundArgs(file));<br />
} The simplest way to add an event to your class is to declare that event as a public field,
as in the preceding example:
C#
This looks like it's declaring a public field, which would appear to be bad object-oriented
practice. Y ou want to protect data access through properties, or methods. While this
may look like a bad practice, the code generated by the compiler does create wrappers
so that the event objects can only be accessed in safe ways. The only operations
available on a field-like event are add handler:
C#
and remove handler:
C#
Note that there's a local variable for the handler. If you used the body of the lambda,
the remove would not work correctly. It would be a different instance of the delegate,
and silently do nothing.
Code outside the class cannot raise the event, nor can it perform any other operations.
Your simple version is working fine. Let's add another feature: Cancellation.Define and raise field-like events
public event EventHandler<FileFoundArgs>? FileFound;<br />
var fileLister = new FileSearcher();<br />
int filesFound = 0; 
EventHandler<FileFoundArgs> onFileFound = (sender, eventArgs) =&gt;<br />
{ 
Console.WriteLine(eventArgs.FoundFile);<br />
filesFound++;<br />
}; 
fileLister.FileFound += onFileFound;<br />
fileLister.FileFound -= onFileFound;<br />
Return values from event subscribersWhen you raise the found event, listeners should be able to stop further processing, if
this file is the last one sought.
The event handlers do not return a value, so you need to communicate that in another
way. The standard event pattern uses the EventArgs object to include fields that event
subscribers can use to communicate cancel.
Two different patterns could be used, based on the semantics of the Cancel contract. In
both cases, you'll add a boolean field to the EventArguments for the found file event.
One pattern would allow any one subscriber to cancel the operation. For this pattern,
the new field is initialized to false. Any subscriber can change it to true. After all
subscribers have seen the event raised, the FileSearcher component examines the
boolean value and takes action.
The second pattern would only cancel the operation if all subscribers wanted the
operation canceled. In this pattern, the new field is initialized to indicate the operation
should cancel, and any subscriber could change it to indicate the operation should
continue. After all subscribers have seen the event raised, the FileSearcher component
examines the boolean and takes action. There is one extra step in this pattern: the
component needs to know if any subscribers have seen the event. If there are no
subscribers, the field would indicate a cancel incorrectly.
Let's implement the first version for this sample. Y ou need to add a boolean field named
CancelRequested to the FileFoundArgs type:
C#
This new field is automatically initialized to false, the default value for a Boolean field,
so you don't cancel accidentally. The only other change to the component is to check
the flag after raising the event to see if any of the subscribers have requested a
cancellation:
C#public class FileFoundArgs  : EventArgs<br />
{ 
public string FoundFile { get; } 
public bool CancelRequested { get; set; } 
public FileFoundArgs (string fileName ) =&gt; FoundFile = fileName;<br />
} 
private void SearchDirectory (string directory, string searchPattern ) 
{ One advantage of this pattern is that it isn't a breaking change. None of the subscribers
requested cancellation before, and they still are not. None of the subscriber code needs
updating unless they want to support the new cancel protocol. It's very loosely coupled.
Let's update the subscriber so that it requests a cancellation once it finds the first
executable:
C#
Let's add one more feature, and demonstrate other language idioms for events. Let's
add an overload of the Search method that traverses all subdirectories in search of files.
This could get to be a lengthy operation in a directory with many sub-directories. Let's
add an event that gets raised when each new directory search begins. This enables
subscribers to track progress, and update the user as to progress. All the samples you've
created so far are public. Let's make this one an internal event. That means you can also
make the types used for the arguments internal as well.
You'll start by creating the new EventArgs derived class for reporting the new directory
and progress.    foreach (var file in Directory.EnumerateFiles(directory, searchPattern))<br />
{ 
FileFoundArgs args = RaiseFileFound(file);<br />
if (args.CancelRequested)
{<br />
break; 
}<br />
} 
} 
private FileFoundArgs RaiseFileFound (string file) 
{ 
var args = new FileFoundArgs(file);<br />
FileFound?.Invoke( this, args);<br />
return args; 
} 
EventHandler<FileFoundArgs> onFileFound = (sender, eventArgs) =&gt;<br />
{ 
Console.WriteLine(eventArgs.FoundFile);<br />
eventArgs.CancelRequested = true; 
}; 
Adding another event declarationC#
Again, you can follow the recommendations to make an immutable reference type for
the event arguments.
Next, define the event. This time, you'll use a different syntax. In addition to using the
field syntax, you can explicitly create the property, with add and remove handlers. In this
sample, you won't need extra code in those handlers, but this shows how you would
create them.
C#
In many ways, the code you write here mirrors the code the compiler generates for the
field event definitions you've seen earlier. Y ou create the event using syntax very similar
to that used for properties . Notice that the handlers have different names: add and
remove. These are called to subscribe to the event, or unsubscribe from the event.
Notice that you also must declare a private backing field to store the event variable. It is
initialized to null.
Next, let's add the overload of the Search method that traverses subdirectories and
raises both events. The easiest way to accomplish this is to use a default argument to
specify that you want to search all directories:
C#internal  class SearchDirectoryArgs  : EventArgs<br />
{ 
internal  string CurrentSearchDirectory { get; } 
internal  int TotalDirs { get; } 
internal  int CompletedDirs { get; } 
internal  SearchDirectoryArgs (string dir, int totalDirs, int 
completedDirs ) 
{ 
CurrentSearchDirectory = dir;<br />
TotalDirs = totalDirs;<br />
CompletedDirs = completedDirs;<br />
} 
} 
internal  event EventHandler<SearchDirectoryArgs> DirectoryChanged<br />
{ 
add { _directoryChanged += value; } 
remove { _directoryChanged -= value; } 
} 
private EventHandler<SearchDirectoryArgs>? _directoryChanged;  public void Search(string directory, string searchPattern, bool 
searchSubDirs = false) 
{ 
if (searchSubDirs)<br />
{ 
var allDirectories = Directory.GetDirectories(directory, &quot;<em>.</em>&quot;, 
SearchOption.AllDirectories);<br />
var completedDirs = 0; 
var totalDirs = allDirectories.Length + 1; 
foreach (var dir in allDirectories)<br />
{<br />
RaiseSearchDirectoryChanged(dir, totalDirs, completedDirs++);<br />
// Search 'dir' and its subdirectories for files that match the<br />
search pattern:<br />
SearchDirectory(dir, searchPattern);<br />
}<br />
// Include the Current Directory:<br />
RaiseSearchDirectoryChanged(directory, totalDirs, completedDirs++);</p>
<pre><code> SearchDirectory(directory, searchPattern);  
</code></pre>
<p>} 
else 
{ 
SearchDirectory(directory, searchPattern);<br />
} 
} 
private void SearchDirectory (string directory, string searchPattern ) 
{ 
foreach (var file in Directory.EnumerateFiles(directory, searchPattern))<br />
{ 
FileFoundArgs args = RaiseFileFound(file);<br />
if (args.CancelRequested)
{<br />
break; 
}<br />
} 
} 
private void RaiseSearchDirectoryChanged ( 
string directory, int totalDirs, int completedDirs ) =&gt; 
_directoryChanged?.Invoke(<br />
this, 
new SearchDirectoryArgs(directory, totalDirs, completedDirs));<br />
private FileFoundArgs RaiseFileFound (string file) 
{ 
var args = new FileFoundArgs(file);<br />
FileFound?.Invoke( this, args);<br />
return args; 
} At this point, you can run the application calling the overload for searching all sub-
directories. There are no subscribers on the new DirectoryChanged event, but using the
?.Invoke() idiom ensures that this works correctly.
Let's add a handler to write a line that shows the progress in the console window.
C#
You've seen patterns that are followed throughout the .NET ecosystem. By learning
these patterns and conventions, you'll be writing idiomatic C# and .NET quickly.
Introduction to events
Event design
Handle and raise events
Next, you'll see some changes in these patterns in the most recent release of .NET.fileLister.DirectoryChanged += (sender, eventArgs) =&gt;<br />
{ 
Console.Write( $&quot;Entering ' {eventArgs.CurrentSearchDirectory} '.&quot;); 
Console.WriteLine( $&quot; {eventArgs.CompletedDirs}  of {eventArgs.TotalDirs}<br />
completed...&quot; ); 
}; 
See also
NextThe Up dated .NET Core Event Pattern
Article •02/13/2023
Previous
The previous article discussed the most common event patterns. .NET Core has a more
relaxed pattern. In this version, the EventHandler<TEventArgs> definition no longer has
the constraint that TEventArgs must be a class derived from System.EventArgs.
This increases flexibility for you, and is backwards compatible. Let's start with the
flexibility. The class S ystem.EventArgs introduces one method: MemberwiseClone(), which
creates a shallow copy of the object. That method must use reflection in order to
implement its functionality for any class derived from EventArgs. That functionality is
easier to create in a specific derived class. That effectively means that deriving from
System.EventArgs is a constraint that limits your designs, but does not provide any
additional benefit. In fact, you can change the definitions of FileFoundArgs and
SearchDirectoryArgs so that they do not derive from EventArgs. The program will work
exactly the same.
You could also change the SearchDirectoryArgs to a struct, if you make one more
change:
C#
The additional change is to call the parameterless constructor before entering the
constructor that initializes all the fields. Without that addition, the rules of C# would
report that the properties are being accessed before they have been assigned.internal  struct SearchDirectoryArgs<br />
{ 
internal  string CurrentSearchDirectory { get; } 
internal  int TotalDirs { get; } 
internal  int CompletedDirs { get; } 
internal  SearchDirectoryArgs (string dir, int totalDirs, int 
completedDirs ) : this()
{ 
CurrentSearchDirectory = dir;<br />
TotalDirs = totalDirs;<br />
CompletedDirs = completedDirs;<br />
} 
} You should not change the FileFoundArgs from a class (reference type) to a struct (value
type). That's because the protocol for handling cancel requires that the event arguments
are passed by reference. If you made the same change, the file search class could never
observe any changes made by any of the event subscribers. A new copy of the structure
would be used for each subscriber, and that copy would be a different copy than the
one seen by the file search object.
Next, let's consider how this change can be backwards compatible. The removal of the
constraint does not affect any existing code. Any existing event argument types do still
derive from System.EventArgs. Backwards compatibility is one major reason why they
will continue to derive from System.EventArgs. Any existing event subscribers will be
subscribers to an event that followed the classic pattern.
Following similar logic, any event argument type created now would not have any
subscribers in any existing codebases. New event types that do not derive from
System.EventArgs will not break those codebases.
You have one final pattern to learn: How to correctly write event subscribers that call
async code. The challenge is described in the article on async and await . Async methods
can have a void return type, but that is strongly discouraged. When your event
subscriber code calls an async method, you have no choice but to create an async void
method. The event handler signature requires it.
You need to reconcile this opposing guidance. Somehow, you must create a safe async
void method. The basics of the pattern you need to implement are below:
C#Events with Async subscribers
worker.StartWorking += async (sender, eventArgs) =&gt;<br />
{ 
try 
{ 
await DoWorkAsync();<br />
} 
catch (Exception e)<br />
{ 
//Some form of logging.<br />
Console.WriteLine( $&quot;Async task failure: {e.ToString()} &quot;); 
// Consider gracefully, and quickly exiting.<br />
} 
}; First, notice that the handler is marked as an async handler. Because it is being assigned
to an event handler delegate type, it will have a void return type. That means you must
follow the pattern shown in the handler, and not allow any exceptions to be thrown out
of the context of the async handler. Because it does not return a task, there is no task
that can report the error by entering the faulted state. Because the method is async, the
method can't simply throw the exception. (The calling method has continued execution
because it is async.) The actual runtime behavior will be defined differently for different
environments. It may terminate the thread or the process that owns the thread, or leave
the process in an indeterminate state. All of these potential outcomes are highly
undesirable.
That's why you should wrap the await statement for the async T ask in your own try
block. If it does cause a faulted task, you can log the error. If it is an error from which
your application cannot recover, you can exit the program quickly and gracefully
Those are the major updates to the .NET event pattern. Y ou will see many examples of
the earlier versions in the libraries you work with. However, you should understand what
the latest patterns are as well.
The next article in this series helps you distinguish between using delegates and events
in your designs. They are similar concepts, and that article will help you make the best
decision for your programs.
NextDistinguishing Delegates and Events
Article •11/05/2021
Previous
Developers that are new to the .NET Core platform often struggle when deciding
between a design based on delegates and a design based on events. The choice of
delegates or events is often difficult, because the two language features are similar.
Events are even built using the language support for delegates.
They both offer a late binding scenario: they enable scenarios where a component
communicates by calling a method that is only known at run time. They both support
single and multiple subscriber methods. Y ou may find this referred to as singlecast and
multicast support. They both support similar syntax for adding and removing handlers.
Finally, raising an event and calling a delegate use exactly the same method call syntax.
They even both support the same Invoke() method syntax for use with the ?. operator.
With all those similarities, it is easy to have trouble determining when to use which.
The most important consideration in determining which language feature to use is
whether or not there must be an attached subscriber. If your code must call the code
supplied by the subscriber, you should use a design based on delegates when you need
to implement callback. If your code can complete all its work without calling any
subscribers, you should use a design based on events.
Consider the examples built during this section. The code you built using List.Sort()
must be given a comparer function in order to properly sort the elements. LINQ queries
must be supplied with delegates in order to determine what elements to return. Both
used a design built with delegates.
Consider the Progress event. It reports progress on a task. The task continues to
proceed whether or not there are any listeners. The FileSearcher is another example. It
would still search and find all the files that were sought, even with no event subscribers
attached. UX controls still work correctly, even when there are no subscribers listening to
the events. They both use designs based on events.Listening to Events is Optional
Return Values Require DelegatesAnother consideration is the method prototype you would want for your delegate
method. As you've seen, the delegates used for events all have a void return type.
You've also seen that there are idioms to create event handlers that do pass information
back to event sources through modifying properties of the event argument object.
While these idioms do work, they are not as natural as returning a value from a method.
Notice that these two heuristics may often both be present: If your delegate method
returns a value, it will likely impact the algorithm in some way.
Classes other than the one in which an event is contained can only add and remove
event listeners; only the class containing the event can invoke the event. Events are
typically public class members. By comparison, delegates are often passed as
parameters and stored as private class members, if they are stored at all.
That event listeners have longer lifetimes is a slightly weaker justification. However, you
may find that event-based designs are more natural when the event source will be
raising events over a long period of time. Y ou can see examples of event-based design
for UX controls on many systems. Once you subscribe to an event, the event source may
raise events throughout the lifetime of the program. (Y ou can unsubscribe from events
when you no longer need them.)
Contrast that with many delegate-based designs, where a delegate is used as an
argument to a method, and the delegate is not used after that method returns.
The above considerations are not hard and fast rules. Instead, they represent guidance
that can help you decide which choice is best for your particular usage. Because they are
similar, you can even prototype both, and consider which would be more natural to
work with. They both handle late binding scenarios well. Use the one that communicates
your design the best.Events Have Private Invocation
Event Listeners Often Have Longer Lifetimes
Evaluate CarefullyVersioning in C#
Article •02/08/2023
In this tutorial you'll learn what versioning means in .NET. Y ou'll also learn the factors to
consider when versioning your library as well as upgrading to a new version of a library.
As a developer who has created .NET libraries for public use, you've most likely been in
situations where you have to roll out new updates. How you go about this process
matters a lot as you need to ensure that there's a seamless transition of existing code to
the new version of your library. Here are several things to consider when creating a new
release:
Semantic versioning  (SemV er for short) is a naming convention applied to versions of
your library to signify specific milestone events. Ideally, the version information you give
your library should help developers determine the compatibility with their projects that
make use of older versions of that same library.
The most basic approach to SemV er is the 3 component format MAJOR.MINOR.PATCH,
where:
MAJOR is incremented when you make incompatible API changes
MINOR is incremented when you add functionality in a backwards-compatible
manner
PATCH is incremented when you make backwards-compatible bug fixes
There are also ways to specify other scenarios, for example, pre-release versions, when
applying version information to your .NET library.
As you release new versions of your library, backwards compatibility with previous
versions will most likely be one of your major concerns. A new version of your library is
source compatible with a previous version if code that depends on the previous version
can, when recompiled, work with the new version. A new version of your library is binary
compatible if an application that depended on the old version can, without
recompilation, work with the new version.Auth oring Libraries
Semantic Versioning
Backwards CompatibilityHere are some things to consider when trying to maintain backwards compatibility with
older versions of your library:
Virtual methods: When you make a virtual method non-virtual in your new version
it means that projects that override that method will have to be updated. This is a
huge breaking change and is strongly discouraged.
Method signatures: When updating a method behavior requires you to change its
signature as well, you should instead create an overload so that code calling into
that method will still work. Y ou can always manipulate the old method signature to
call into the new method signature so that implementation remains consistent.
Obsolete attribute : You can use this attribute in your code to specify classes or
class members that are deprecated and likely to be removed in future versions.
This ensures developers utilizing your library are better prepared for breaking
changes.
Optional Method Arguments: When you make previously optional method
arguments compulsory or change their default value then all code that does not
supply those arguments will need to be updated.
The easier you make it for your users to upgrade to the new version of your library, the
more likely that they will upgrade sooner.
As a .NET developer there's a very high chance you've encountered the app.config  file
present in most project types. This simple configuration file can go a long way into
improving the rollout of new updates. Y ou should generally design your libraries in such
a way that information that is likely to change regularly is stored in the app.config file,
this way when such information is updated, the config file of older versions just needs to
be replaced with the new one without the need for recompilation of the library.
As a developer that consumes .NET libraries built by other developers you're most likely
aware that a new version of a library might not be fully compatible with your project and
you might often find yourself having to update your code to work with those changes.７ Note
Making compulsory arguments optional should have very little effect especially if it
doesn't change the method's behavior.
Application Configuration File
Consuming LibrariesLucky for you, C# and the .NET ecosystem comes with features and techniques that
allow us to easily update our app to work with new versions of libraries that might
introduce breaking changes.
You can use the app.c onfig file to update the version of a library your app uses. By
adding what is called a binding r edirect, you can use the new library version without
having to recompile your app. The following example shows how you would update
your app's app.c onfig file to use the 1.0.1 patch version of ReferencedLibrary instead
of the 1.0.0 version it was originally compiled with.
XML
You use the new modifier to hide inherited members of a base class. This is one way
derived classes can respond to updates in base classes.
Take the following example:
C#Assembly Binding Redirection
<dependentAssembly > 
<assemblyIdentity  name="ReferencedLibrary"  
publicKeyToken ="32ab4ba45e0a69a1"  culture="en-us" /> 
<bindingRedirect  oldVersion ="1.0.0" newVersion ="1.0.1" /> 
</dependentAssembly > 
７ Note
This approach will only work if the new version of ReferencedLibrary is binary
compatible with your app. See the Backwar ds Comp atibility  section above for
changes to look out for when determining compatibility.
new
public class BaseClass<br />
{ 
public void MyMethod () 
{ 
Console.WriteLine( &quot;A base method&quot; ); 
} 
} 
public class DerivedClass  : BaseClass  Output
Console
From the example above you can see how DerivedClass hides the MyMethod method
present in BaseClass. This means that when a base class in the new version of a library
adds a member that already exists in your derived class, you can simply use the new
modifier on your derived class member to hide the base class member.
When no new modifier is specified, a derived class will by default hide conflicting
members in a base class, although a compiler warning will be generated the code will
still compile. This means that simply adding new members to an existing class makes
that new version of your library both source and binary compatible with code that
depends on it.
The override modifier means a derived implementation extends the implementation of
a base class member rather than hides it. The base class member needs to have the
virtual modifier applied to it.
C#{ 
public new void MyMethod () 
{ 
Console.WriteLine( &quot;A derived method&quot; ); 
} 
} 
public static void Main() 
{ 
BaseClass b = new BaseClass();<br />
DerivedClass d = new DerivedClass();<br />
b.MyMethod();<br />
d.MyMethod();<br />
} 
A base method<br />
A derived method<br />
override
public class MyBaseClass<br />
{ 
public virtual string MethodOne () 
{ Output
Console
The override modifier is evaluated at compile time and the compiler will throw an error
if it doesn't find a virtual member to override.
Your knowledge of the discussed techniques and your understanding of the situations in
which to use them, will go a long way towards easing the transition between versions of
a library.        return &quot;Method One&quot; ; 
} 
} 
public class MyDerivedClass  : MyBaseClass<br />
{ 
public override  string MethodOne () 
{ 
return &quot;Derived Method One&quot; ; 
} 
} 
public static void Main() 
{ 
MyBaseClass b = new MyBaseClass();<br />
MyDerivedClass d = new MyDerivedClass();<br />
Console.WriteLine( &quot;Base Method One: {0}&quot; , b.MethodOne());<br />
Console.WriteLine( &quot;Derived Method One: {0}&quot; , d.MethodOne());<br />
} 
Base Method One: Method One<br />
Derived Method One: Derived Method One  How to (C#)
Article •02/13/2023
In the How to section of the C# Guide, you can find quick answers to common
questions. In some cases, articles may be listed in multiple sections. W e wanted to make
them easy to find for multiple search paths.
There are several tips and tricks that are common C# developer practices:
Initialize objects using an object initializer .
Use operator overloading .
Implement and call a custom extension method .
Create a new method for an enum  type using extension methods .
You create classes, records, and structs to implement your program. These techniques
are commonly used when writing classes, records, or structs.
Declare auto implemented properties .
Declare and use read/write properties .
Define constants .
Override the ToString  method to provide string output .
Define abstract properties .
Use the xml documentation features to document your code .
Explicitly implement interface members  to keep your public interface concise.
Explicitly implement members of two interfaces .
These articles help you work with collections of data.
Initialize a dictionary with a collection initializer .
Strings are the fundamental data type used to display or manipulate text. These articles
demonstrate common practices with strings.General C# concepts
Class, record, and struct members
Working with collections
Working with stringsCompare strings .
Modify the contents of a string .
Determine if a string represents a number .
Use String.Split  to separate strings .
Combine multiple strings into one .
Search for text in a string .
You may need to convert an object to a different type.
Determine if a string represents a number .
Convert between strings that represent hexadecimal numbers and the number .
Convert a string to a DateTime .
Convert a byte array to an int .
Convert a string to a number .
Use pattern matching, the as and is operators to safely cast to a different type .
Define custom type conversions .
Determine if a type is a nullable value type .
Convert between nullable and non-nullable value types .
You may create types that define their own rules for equality or define a natural ordering
among objects of that type.
Test for reference-based equality .
Define value-based equality for a type .
.NET programs report that methods did not successfully complete their work by
throwing exceptions. In these articles you'll learn to work with exceptions.
Handle exceptions using try and catch .
Cleanup resources using finally  clauses .
Recover from non-CLS (Common Language Specification) exceptions .Convert between types
Equality and ordering comparisons
Exception handling
Delegates and eventsDelegates and events provide a capability for strategies that involve loosely coupled
blocks of code.
Declare, instantiate, and use delegates .
Combine multicast delegates .
Events provide a mechanism to publish or subscribe to notifications.
Subscribe and unsubscribe from events .
Implement events declared in interfaces .
Conform to .NET guidelines when your code publishes events .
Raise events defined in base classes from derived classes .
Implement custom event accessors .
LINQ enables you to write code to query any data source that supports the LINQ query
expression pattern. These articles help you understand the pattern and work with
different data sources.
Query a collection .
Use var in query expressions .
Return subsets of element properties from a query .
Write queries with complex filtering .
Sort elements of a data source .
Sort elements on multiple keys .
Control the type of a projection .
Count occurrences of a value in a source sequence .
Calculate intermediate values .
Merge data from multiple sources .
Find the set difference between two sequences .
Debug empty query results .
Add custom methods to LINQ queries .
Modern programs often use asynchronous operations. These articles will help you learn
to use these techniques.
Improve async performance using System.Threading.T asks.T ask.WhenAll .
Make multiple web requests in parallel using async  and await .
Use a thread pool .LINQ practices
Multip le threads and async processingTypically, C# programs have command line arguments. These articles teach you to
access and process those command line arguments.
Retrieve all command line arguments with for.Command line args to your programHow to separate strings using
String.Split in C#
Article •09/15/2021
The String.Split  method creates an array of substrings by splitting the input string based
on one or more delimiters. This method is often the easiest way to separate a string on
word boundaries. It's also used to split strings on other specific characters or strings.
The following code splits a common phrase into an array of strings for each word.
C#
Every instance of a separator character produces a value in the returned array.
Consecutive separator characters produce the empty string as a value in the returned
array. Y ou can see how an empty string is created in the following example, which uses
the space character as a separator.
C#７ Note
The C# examples in this article run in the Try.NET inline code runner and
playground. Select the Run button to run an example in an interactive window.
Once you execute the code, you can modify it and run the modified code by
selecting Run again. The modified code either runs in the interactive window or, if
compilation fails, the interactive window displays all C# compiler error messages.
string phrase = &quot;The quick brown fox jumps over the lazy dog.&quot; ;
string[] words = phrase.Split( ' ');
foreach (var word in words)
{
System.Console.WriteLine( $&quot;&lt;{word}&gt;&quot;);
}
string phrase = &quot;The quick brown    fox     jumps over the lazy dog.&quot; ;
string[] words = phrase.Split( ' ');
foreach (var word in words)
{
System.Console.WriteLine( $&quot;&lt;{word}&gt;&quot;);
}This behavior makes it easier for formats like comma-separated values (CSV) files
representing tabular data. Consecutive commas represent a blank column.
You can pass an optional StringSplitOptions.R emoveEmptyEntries  parameter to exclude
any empty strings in the returned array. For more complicated processing of the
returned collection, you can use LINQ  to manipulate the result sequence.
String.Split  can use multiple separator characters. The following example uses spaces,
commas, periods, colons, and tabs as separating characters, which are passed to Split in
an array. The loop at the bottom of the code displays each of the words in the returned
array.
C#
Consecutive instances of any separator produce the empty string in the output array:
C#
String.Split  can take an array of strings (character sequences that act as separators for
parsing the target string, instead of single characters).
C#char[] delimiterChars = { ' ', ',', '.', ':', '\t' };
string text = &quot;one\ttwo three:four,five six seven&quot; ;
System.Console.WriteLine( $&quot;Original text: ' {text}'&quot;);
string[] words = text.Split(delimiterChars);
System.Console.WriteLine( $&quot;{words.Length}  words in text:&quot; );
foreach (var word in words)
{
System.Console.WriteLine( $&quot;&lt;{word}&gt;&quot;);
}
char[] delimiterChars = { ' ', ',', '.', ':', '\t' };
string text = &quot;one\ttwo :,five six seven&quot; ;
System.Console.WriteLine( $&quot;Original text: ' {text}'&quot;);
string[] words = text.Split(delimiterChars);
System.Console.WriteLine( $&quot;{words.Length}  words in text:&quot; );
foreach (var word in words)
{
System.Console.WriteLine( $&quot;&lt;{word}&gt;&quot;);
}Extract elements from a string
C# programming guide
Strings
.NET regular expressionsstring[] separatingStrings = { &quot;&lt;&lt;&quot;, &quot;...&quot; };
string text = &quot;one&lt;&lt;two......three&lt;four&quot; ;
System.Console.WriteLine( $&quot;Original text: ' {text}'&quot;);
string[] words = text.Split(separatingStrings,<br />
System.StringSplitOptions.RemoveEmptyEntries);
System.Console.WriteLine( $&quot;{words.Length}  substrings in text:&quot; );
foreach (var word in words)
{
System.Console.WriteLine(word);
}
See alsoHow to concatenate multiple strings (C#
Guide)
Article •09/15/2021
Concat enation  is the process of appending one string to the end of another string. Y ou
concatenate strings by using the + operator. For string literals and string constants,
concatenation occurs at compile time; no run-time concatenation occurs. For string
variables, concatenation occurs only at run time.
The following example splits a long string literal into smaller strings to improve
readability in the source code. The code concatenates the smaller strings to create the
long string literal. The parts are concatenated into a single string at compile time.
There's no run-time performance cost regardless of the number of strings involved.
C#７ Note
The C# examples in this article run in the Try.NET inline code runner and
playground. Select the Run button to run an example in an interactive window.
Once you execute the code, you can modify it and run the modified code by
selecting Run again. The modified code either runs in the interactive window or, if
compilation fails, the interactive window displays all C# compiler error messages.
String literals
// Concatenation of literals is performed at compile time, not run time.
string text = &quot;Historically, the world of data and the world of objects &quot;  +
&quot;have not been well integrated. Programmers work in C# or Visual Basic &quot;  +
&quot;and also in SQL or XQuery. On the one side are concepts such as classes, &quot;</p>
</li>
</ol>
<ul>
<li></li>
</ul>
<p>&quot;objects, fields, inheritance, and .NET Framework APIs. On the other side &quot;</p>
<ul>
<li></li>
</ul>
<p>&quot;are tables, columns, rows, nodes, and separate languages for dealing with &quot;</p>
<ul>
<li></li>
</ul>
<p>&quot;them. Data types often require translation between the two worlds; there<br />
are &quot; +
&quot;different standard functions. Because the object world has no notion of<br />
query, a &quot;  +
&quot;query can only be represented as a string without compile-time type<br />
checking or &quot;  +
&quot;IntelliSense support in the IDE. Transferring data from SQL tables or XML<br />
trees to &quot;  +To concatenate string variables, you can use the + or += operators, string interpolation
or the String.Format , String.Concat , String.Join  or StringBuilder.Append  methods. The +
operator is easy to use and makes for intuitive code. Even if you use several + operators
in one statement, the string content is copied only once. The following code shows
examples of using the + and += operators to concatenate strings:
C#
In some expressions, it's easier to concatenate strings using string interpolation, as the
following code shows:
C#&quot;objects in memory is often tedious and error-prone.&quot; ;
System.Console.WriteLine(text);</p>
<ul>
<li>and += operators
string userName = &quot;<Type your name here>&quot; ;
string dateString = DateTime.Today.ToShortDateString();
// Use the + and += operators for one-time concatenations.
string str = &quot;Hello &quot;  + userName + &quot;. Today is &quot;  + dateString + &quot;.&quot;;
System.Console.WriteLine(str);
str += &quot; How are you today?&quot; ;
System.Console.WriteLine(str);
String interpolation
string userName = &quot;<Type your name here>&quot; ;
string date = DateTime.Today.ToShortDateString();
// Use string interpolation to concatenate strings.
string str = $&quot;Hello {userName} . Today is {date}.&quot;;
System.Console.WriteLine(str);
str = $&quot;{str} How are you today?&quot; ;
System.Console.WriteLine(str);
７ NoteBeginning with C# 10, you can use string interpolation to initialize a constant string
when all the expressions used for placeholders are also constant strings.
Another method to concatenate strings is String.Format . This method works well when
you're building a string from a small number of component strings.
In other cases, you may be combining strings in a loop where you don't know how many
source strings you're combining, and the actual number of source strings may be large.
The StringBuilder  class was designed for these scenarios. The following code uses the
Append  method of the StringBuilder  class to concatenate strings.
C#
You can read more about the reasons to choose string concatenation or the
StringBuilder  class .
Another option to join strings from a collection is to use String.Concat  method. Use
String.Join  method if source strings should be separated by a delimiter. The following
code combines an array of words using both methods:
C#In string concatenation operations, the C# compiler treats a null string the same as
an empty string.
String.Format
StringBuilder
// Use StringBuilder for concatenation in tight loops.
var sb = new System.Text.StringBuilder();
for (int i = 0; i &lt; 20; i++)
{
sb.AppendLine(i.ToString());
}
System.Console.WriteLine(sb.ToString());
String.Concat or String.Join
string[] words = { &quot;The&quot;, &quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot;, &quot;jumps&quot;, &quot;over&quot;, &quot;the&quot;, 
&quot;lazy&quot;, &quot;dog.&quot; };
var unreadablePhrase = string.Concat(words);At last, you can use LINQ  and the Enumerable.Aggregate  method to join strings from a
collection. This method combines the source strings using a lambda expression. The
lambda expression does the work to add each string to the existing accumulation. The
following example combines an array of words, adding a space between each word in
the array:
C#
This option can cause more allocations than other methods for concatenating
collections, as it creates an intermediate string for each iteration. If optimizing
performance is critical, consider the StringBuilder  class or the String.Concat  or String.Join
method to concatenate a collection, instead of Enumerable.Aggregate.
String
StringBuilder
C# programming guide
StringsSystem.Console.WriteLine(unreadablePhrase);
var readablePhrase = string.Join(&quot; &quot;, words);
System.Console.WriteLine(readablePhrase);
LINQ and Enumerable.Aggregate
string[] words = { &quot;The&quot;, &quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot;, &quot;jumps&quot;, &quot;over&quot;, &quot;the&quot;, 
&quot;lazy&quot;, &quot;dog.&quot; };
var phrase = words.Aggregate((partialPhrase, word) =&gt; $&quot;{partialPhrase}<br />
{word}&quot;);
System.Console.WriteLine(phrase);
See alsoHow to search strings
Article •09/15/2021
You can use two main strategies to search for text in strings. Methods of the String  class
search for specific text. R egular expressions search for patterns in text.
The string  type, which is an alias for the System.S tring  class, provides a number of useful
methods for searching the contents of a string. Among them are Contains , StartsWith ,
EndsWith , IndexOf , LastIndexOf . The System.T ext.R egularExpressions.R egex  class
provides a rich vocabulary to search for patterns in text. In this article, you learn these
techniques and how to choose the best method for your needs.
The String.Contains , String.S tartsWith , and String.EndsWith  methods search a string for
specific text. The following example shows each of these methods and a variation that
uses a case-insensitive search:
C#７ Note
The C# examples in this article run in the Try.NET inline code runner and
playground. Select the Run button to run an example in an interactive window.
Once you execute the code, you can modify it and run the modified code by
selecting Run again. The modified code either runs in the interactive window or, if
compilation fails, the interactive window displays all C# compiler error messages.
Does a string contain text?
string factMessage = &quot;Extension methods have all the capabilities of regular<br />
static methods.&quot; ;
// Write the string and include the quotation marks.
Console.WriteLine( $&quot;&quot;{factMessage} &quot;&quot;);
// Simple comparisons are always case sensitive!
bool containsSearchResult = factMessage.Contains( &quot;extension&quot; );
Console.WriteLine( $&quot;Contains &quot;extension&quot;? {containsSearchResult} &quot;);
// For user input and strings that will be displayed to the end user,
// use the StringComparison parameter on methods that have it to specify how<br />
to match strings.
bool ignoreCaseSearchResult = factMessage.StartsWith( &quot;extension&quot; , 
System.StringComparison.CurrentCultureIgnoreCase);
Console.WriteLine( $&quot;Starts with &quot;extension&quot;? {ignoreCaseSearchResult}  The preceding example demonstrates an important point for using these methods.
Searches are case-sensitiv e by default. Y ou use the
StringComparison.CurrentCultureIgnoreCase  enumeration value to specify a case-
insensitive search.
The IndexOf  and LastIndexOf  methods also search for text in strings. These methods
return the location of the text being sought. If the text isn't found, they return -1. The
following example shows a search for the first and last occurrence of the word
&quot;methods&quot; and displays the text in between.
C#
The System.T ext.R egularExpressions.R egex  class can be used to search strings. These
searches can range in complexity from simple to complicated text patterns.
The following code example searches for the word &quot;the&quot; or &quot;their&quot; in a sentence,
ignoring case. The static method Regex.IsMatch  performs the search. Y ou give it the
string to search and a search pattern. In this case, a third argument specifies case-
insensitive search. For more information, see
System.T ext.R egularExpressions.R egexOptions .(ignoring case)&quot; );
bool endsWithSearchResult = factMessage.EndsWith( &quot;.&quot;, 
System.StringComparison.CurrentCultureIgnoreCase);
Console.WriteLine( $&quot;Ends with '.'? {endsWithSearchResult} &quot;);
Where does the sought text occur in a string?
string factMessage = &quot;Extension methods have all the capabilities of regular<br />
static methods.&quot; ;
// Write the string and include the quotation marks.
Console.WriteLine( $&quot;&quot;{factMessage} &quot;&quot;);
// This search returns the substring between two strings, so
// the first index is moved to the character just after the first string.
int first = factMessage.IndexOf( &quot;methods&quot; ) + &quot;methods&quot; .Length;
int last = factMessage.LastIndexOf( &quot;methods&quot; );
string str2 = factMessage.Substring(first, last - first);
Console.WriteLine( $&quot;Substring between &quot;methods&quot; and &quot;methods&quot;:<br />
'{str2}'&quot;);
Finding specific text using regular expressionsThe search pattern describes the text you search for. The following table describes each
element of the search pattern. (The table below uses the single , which must be
escaped as \ in a C# string).
Pattern Meaning
the match the text &quot;the&quot;
(eir)? match 0 or 1 occurrence of &quot;eir&quot;
\s match a white-space character
C#
string[] sentences =
{
&quot;Put the water over there.&quot; ,
&quot;They're quite thirsty.&quot; ,
&quot;Their water bottles broke.&quot;
};
string sPattern = &quot;the(ir)?\s&quot; ;
foreach (string s in sentences)
{
Console.Write( $&quot;{s,24}&quot;);
if (System.Text.RegularExpressions.Regex.IsMatch(s, sPattern,<br />
System.Text.RegularExpressions.RegexOptions.IgnoreCase))
{
Console.WriteLine( $&quot;  (match for ' {sPattern} ' found)&quot; );
}
else
{
Console.WriteLine();
}
}
 Tip
The string methods are usually better choices when you are searching for an exact
string. R egular expressions are better when you are searching for some pattern in a
source string.
Does a string follow a pattern?The following code uses regular expressions to validate the format of each string in an
array. The validation requires that each string have the form of a telephone number in
which three groups of digits are separated by dashes, the first two groups contain three
digits, and the third group contains four digits. The search pattern uses the regular
expression ^\d{3}-\d{3}-\d{4}$. For more information, see Regular Expression
Language - Quick R eference .
Pattern Meaning
^ matches the beginning of the string
\d{3} matches exactly 3 digit characters</li>
</ul>
<ul>
<li>matches the '-' character
\d{4} matches exactly 4 digit characters
$ matches the end of the string
C#
string[] numbers =
{
&quot;123-555-0190&quot; ,
&quot;444-234-22450&quot; ,
&quot;690-555-0178&quot; ,
&quot;146-893-232&quot; ,
&quot;146-555-0122&quot; ,
&quot;4007-555-0111&quot; ,
&quot;407-555-0111&quot; ,
&quot;407-2-5555&quot; ,
&quot;407-555-8974&quot; ,
&quot;407-2ab-5555&quot; ,
&quot;690-555-8148&quot; ,
&quot;146-893-232-&quot;
};
string sPattern = &quot;^\d{3}-\d{3}-\d{4}$&quot; ;
foreach (string s in numbers)
{
Console.Write( $&quot;{s,14}&quot;);
if (System.Text.RegularExpressions.Regex.IsMatch(s, sPattern))
{
Console.WriteLine( &quot; - valid&quot; );
}
else
{
Console.WriteLine( &quot; - invalid&quot; );This single search pattern matches many valid strings. R egular expressions are better to
search for or validate against a pattern, rather than a single text string.
C# programming guide
Strings
System.T ext.R egularExpressions.R egex
.NET regular expressions
Regular expression language - quick reference
Best practices for using strings in .NET    }
}
See alsoHow to modify string contents in C#
Article •09/15/2021
This article demonstrates several techniques to produce a string by modifying an
existing string. All the techniques demonstrated return the result of the modifications
as a new string object. T o demonstrate that the original and modified strings are
distinct instances, the examples store the result in a new variable. Y ou can examine the
original string and the new, modified string when you run each example.
There are several techniques demonstrated in this article. Y ou can replace existing text.
You can search for patterns and replace matching text with other text. Y ou can treat a
string as a sequence of characters. Y ou can also use convenience methods that remove
white space. Choose the techniques that most closely match your scenario.
The following code creates a new string by replacing existing text with a substitute.
C#
The preceding code demonstrates this immut able property of strings. Y ou can see in the
preceding example that the original string, source, is not modified. The String.R eplace
method creates a new string containing the modifications.７ Note
The C# examples in this article run in the Try.NET inline code runner and
playground. Select the Run button to run an example in an interactive window.
Once you execute the code, you can modify it and run the modified code by
selecting Run again. The modified code either runs in the interactive window or, if
compilation fails, the interactive window displays all C# compiler error messages.
Replace text
string source = &quot;The mountains are behind the clouds today.&quot; ; 
// Replace one substring with another with String.Replace.<br />
// Only exact matches are supported.<br />
var replacement = source.Replace( &quot;mountains&quot; , &quot;peaks&quot;); 
Console.WriteLine( $&quot;The source string is &lt; {source} &gt;&quot;); 
Console.WriteLine( $&quot;The updated string is &lt; {replacement} &gt;&quot;); The Replace  method can replace either strings or single characters. In both cases, every
occurrence of the sought text is replaced. The following example replaces all ' '
characters with '<em>':
C#
The source string is unchanged, and a new string is returned with the replacement.
You can use the String.T rim, String.T rimStart, and String.T rimEnd  methods to remove any
leading or trailing white space. The following code shows an example of each. The
source string does not change; these methods return a new string with the modified
contents.
C#
You can remove text from a string using the String.R emove  method. This method
removes a number of characters starting at a specific index. The following example
shows how to use String.IndexOf  followed by Remove  to remove text from a string:
C#string source = &quot;The mountains are behind the clouds today.&quot; ; 
// Replace all occurrences of one char with another.<br />
var replacement = source.Replace( ' ', '</em>'); 
Console.WriteLine(source);<br />
Console.WriteLine(replacement);<br />
Trim white space
// Remove trailing and leading white space.<br />
string source = &quot;    I'm wider than I need to be.      &quot; ; 
// Store the results in a new string variable.<br />
var trimmedResult = source.Trim();<br />
var trimLeading = source.TrimStart();<br />
var trimTrailing = source.TrimEnd();<br />
Console.WriteLine( $&quot;&lt;{source} &gt;&quot;); 
Console.WriteLine( $&quot;&lt;{trimmedResult} &gt;&quot;); 
Console.WriteLine( $&quot;&lt;{trimLeading} &gt;&quot;); 
Console.WriteLine( $&quot;&lt;{trimTrailing} &gt;&quot;); 
Remove text
string source = &quot;Many mountains are behind many clouds today.&quot; ; 
// Remove a substring from the middle of the string.  You can use regular expressions  to replace text matching patterns with new text,
possibly defined by a pattern. The following example uses the
System.T ext.R egularExpressions.R egex  class to find a pattern in a source string and
replace it with proper capitalization. The Regex.R eplace(S tring, S tring, MatchEvaluator,
RegexOptions)  method takes a function that provides the logic of the replacement as
one of its arguments. In this example, that function, LocalReplaceMatchCase is a local
function  declared inside the sample method. LocalReplaceMatchCase uses the
System.T ext.StringBuilder  class to build the replacement string with proper capitalization.
Regular expressions are most useful for searching and replacing text that follows a
pattern, rather than known text. For more information, see How to search strings . The
search pattern, &quot;the\s&quot; searches for the word &quot;the&quot; followed by a white-space character.
That part of the pattern ensures that it doesn't match &quot;there&quot; in the source string. For
more information on regular expression language elements, see Regular Expression
Language - Quick R eference .
C#string toRemove = &quot;many &quot;; 
string result = string.Empty; 
int i = source.IndexOf(toRemove);<br />
if (i &gt;= 0) 
{ 
result= source.Remove(i, toRemove.Length);<br />
} 
Console.WriteLine(source);<br />
Console.WriteLine(result);<br />
Replace matching patterns
string source = &quot;The mountains are still there behind the clouds today.&quot; ; 
// Use Regex.Replace for more flexibility.<br />
// Replace &quot;the&quot; or &quot;The&quot; with &quot;many&quot; or &quot;Many&quot;.<br />
// using System.Text.RegularExpressions<br />
string replaceWith = &quot;many &quot;; 
source = System.Text.RegularExpressions.Regex.Replace(source, &quot;the\s&quot; , 
LocalReplaceMatchCase,<br />
System.Text.RegularExpressions.RegexOptions.IgnoreCase);<br />
Console.WriteLine(source);<br />
string LocalReplaceMatchCase (System.Text.RegularExpressions.Match<br />
matchExpression ) 
{ 
// Test whether the match is capitalized<br />
if (Char.IsUpper(matchExpression.Value[ 0])) 
{ The StringBuilder.T oString  method returns an immutable string with the contents in the
StringBuilder  object.
You can produce a character array from a string, modify the contents of the array, and
then create a new string from the modified contents of the array.
The following example shows how to replace a set of characters in a string. First, it uses
the String.T oCharArray()  method to create an array of characters. It uses the IndexOf
method to find the starting index of the word &quot;fox.&quot; The next three characters are
replaced with a different word. Finally, a new string is constructed from the updated
character array.
C#        // Capitalize the replacement string<br />
System.Text.StringBuilder replacementBuilder = new 
System.Text.StringBuilder(replaceWith);<br />
replacementBuilder[ 0] = Char.ToUpper(replacementBuilder[ 0]); 
return replacementBuilder.ToString();<br />
} 
else 
{ 
return replaceWith;<br />
} 
} 
Modifying individual characters
string phrase = &quot;The quick brown fox jumps over the fence&quot; ; 
Console.WriteLine(phrase);<br />
char[] phraseAsChars = phrase.ToCharArray();<br />
int animalIndex = phrase.IndexOf( &quot;fox&quot;); 
if (animalIndex != -1) 
{ 
phraseAsChars[animalIndex++] = 'c'; 
phraseAsChars[animalIndex++] = 'a'; 
phraseAsChars[animalIndex] = 't'; 
} 
string updatedPhrase = new string(phraseAsChars);<br />
Console.WriteLine(updatedPhrase);
Programmatically build up string contentSince strings are immutable, the previous examples all create temporary strings or
character arrays. In high-performance scenarios, it may be desirable to avoid these heap
allocations. .NET Core provides a String.Create  method that allows you to
programmatically fill in the character content of a string via a callback while avoiding the
intermediate temporary string allocations.
C#
You could modify a string in a fixed block with unsafe code, but it is strongly
discouraged to modify the string content after a string is created. Doing so will break
things in unpredictable ways. For example, if someone interns a string that has the same
content as yours, they'll get your copy and won't expect that you are modifying their
string.
.NET regular expressions
Regular expression language - quick reference// constructing a string from a char array, prefix it with some additional<br />
characters<br />
char[] chars = { 'a', 'b', 'c', 'd', '\0' }; 
int length = chars.Length + 2; 
string result = string.Create(length, chars, (Span&lt; char&gt; strContent, char[] 
charArray) =&gt;<br />
{ 
strContent[ 0] = '0'; 
strContent[ 1] = '1'; 
for (int i = 0; i &lt; charArray.Length; i++)<br />
{ 
strContent[i + 2] = charArray[i];<br />
} 
}); 
Console.WriteLine(result);<br />
See alsoHow to compare strings in C#
Article •04/28/2023
You compare strings to answer one of two questions: &quot;Are these two strings equal?&quot; or
&quot;In what order should these strings be placed when sorting them?&quot;
Those two questions are complicated by factors that affect string comparisons:
You can choose an ordinal or linguistic comparison.
You can choose if case matters.
You can choose culture-specific comparisons.
Linguistic comparisons are culture and platform-dependent.
When you compare strings, you define an order among them. Comparisons are used to
sort a sequence of strings. Once the sequence is in a known order, it is easier to search,
both for software and for humans. Other comparisons may check if strings are the same.
These sameness checks are similar to equality, but some differences, such as case
differences, may be ignored.
By default, the most common operations:
String.Equals
String.Equality  and String.Inequality , that is, equality operators == and !=,
respectively
perform a case-sensitive, ordinal comparison. In the case of String.Equals , a
StringComparison  argument can be provided to alter its sorting rules. The following
example demonstrates that:
C#７ Note
The C# examples in this article run in the Try.NET inline code runner and
playground. Select the Run button to run an example in an interactive window.
Once you execute the code, you can modify it and run the modified code by
selecting Run again. The modified code either runs in the interactive window or, if
compilation fails, the interactive window displays all C# compiler error messages.
Default ordinal comparisonsThe default ordinal comparison doesn't take linguistic rules into account when
comparing strings. It compares the binary value of each Char object in two strings. As a
result, the default ordinal comparison is also case-sensitive.
The test for equality with String.Equals  and the == and != operators differs from string
comparison using the String.CompareT o and Compare(S tring, S tring)  methods. They all
perform a case-sensitive comparison. However, while the tests for equality perform an
ordinal comparison, the CompareTo and Compare methods perform a culture-aware
linguistic comparison using the current culture. Because these default comparison
methods differ in the ways they compare strings, we recommend that you always make
the intent of your code clear by calling an overload that explicitly specifies the type of
comparison to perform.
The String.Equals(S tring, S tringComparison)  method enables you to specify a
StringComparison  value of StringComparison.OrdinalIgnoreCase  for a case-insensitive
ordinal comparison. There is also a static String.Compare(S tring, S tring,
StringComparison)  method that performs a case-insensitive ordinal comparison if you
specify a value of StringComparison.OrdinalIgnoreCase  for the StringComparison
argument. These are shown in the following code:
C#string root = @&quot;C:\users&quot; ; 
string root2 = @&quot;C:\Users&quot; ; 
bool result = root.Equals(root2);
Console.WriteLine( $&quot;Ordinal comparison: &lt; {root}&gt; and &lt;{root2}&gt; are {(result<br />
? &quot;equal.&quot;  : &quot;not equal.&quot; )}&quot;); 
result = root.Equals(root2, StringComparison.Ordinal);<br />
Console.WriteLine( $&quot;Ordinal comparison: &lt; {root}&gt; and &lt;{root2}&gt; are {(result<br />
? &quot;equal.&quot;  : &quot;not equal.&quot; )}&quot;); 
Console.WriteLine( $&quot;Using == says that &lt; {root}&gt; and &lt;{root2}&gt; are {(root ==<br />
root2 ? &quot;equal&quot; : &quot;not equal&quot; )}&quot;); 
Case-insensitive ordinal comparisons
string root = @&quot;C:\users&quot; ; 
string root2 = @&quot;C:\Users&quot; ; 
bool result = root.Equals(root2, StringComparison.OrdinalIgnoreCase);<br />
bool areEqual = String.Equals(root, root2,<br />
StringComparison.OrdinalIgnoreCase);<br />
int comparison = String.Compare(root, root2, comparisonType:  When performing a case-insensitive ordinal comparison, these methods use the casing
conventions of the invariant culture .
Many string comparison methods (such as String.S tartsWith ) use linguistic rules for the
current cultur e by default to order their inputs. This is sometimes referred to as &quot;word
sort order.&quot; When you perform a linguistic comparison, some nonalphanumeric Unicode
characters might have special weights assigned. For example, the hyphen &quot;-&quot; may have a
small weight assigned to it so that &quot;co-op&quot; and &quot;coop&quot; appear next to each other in sort
order, while some non-printing control characters might be completely ignored. In
addition, some Unicode characters may be equivalent to a sequence of Char instances.
The following example uses the phrase &quot;They dance in the street.&quot; in German with the
&quot;ss&quot; (U+0073 U+0073) in one string and 'ß' (U+00DF) in another. Linguistically (in
Windows), &quot;ss&quot; is equal to the German Esszet: 'ß' character in both the &quot;en-US&quot; and &quot;de-
DE&quot; cultures.
C#StringComparison.OrdinalIgnoreCase);<br />
Console.WriteLine( $&quot;Ordinal ignore case: &lt; {root}&gt; and &lt;{root2}&gt; are {(result<br />
? &quot;equal.&quot;  : &quot;not equal.&quot; )}&quot;); 
Console.WriteLine( $&quot;Ordinal static ignore case: &lt; {root}&gt; and &lt;{root2}&gt; are 
{(areEqual ? &quot;equal.&quot;  : &quot;not equal.&quot; )}&quot;); 
if (comparison &lt; 0) 
Console.WriteLine( $&quot;&lt;{root}&gt; is less than &lt; {root2}&gt;&quot;); 
else if (comparison &gt; 0) 
Console.WriteLine( $&quot;&lt;{root}&gt; is greater than &lt; {root2}&gt;&quot;); 
else 
Console.WriteLine( $&quot;&lt;{root}&gt; and &lt;{root2}&gt; are equivalent in order&quot; ); 
Linguistic comparisons
string first = &quot;Sie tanzen auf der Straße.&quot; ; 
string second = &quot;Sie tanzen auf der Strasse.&quot; ; 
Console.WriteLine( $&quot;First sentence is &lt; {first}&gt;&quot;); 
Console.WriteLine( $&quot;Second sentence is &lt; {second} &gt;&quot;); 
bool equal = String.Equals(first, second,<br />
StringComparison.InvariantCulture);<br />
Console.WriteLine( $&quot;The two strings {(equal == true ? &quot;are&quot; : &quot;are not&quot; )} 
equal.&quot;); 
showComparison(first, second);<br />
string word = &quot;coop&quot;; 
string words = &quot;co-op&quot;;
string other = &quot;cop&quot;; On Windows, prior to .NET 5, the sort order of &quot;cop&quot;, &quot;coop&quot;, and &quot;co-op&quot; changes when
you change from a linguistic comparison to an ordinal comparison. The two German
sentences also compare differently using the different comparison types. This is because
prior to .NET 5, the .NET globalization APIs used National Language Support (NLS)
libraries. In .NET 5 and later versions, the .NET globalization APIs use International
Components for Unicode (ICU)  libraries, which unifies .NET's globalization behavior
across all supported operating systems.
This sample stores CultureInfo  objects for the en-US and de-DE cultures. The
comparisons are performed using a CultureInfo  object to ensure a culture-specific
comparison.
The culture used affects linguistic comparisons. The following example shows the results
of comparing the two German sentences using the &quot;en-US&quot; culture and the &quot;de-DE&quot;
culture:
C#showComparison(word, words);<br />
showComparison(word, other);<br />
showComparison(words, other);<br />
void showComparison (string one, string two) 
{ 
int compareLinguistic = String.Compare(one, two,<br />
StringComparison.InvariantCulture);<br />
int compareOrdinal = String.Compare(one, two, StringComparison.Ordinal);<br />
if (compareLinguistic &lt; 0) 
Console.WriteLine( $&quot;&lt;{one}&gt; is less than &lt; {two}&gt; using invariant<br />
culture&quot; ); 
else if (compareLinguistic &gt; 0) 
Console.WriteLine( $&quot;&lt;{one}&gt; is greater than &lt; {two}&gt; using invariant<br />
culture&quot; ); 
else 
Console.WriteLine( $&quot;&lt;{one}&gt; and &lt;{two}&gt; are equivalent in order<br />
using invariant culture&quot; ); 
if (compareOrdinal &lt; 0) 
Console.WriteLine( $&quot;&lt;{one}&gt; is less than &lt; {two}&gt; using ordinal<br />
comparison&quot; ); 
else if (compareOrdinal &gt; 0) 
Console.WriteLine( $&quot;&lt;{one}&gt; is greater than &lt; {two}&gt; using ordinal<br />
comparison&quot; ); 
else 
Console.WriteLine( $&quot;&lt;{one}&gt; and &lt;{two}&gt; are equivalent in order<br />
using ordinal comparison&quot; ); 
} 
Comparisons using specific cultur esstring first = &quot;Sie tanzen auf der Straße.&quot; ; 
string second = &quot;Sie tanzen auf der Strasse.&quot; ; 
Console.WriteLine( $&quot;First sentence is &lt; {first}&gt;&quot;); 
Console.WriteLine( $&quot;Second sentence is &lt; {second} &gt;&quot;); 
var en = new System.Globalization.CultureInfo( &quot;en-US&quot;); 
// For culture-sensitive comparisons, use the String.Compare<br />
// overload that takes a StringComparison value.<br />
int i = String.Compare(first, second, en,<br />
System.Globalization.CompareOptions.None);<br />
Console.WriteLine( $&quot;Comparing in {en.Name}  returns {i}.&quot;); 
var de = new System.Globalization.CultureInfo( &quot;de-DE&quot;); 
i = String.Compare(first, second, de,<br />
System.Globalization.CompareOptions.None);<br />
Console.WriteLine( $&quot;Comparing in {de.Name}  returns {i}.&quot;); 
bool b = String.Equals(first, second, StringComparison.CurrentCulture);<br />
Console.WriteLine( $&quot;The two strings {(b ? &quot;are&quot; : &quot;are not&quot; )} equal.&quot; ); 
string word = &quot;coop&quot;; 
string words = &quot;co-op&quot;;
string other = &quot;cop&quot;; 
showComparison(word, words, en);<br />
showComparison(word, other, en);<br />
showComparison(words, other, en);
void showComparison (string one, string two, System.Globalization.CultureInfo<br />
culture) 
{ 
int compareLinguistic = String.Compare(one, two, en,<br />
System.Globalization.CompareOptions.None);<br />
int compareOrdinal = String.Compare(one, two, StringComparison.Ordinal);<br />
if (compareLinguistic &lt; 0) 
Console.WriteLine( $&quot;&lt;{one}&gt; is less than &lt; {two}&gt; using en-US<br />
culture&quot; ); 
else if (compareLinguistic &gt; 0) 
Console.WriteLine( $&quot;&lt;{one}&gt; is greater than &lt; {two}&gt; using en-US<br />
culture&quot; ); 
else 
Console.WriteLine( $&quot;&lt;{one}&gt; and &lt;{two}&gt; are equivalent in order<br />
using en-US culture&quot; ); 
if (compareOrdinal &lt; 0) 
Console.WriteLine( $&quot;&lt;{one}&gt; is less than &lt; {two}&gt; using ordinal<br />
comparison&quot; ); 
else if (compareOrdinal &gt; 0) 
Console.WriteLine( $&quot;&lt;{one}&gt; is greater than &lt; {two}&gt; using ordinal<br />
comparison&quot; ); 
else 
Console.WriteLine( $&quot;&lt;{one}&gt; and &lt;{two}&gt; are equivalent in order<br />
using ordinal comparison&quot; ); 
} Culture-sensitive comparisons are typically used to compare and sort strings input by
users with other strings input by users. The characters and sorting conventions of these
strings might vary depending on the locale of the user's computer. Even strings that
contain identical characters might sort differently depending on the culture of the
current thread.
The following examples show how to sort and search for strings in an array using a
linguistic comparison dependent on the current culture. Y ou use the static Array
methods that take a System.S tringComparer  parameter.
This example shows how to sort an array of strings using the current culture:
C#
Once the array is sorted, you can search for entries using a binary search. A binary
search starts in the middle of the collection to determine which half of the collection
would contain the sought string. Each subsequent comparison subdivides the remaining
part of the collection in half. The array is sorted using theLinguistic sorting and searching strings in
arrays
string[] lines = new string[] 
{ 
@&quot;c:\public\textfile.txt&quot; , 
@&quot;c:\public\textFile.TXT&quot; , 
@&quot;c:\public\Text.txt&quot; , 
@&quot;c:\public\testfile2.txt&quot;<br />
}; 
Console.WriteLine( &quot;Non-sorted order:&quot; ); 
foreach (string s in lines) 
{ 
Console.WriteLine( $&quot;   {s}&quot;); 
} 
Console.WriteLine( &quot;\n\rSorted order:&quot; ); 
// Specify Ordinal to demonstrate the different behavior.<br />
Array.Sort(lines, StringComparer.CurrentCulture);<br />
foreach (string s in lines) 
{ 
Console.WriteLine( $&quot;   {s}&quot;); 
} StringComparer.CurrentCulture . The local function ShowWhere displays information about
where the string was found. If the string wasn't found, the returned value indicates
where it would be if it were found.
C#
string[] lines = new string[] 
{ 
@&quot;c:\public\textfile.txt&quot; , 
@&quot;c:\public\textFile.TXT&quot; , 
@&quot;c:\public\Text.txt&quot; , 
@&quot;c:\public\testfile2.txt&quot;<br />
}; 
Array.Sort(lines, StringComparer.CurrentCulture);<br />
string searchString = @&quot;c:\public\TEXTFILE.TXT&quot; ; 
Console.WriteLine( $&quot;Binary search for &lt; {searchString} &gt;&quot;); 
int result = Array.BinarySearch(lines, searchString,<br />
StringComparer.CurrentCulture);<br />
ShowWhere&lt; string&gt;(lines, result);<br />
Console.WriteLine( $&quot;{(result &gt; 0 ? &quot;Found&quot; : &quot;Did not find&quot; )} 
{searchString} &quot;); 
void ShowWhere<T>(T[] array, int index) 
{ 
if (index &lt; 0) 
{ 
index = ~index;<br />
Console.Write( &quot;Not found. Sorts between: &quot; ); 
if (index == 0)
Console.Write( &quot;beginning of sequence and &quot; ); 
else 
Console.Write( $&quot;{array[index - 1]} and &quot;); 
if (index == array.Length)<br />
Console.WriteLine( &quot;end of sequence.&quot; ); 
else 
Console.WriteLine( $&quot;{array[index]} .&quot;); 
} 
else 
{ 
Console.WriteLine( $&quot;Found at index {index}.&quot;); 
} 
} 
Ordinal sorting and searching in collectionsThe following code uses the System.Collections.Generic.List<T>  collection class to store
strings. The strings are sorted using the List<T>.Sort  method. This method needs a
delegate that compares and orders two strings. The String.CompareT o method provides
that comparison function. Run the sample and observe the order. This sort operation
uses an ordinal case-sensitive sort. Y ou would use the static String.Compare  methods to
specify different comparison rules.
C#
Once sorted, the list of strings can be searched using a binary search. The following
sample shows how to search the sorted list using the same comparison function. The
local function ShowWhere shows where the sought text is or would be:
C#List<string> lines = new List<string> 
{ 
@&quot;c:\public\textfile.txt&quot; , 
@&quot;c:\public\textFile.TXT&quot; , 
@&quot;c:\public\Text.txt&quot; , 
@&quot;c:\public\testfile2.txt&quot;<br />
}; 
Console.WriteLine( &quot;Non-sorted order:&quot; ); 
foreach (string s in lines) 
{ 
Console.WriteLine( $&quot;   {s}&quot;); 
} 
Console.WriteLine( &quot;\n\rSorted order:&quot; ); 
lines.Sort((left, right) =&gt; left.CompareTo(right));<br />
foreach (string s in lines) 
{ 
Console.WriteLine( $&quot;   {s}&quot;); 
} 
List<string> lines = new List<string> 
{ 
@&quot;c:\public\textfile.txt&quot; , 
@&quot;c:\public\textFile.TXT&quot; , 
@&quot;c:\public\Text.txt&quot; , 
@&quot;c:\public\testfile2.txt&quot;<br />
}; 
lines.Sort((left, right) =&gt; left.CompareTo(right));<br />
string searchString = @&quot;c:\public\TEXTFILE.TXT&quot; ; 
Console.WriteLine( $&quot;Binary search for &lt; {searchString} &gt;&quot;); 
int result = lines.BinarySearch(searchString);<br />
ShowWhere&lt; string&gt;(lines, result);  Always make sure to use the same type of comparison for sorting and searching. Using
different comparison types for sorting and searching produces unexpected results.
Collection classes such as System.Collections.Hashtable ,
System.Collections.Generic.Dictionary&lt;TK ey,TValue&gt; , and
System.Collections.Generic.List<T>  have constructors that take a System.S tringComparer
parameter when the type of the elements or keys is string. In general, you should use
these constructors whenever possible, and specify either StringComparer.Ordinal  or
StringComparer.OrdinalIgnoreCase .
System.Globalization.CultureInfo
System.S tringComparer
Strings
Comparing strings
Globalizing and localizing applicationsConsole.WriteLine( $&quot;{(result &gt; 0 ? &quot;Found&quot; : &quot;Did not find&quot; )} 
{searchString} &quot;); 
void ShowWhere<T>(IList<T> collection, int index) 
{ 
if (index &lt; 0) 
{ 
index = ~index;<br />
Console.Write( &quot;Not found. Sorts between: &quot; ); 
if (index == 0)
Console.Write( &quot;beginning of sequence and &quot; ); 
else 
Console.Write( $&quot;{collection[index - 1]} and &quot;); 
if (index == collection.Count)<br />
Console.WriteLine( &quot;end of sequence.&quot; ); 
else 
Console.WriteLine( $&quot;{collection[index]} .&quot;); 
} 
else 
{ 
Console.WriteLine( $&quot;Found at index {index}.&quot;); 
} 
} 
See alsoHow to catch a non-CLS exception
Article •09/15/2021
Some .NET languages, including C++/CLI, allow objects to throw exceptions that do not
derive from Exception . Such exceptions are called non-CLS ex ceptions  or non-Ex ceptions .
In C# you cannot throw non-CLS exceptions, but you can catch them in two ways:
Within a catch (RuntimeWrappedException e) block.
By default, a Visual C# assembly catches non-CLS exceptions as wrapped
exceptions. Use this method if you need access to the original exception, which
can be accessed through the RuntimeWrappedException.WrappedException
property. The procedure later in this topic explains how to catch exceptions in this
manner.
Within a general catch block (a catch block without an exception type specified)
that is put after all other catch blocks.
Use this method when you want to perform some action (such as writing to a log
file) in response to non-CLS exceptions, and you do not need access to the
exception information. By default the common language runtime wraps all
exceptions. T o disable this behavior, add this assembly-level attribute to your code,
typically in the AssemblyInfo.cs file: [assembly:
RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)].
Within a catch(RuntimeWrappedException e) block, access the original exception through
the RuntimeWrappedException.WrappedException  property.
The following example shows how to catch a non-CLS exception that was thrown from a
class library written in C++/CLI. Note that in this example, the C# client code knows in
advance that the exception type being thrown is a System.S tring . You can cast the
RuntimeWrappedException.WrappedException  property back its original type as long as
that type is accessible from your code.
C#To catch a non-CLS exception
ExampleRuntimeWrappedException
Exceptions and Exception Handling// Class library written in C++/CLI.<br />
var myClass = new ThrowNonCLS.Class1();<br />
try 
{ 
// throws gcnew System::String(<br />
// &quot;I do not derive from System.Exception!&quot;);<br />
myClass.TestThrow();<br />
} 
catch (RuntimeWrappedException e)
{ 
String s = e.WrappedException as String;<br />
if (s != null) 
{ 
Console.WriteLine(s);<br />
} 
} 
See alsoAttributes
Article •03/15/2023
Attributes provide a powerful method of associating metadata, or declarative
information, with code (assemblies, types, methods, properties, and so forth). After an
attribute is associated with a program entity, the attribute can be queried at run time by
using a technique called reflection .
Attributes have the following properties:
Attributes add metadata to your program. Metadata is information about the types
defined in a program. All .NET assemblies contain a specified set of metadata that
describes the types and type members defined in the assembly. Y ou can add
custom attributes to specify any additional information that is required.
You can apply one or more attributes to entire assemblies, modules, or smaller
program elements such as classes and properties.
Attributes can accept arguments in the same way as methods and properties.
Your program can examine its own metadata or the metadata in other programs
by using reflection.
Reflection provides objects (of type Type) that describe assemblies, modules, and types.
You can use reflection to dynamically create an instance of a type, bind the type to an
existing object, or get the type from an existing object and invoke its methods or access
its fields and properties. If you're using attributes in your code, reflection enables you to
access them. For more information, see Attributes .
Here's a simple example of reflection using the GetType()  method - inherited by all types
from the Object base class - to obtain the type of a variable:
C#７ Note
Make sure you add using System; and using System.Reflection; at the top of
your .cs file.
// Using GetType to obtain type information:<br />
int i = 42; 
Type type = i.GetType();<br />
Console.WriteLine(type);  The output is: System.Int32.
The following example uses reflection to obtain the full name of the loaded assembly.
C#
The output is something like: System.Private.CoreLib, Version=7.0.0.0,
Culture=neutral, PublicKeyToken=7cec85d7bea7798e.
Attributes can be placed on almost any declaration, though a specific attribute might
restrict the types of declarations on which it's valid. In C#, you specify an attribute by
placing the name of the attribute enclosed in square brackets ( []) above the
declaration of the entity to which it applies.
In this example, the SerializableAttribute  attribute is used to apply a specific
characteristic to a class:
C#
A method with the attribute DllImportAttribute  is declared like the following example:
C#// Using Reflection to get information of an Assembly:<br />
Assembly info = typeof(int).Assembly;<br />
Console.WriteLine(info);<br />
７ Note
The C# keywords protected and internal have no meaning in Intermediate
Language (IL) and are not used in the reflection APIs. The corresponding terms in IL
are Family  and Assembly . To identify an internal method using reflection, use the
IsAssembly  property. T o identify a protected internal method, use the
IsFamilyOrAssembly .
Using attributes
[Serializable ] 
public class SampleClass<br />
{ 
// Objects of this type can be serialized.<br />
} More than one attribute can be placed on a declaration as the following example shows:
C#
Some attributes can be specified more than once for a given entity. An example of such
a multiuse attribute is ConditionalAttribute :
C#
Many attributes have parameters, which can be positional, unnamed, or named. Any
positional parameters must be specified in a certain order and can't be omitted. Named
parameters are optional and can be specified in any order. P ositional parameters are
specified first. For example, these three attributes are equivalent:
C#[System.Runtime.InteropServices.DllImport( &quot;user32.dll&quot; )]
extern static void SampleMethod (); 
void MethodA([In][Out] ref double x) { } 
void MethodB([Out][In] ref double x) { } 
void MethodC([In, Out] ref double x) { } 
[Conditional( &quot;DEBUG&quot;), Conditional( &quot;TEST1&quot;)] 
void TraceMethod () 
{ 
// ... 
} 
７ Note
By convention, all attribute names end with the word &quot;Attribute&quot; to distinguish
them from other items in the .NET libraries. However, you do not need to specify
the attribute suffix when using attributes in code. For example, [DllImport] is
equivalent to [DllImportAttribute], but DllImportAttribute is the attribute's
actual name in the .NET Class Library.
Attribute parameters
[DllImport( &quot;user32.dll&quot; )] 
[DllImport( &quot;user32.dll&quot; , SetLastError=false, ExactSpelling=false) ] 
[DllImport( &quot;user32.dll&quot; , ExactSpelling=false, SetLastError=false) ] The first parameter, the DLL name, is positional and always comes first; the others are
named. In this case, both named parameters default to false, so they can be omitted.
Positional parameters correspond to the parameters of the attribute constructor. Named
or optional parameters correspond to either properties or fields of the attribute. R efer to
the individual attribute's documentation for information on default parameter values.
For more information on allowed parameter types, see the Attributes  section of the C#
language specification
The target of an attribute is the entity that the attribute applies to. For example, an
attribute may apply to a class, a particular method, or an entire assembly. By default, an
attribute applies to the element that follows it. But you can also explicitly identify, for
example, whether an attribute is applied to a method, or to its parameter, or to its return
value.
To explicitly identify an attribute target, use the following syntax:
C#
The list of possible target values is shown in the following table.
Target v alue Applies t o
assembly Entire assembly
module Current assembly module
field Field in a class or a struct
event Event
method Method or get and set property accessors
param Method parameters or set property accessor parameters
property Property
return Return value of a method, property indexer, or get property accessor
type Struct, class, interface, enum, or delegateAttribute targets
[target : attribute-list ] You would specify the field target value to apply an attribute to the backing field
created for an auto-implemented property .
The following example shows how to apply attributes to assemblies and modules. For
more information, see Common Attributes (C#) .
C#
The following example shows how to apply attributes to methods, method parameters,
and method return values in C#.
C#
The following list includes a few of the common uses of attributes in code:using System;<br />
using System.Reflection;<br />
[assembly: AssemblyTitleAttribute( &quot;Production assembly 4&quot; )] 
[module: CLSCompliant(true) ] 
// default: applies to method<br />
[ValidatedContract ] 
int Method1() { return 0; } 
// applies to method<br />
[method: ValidatedContract ] 
int Method2() { return 0; } 
// applies to parameter<br />
int Method3([ValidatedContract] string contract ) { return 0; } 
// applies to return value<br />
[return: ValidatedContract ] 
int Method4() { return 0; } 
７ Note
Regardless of the targets on which ValidatedContract is defined to be valid, the
return target has to be specified, even if ValidatedContract were defined to apply
only to return values. In other words, the compiler will not use AttributeUsage
information to resolve ambiguous attribute targets. For more information, see
Attribut eUsage .
Common uses for attributesMarking methods using the WebMethod attribute in W eb services to indicate that
the method should be callable over the SO AP protocol. For more information, see
WebMethodAttribute .
Describing how to marshal method parameters when interoperating with native
code. For more information, see MarshalAsAttribute .
Describing the C OM properties for classes, methods, and interfaces.
Calling unmanaged code using the DllImportAttribute  class.
Describing your assembly in terms of title, version, description, or trademark.
Describing which members of a class to serialize for persistence.
Describing how to map between class members and XML nodes for XML
serialization.
Describing the security requirements for methods.
Specifying characteristics used to enforce security.
Controlling optimizations by the just-in-time (JIT) compiler so the code remains
easy to debug.
Obtaining information about the caller to a method.
Reflection is useful in the following situations:
When you have to access attributes in your program's metadata. For more
information, see Retrieving Information S tored in Attributes .
For examining and instantiating types in an assembly.
For building new types at run time. Use classes in System.R eflection.Emit .
For performing late binding, accessing methods on types created at run time. See
the article Dynamically Loading and Using T ypes.
For more information:
Common Attributes (C#)
Caller Information (C#)
Attributes
Reflection
Viewing T ype Information
Reflection and Generic T ypes
System.R eflection.Emit
Retrieving Information S tored in AttributesReflection overview
Related sectionsCreate custom attributes
Article •03/15/2023
You can create your own custom attributes by defining an attribute class, a class that
derives directly or indirectly from Attribute , which makes identifying attribute definitions
in metadata fast and easy. Suppose you want to tag types with the name of the
programmer who wrote the type. Y ou might define a custom Author attribute class:
C#
The class name AuthorAttribute is the attribute's name, Author, plus the Attribute
suffix. It's derived from System.Attribute, so it's a custom attribute class. The
constructor's parameters are the custom attribute's positional parameters. In this
example, name is a positional parameter. Any public read-write fields or properties are
named parameters. In this case, version is the only named parameter. Note the use of
the AttributeUsage attribute to make the Author attribute valid only on class and
struct declarations.
You could use this new attribute as follows:
C#[System.AttributeUsage(System.AttributeTargets.Class |<br />
System.AttributeTargets.Struct)<br />
] 
public class AuthorAttribute  : System.Attribute<br />
{ 
private string Name; 
public double Version;<br />
public AuthorAttribute (string name) 
{ 
Name = name;<br />
Version = 1.0; 
} 
} 
[Author(&quot;P. Ackerman&quot; , Version = 1.1)] 
class SampleClass<br />
{ 
// P. Ackerman's code goes here...<br />
} AttributeUsage has a named parameter, AllowMultiple, with which you can make a
custom attribute single-use or multiuse. In the following code example, a multiuse
attribute is created.
C#
In the following code example, multiple attributes of the same type are applied to a
class.
C#
System.R eflection
Writing Custom Attributes
AttributeUsage (C#)[System.AttributeUsage(System.AttributeTargets.Class |<br />
System.AttributeTargets.Struct,<br />
AllowMultiple = true)  // Multiuse attribute.<br />
] 
public class AuthorAttribute  : System.Attribute<br />
{ 
string Name; 
public double Version;<br />
public AuthorAttribute (string name) 
{ 
Name = name;<br />
// Default value.<br />
Version = 1.0; 
} 
public string GetName() =&gt; Name;<br />
} 
[Author(&quot;P. Ackerman&quot; ), Author( &quot;R. Koch&quot; , Version = 2.0)] 
public class ThirdClass
{ 
// ... 
} 
See alsoAcces s attributes using reflection
Article •03/15/2023
The fact that you can define custom attributes and place them in your source code
would be of little value without some way of retrieving that information and acting on it.
By using reflection, you can retrieve the information that was defined with custom
attributes. The key method is GetCustomAttributes, which returns an array of objects
that are the run-time equivalents of the source code attributes. This method has many
overloaded versions. For more information, see Attribute .
An attribute specification such as:
C#
is conceptually equivalent to the following code:
C#
However, the code isn't executed until SampleClass is queried for attributes. Calling
GetCustomAttributes on SampleClass causes an Author object to be constructed and
initialized. If the class has other attributes, other attribute objects are constructed
similarly. GetCustomAttributes then returns the Author object and any other attribute
objects in an array. Y ou can then iterate over this array, determine what attributes were
applied based on the type of each array element, and extract information from the
attribute objects.
Here's a complete example. A custom attribute is defined, applied to several entities,
and retrieved via reflection.
C#[Author(&quot;P. Ackerman&quot; , Version = 1.1)] 
class SampleClass  { } 
var anonymousAuthorObject = new Author( &quot;P. Ackerman&quot; ) 
{ 
Version = 1.1 
}; 
// Multiuse attribute.<br />
[System.AttributeUsage(System.AttributeTargets.Class |<br />
System.AttributeTargets.Struct,<br />
AllowMultiple = true)  // Multiuse attribute.<br />
] public class AuthorAttribute  : System.Attribute<br />
{ 
string Name; 
public double Version;<br />
public AuthorAttribute (string name) 
{ 
Name = name;<br />
// Default value.<br />
Version = 1.0; 
} 
public string GetName() =&gt; Name;<br />
} 
// Class with the Author attribute.<br />
[Author(&quot;P. Ackerman&quot; )]
public class FirstClass
{ 
// ... 
} 
// Class without the Author attribute.<br />
public class SecondClass<br />
{ 
// ... 
} 
// Class with multiple Author attributes.<br />
[Author(&quot;P. Ackerman&quot; ), Author( &quot;R. Koch&quot; , Version = 2.0)] 
public class ThirdClass
{ 
// ... 
} 
class TestAuthorAttribute<br />
{ 
public static void Test() 
{ 
PrintAuthorInfo( typeof(FirstClass));<br />
PrintAuthorInfo( typeof(SecondClass));<br />
PrintAuthorInfo( typeof(ThirdClass));<br />
} 
private static void PrintAuthorInfo (System.Type t ) 
{ 
System.Console.WriteLine( $&quot;Author information for {t}&quot;); 
// Using reflection.<br />
System.Attribute[] attrs = System.Attribute.GetCustomAttributes(t);<br />
// Reflection.<br />
// Displaying output.<br />
foreach (System.Attribute attr in attrs) System.R eflection
Attribute
Retrieving Information S tored in Attributes        {<br />
if (attr is AuthorAttribute a)<br />
{<br />
System.Console.WriteLine( $&quot;   {a.GetName()} , version<br />
{a.Version:f} &quot;); 
}<br />
}<br />
} 
} 
/* Output:<br />
Author information for FirstClass<br />
P. Ackerman, version 1.00<br />
Author information for SecondClass<br />
Author information for ThirdClass<br />
R. Koch, version 2.00<br />
P. Ackerman, version 1.00<br />
*/ 
See alsoHow to create a C/C++ union by using
attributes in C#
Article •03/15/2023
By using attributes, you can customize how structs are laid out in memory. For example,
you can create what is known as a union in C/C++ by using the
StructLayout(LayoutKind.Explicit) and FieldOffset attributes.
In this code segment, all of the fields of TestUnion start at the same location in memory.
C#
The following code is another example where fields start at different explicitly set
locations.
C#[System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit) ]
struct TestUnion<br />
{ 
[System.Runtime.InteropServices.FieldOffset( 0)] 
public int i; 
[System.Runtime.InteropServices.FieldOffset( 0)] 
public double d; 
[System.Runtime.InteropServices.FieldOffset( 0)] 
public char c; 
[System.Runtime.InteropServices.FieldOffset( 0)] 
public byte b; 
} 
[System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit) ]
struct TestExplicit<br />
{ 
[System.Runtime.InteropServices.FieldOffset( 0)] 
public long lg; 
[System.Runtime.InteropServices.FieldOffset( 0)] 
public int i1; 
[System.Runtime.InteropServices.FieldOffset( 4)] 
public int i2; 
[System.Runtime.InteropServices.FieldOffset( 8)] 
public double d; The two integer fields, i1 and i2 combined, share the same memory locations as lg.
Either lg uses the first 8 bytes, or i1 uses the first 4 bytes and i2 uses the next 4 bytes.
This sort of control over struct layout is useful when using platform invocation.
System.R eflection
Attribute
Attributes    [System.Runtime.InteropServices.FieldOffset( 12)] 
public char c; 
[System.Runtime.InteropServices.FieldOffset( 14)] 
public byte b; 
} 
See alsoGenerics and Attributes
Article •03/15/2023
Attributes can be applied to generic types in the same way as nongeneric types.
However, you can apply attributes only on open gener ic types  and closed constr ucted
gener ic types , not on partially c onstr ucted gener ic types . An open gener ic type  is one
where none of the type arguments are specified, such as Dictionary&lt;TKey, TValue&gt; A
closed constr ucted gener ic type  specifies all type arguments, such as Dictionary&lt;string,
object&gt;. A partially c onstr ucted gener ic type  specifies some, but not all, type arguments.
An example is Dictionary&lt;string, TValue&gt;.
The following examples use this custom attribute:
C#
An attribute can reference an open generic type:
C#
Specify multiple type parameters using the appropriate number of commas. In this
example, GenericClass2 has two type parameters:
C#
An attribute can reference a closed constructed generic type:
C#class CustomAttribute  : Attribute<br />
{ 
public object? info; 
} 
public class GenericClass1 <T> { } 
[CustomAttribute(info = typeof(GenericClass1&lt;&gt;)) ] 
class ClassA { } 
public class GenericClass2 &lt;T, U&gt; { } 
[CustomAttribute(info = typeof(GenericClass2&lt;,&gt;)) ] 
class ClassB { } An attribute that references a generic type parameter causes a compile-time error:
C#
Beginning with C# 11, a generic type can inherit from Attribute :
C#
To obtain information about a generic type or type parameter at run time, you can use
the methods of System.R eflection . For more information, see Generics and R eflection .
Generics
Attributespublic class GenericClass3 &lt;T, U, V&gt; { } 
[CustomAttribute(info = typeof(GenericClass3&lt;int, double, string&gt;)) ] 
class ClassC { } 
[CustomAttribute(info = typeof(GenericClass3&lt;int, T, string&gt;)) ]  //Error 
CS0416 
class ClassD<T> { } 
public class CustomGenericAttribute <T> : Attribute  { }  //Requires C# 11<br />
See alsoHow to query an assembly's metadata
with Reflection (LINQ)
Article •03/15/2023
You use the .NET reflection APIs to examine the metadata in a .NET assembly and create
collections of types, type members, and parameters that are in that assembly. Because
these collections support the generic IEnumerable<T>  interface, they can be queried by
using LINQ.
The following example shows how LINQ can be used with reflection to retrieve specific
metadata about methods that match a specified search criterion. In this case, the query
finds the names of all the methods in the assembly that return enumerable types such
as arrays.
C#
The example uses the Assembly.GetT ypes method to return an array of types in the
specified assembly. The where  filter is applied so that only public types are returned. For
each public type, a subquery is generated by using the MethodInfo  array that is
returned from the Type.GetMethods  call. These results are filtered to return only those
methods whose return type is an array or else a type that implements IEnumerable<T> .
Finally, these results are grouped by using the type name as a key.Assembly assembly = Assembly.Load( &quot;System.Private.CoreLib, Version=7.0.0.0,<br />
Culture=neutral, PublicKeyToken=7cec85d7bea7798e&quot; ); 
var pubTypesQuery = from type in assembly.GetTypes()<br />
where type.IsPublic<br />
from method in type.GetMethods()<br />
where method.ReturnType.IsArray == true 
|| (method.ReturnType.GetInterface(</li>
</ul>
<p>typeof(System.Collections.Generic.IEnumerable&lt;&gt;).FullName!) != null 
&amp;&amp; method.ReturnType.FullName != &quot;System.String&quot; ) 
group method.ToString() by type.ToString();<br />
foreach (var groupOfMethods in pubTypesQuery)<br />
{ 
Console.WriteLine( &quot;Type: {0}&quot; , groupOfMethods.Key);<br />
foreach (var method in groupOfMethods)<br />
{ 
Console.WriteLine( &quot;  {0}&quot;, method);<br />
} 
} Generics and reflection
Article •03/15/2023
Because the Common Language Runtime (CLR) has access to generic type information
at run time, you can use reflection to obtain information about generic types in the
same way as for nongeneric types. For more information, see Generics in the Runtime .
The System.R eflection.Emit  namespace also contains new members that support
generics. See How to: Define a Generic T ype with R eflection Emit .
For a list of the invariant conditions for terms used in generic reflection, see the
IsGenericT ype property remarks:
IsGenericT ype: Returns true if a type is generic.
GetGenericArguments : Returns an array of Type objects that represent the type
arguments supplied for a constructed type, or the type parameters of a generic
type definition.
GetGenericT ypeDefinition : Returns the underlying generic type definition for the
current constructed type.
GetGenericP arameterConstraints : Returns an array of Type objects that represent
the constraints on the current generic type parameter.
ContainsGenericP arameters : Returns true if the type or any of its enclosing types or
methods contain type parameters for which specific types haven't been supplied.
GenericP arameterAttributes : Gets a combination of GenericParameterAttributes
flags that describe the special constraints of the current generic type parameter.
GenericP arameterP osition : For a Type object that represents a type parameter, gets
the position of the type parameter in the type parameter list of the generic type
definition or generic method definition that declared the type parameter.
IsGenericP arameter : Gets a value that indicates whether the current Type
represents a type parameter of a generic type or method definition.
IsGenericT ypeDefinition : Gets a value that indicates whether the current Type
represents a generic type definition, from which other generic types can be
constructed. R eturns true if the type represents the definition of a generic type.
DeclaringMethod : Returns the generic method that defined the current generic
type parameter, or null if the type parameter wasn't defined by a generic method.
MakeGenericT ype: Substitutes the elements of an array of types for the type
parameters of the current generic type definition, and returns a Type object
representing the resulting constructed type.
In addition, members of the MethodInfo  class enable run-time information for generic
methods. See the IsGenericMethod  property remarks for a list of invariant conditions forterms used to reflect on generic methods:
IsGenericMethod : Returns true if a method is generic.
GetGenericArguments : Returns an array of T ype objects that represent the type
arguments of a constructed generic method or the type parameters of a generic
method definition.
GetGenericMethodDefinition : Returns the underlying generic method definition for
the current constructed method.
ContainsGenericP arameters : Returns true if the method or any of its enclosing
types contain any type parameters for which specific types haven't been supplied.
IsGenericMethodDefinition : Returns true if the current MethodInfo  represents the
definition of a generic method.
MakeGenericMethod : Substitutes the elements of an array of types for the type
parameters of the current generic method definition, and returns a MethodInfo
object representing the resulting constructed method.
Generics
Reflection and Generic T ypes
GenericsSee alsoDefine and read custom attributes
Article •03/15/2023
Attributes provide a way of associating information with code in a declarative way. They
can also provide a reusable element that can be applied to various targets. Consider the
ObsoleteAttribute . It can be applied to classes, structs, methods, constructors, and more.
It declar es that the element is obsolete. It's then up to the C# compiler to look for this
attribute, and do some action in response.
In this tutorial, you learn how to add attributes to your code, how to create and use your
own attributes, and how to use some attributes that are built into .NET.
You need to set up your machine to run .NET. Y ou can find the installation instructions
on the .NET Downloads  page. Y ou can run this application on Windows, Ubuntu Linux,
macOS, or in a Docker container. Y ou need to install your favorite code editor. The
following descriptions use Visual S tudio Code , which is an open-source, cross-
platform editor. However, you can use whatever tools you're comfortable with.
Now that you've installed all the tools, create a new .NET console app. T o use the
command line generator, execute the following command in your favorite shell:
.NET CLI
This command creates bare-bones .NET project files. Y ou run dotnet restore to restore
the dependencies needed to compile this project.
You don't have to run dotnet restore  because it's run implicitly by all commands that
require a restore to occur, such as dotnet new, dotnet build, dotnet run, dotnet test,
dotnet publish, and dotnet pack. To disable implicit restore, use the --no-restore
option.
The dotnet restore command is still useful in certain scenarios where explicitly
restoring makes sense, such as continuous integration builds in Azure DevOps Services
or in build systems that need to explicitly control when the restore occurs.Prerequisites
Create the app
dotnet new console  For information about how to manage NuGet feeds, see the dotnet restore
documentation .
To execute the program, use dotnet run. You should see &quot;Hello, W orld&quot; output to the
console.
In C#, attributes are classes that inherit from the Attribute base class. Any class that
inherits from Attribute can be used as a sort of &quot;tag&quot; on other pieces of code. For
instance, there's an attribute called ObsoleteAttribute. This attribute signals that code is
obsolete and shouldn't be used anymore. Y ou place this attribute on a class, for
instance, by using square brackets.
C#
While the class is called ObsoleteAttribute, it's only necessary to use [Obsolete] in the
code. Most C# code follows this convention. Y ou can use the full name
[ObsoleteAttribute] if you choose.
When marking a class obsolete, it's a good idea to provide some information as to why
it's obsolete, and/or what  to use instead. Y ou include a string parameter to the Obsolete
attribute to provide this explanation.
C#
The string is being passed as an argument to an ObsoleteAttribute constructor, as if
you were writing var attr = new ObsoleteAttribute(&quot;some string&quot;).
Parameters to an attribute constructor are limited to simple types/literals: bool, int,
double, string, Type, enums, etc and arrays of those types. Y ou can't use an
expression or a variable. Y ou're free to use positional or named parameters.Add attributes to code
[Obsolete ] 
public class MyClass 
{ 
} 
[Obsolete( &quot;ThisClass is obsolete. Use ThisClass2 instead.&quot; )] 
public class ThisClass<br />
{ 
} You create an attribute by defining a new class that inherits from the Attribute base
class.
C#
With the preceding code, you can use [MySpecial] (or [MySpecialAttribute]) as an
attribute elsewhere in the code base.
C#
Attributes in the .NET base class library like ObsoleteAttribute trigger certain behaviors
within the compiler. However, any attribute you create acts only as metadata, and
doesn't result in any code within the attribute class being executed. It's up to you to act
on that metadata elsewhere in your code.
There's a 'gotcha' here to watch out for. As mentioned earlier, only certain types can be
passed as arguments when using attributes. However, when creating an attribute type,
the C# compiler doesn't stop you from creating those parameters. In the following
example, you've created an attribute with a constructor that compiles correctly.
C#
However, you're unable to use this constructor with attribute syntax.
C#Create your own attribute
public class MySpecialAttribute  : Attribute<br />
{ 
} 
[MySpecial ] 
public class SomeOtherClass<br />
{ 
} 
public class GotchaAttribute  : Attribute<br />
{ 
public GotchaAttribute (Foo myClass, string str) 
{ 
} 
} The preceding code causes a compiler error like Attribute constructor parameter
'myClass' has type 'Foo', which is not a valid attribute parameter type
Attributes can be used on the following &quot;targets&quot;. The preceding examples show them
on classes, but they can also be used on:
Assembly
Class
Constructor
Delegate
Enum
Event
Field
GenericP arameter
Interface
Method
Module
Parameter
Property
ReturnV alue
Struct
When you create an attribute class, by default, C# allows you to use that attribute on
any of the possible attribute targets. If you want to restrict your attribute to certain
targets, you can do so by using the AttributeUsageAttribute on your attribute class.
That's right, an attribute on an attribute!
C#[Gotcha(new Foo(), &quot;test&quot;)] // does not compile<br />
public class AttributeFail<br />
{ 
} 
How to restrict attribute usage
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct) ]
public class MyAttributeForClassAndStructOnly  : Attribute<br />
{ 
} If you attempt to put the above attribute on something that's not a class or a struct, you
get a compiler error like Attribute 'MyAttributeForClassAndStructOnly' is not valid
on this declaration type. It is only valid on 'class, struct' declarations
C#
Attributes act as metadata. Without some outward force, they don't actually do
anything.
To find and act on attributes, reflection is needed. R eflection allows you to write code in
C# that examines other code. For instance, you can use R eflection to get information
about a class(add using System.Reflection; at the head of your code):
C#
That prints something like: The assembly qualified name of MyClass is
ConsoleApplication.MyClass, attributes, Version=1.0.0.0, Culture=neutral,
PublicKeyToken=null
Once you have a TypeInfo object (or a MemberInfo, FieldInfo, or other object), you can
use the GetCustomAttributes method. This method returns a collection of Attribute
objects. Y ou can also use GetCustomAttribute and specify an Attribute type.
Here's an example of using GetCustomAttributes on a MemberInfo instance for MyClass
(which we saw earlier has an [Obsolete] attribute on it).
C#public class Foo 
{ 
// if the below attribute was uncommented, it would cause a compiler<br />
error 
// [MyAttributeForClassAndStructOnly]<br />
public Foo() 
{ } 
} 
How to use attributes attached to a code
element
TypeInfo typeInfo = typeof(MyClass).GetTypeInfo();<br />
Console.WriteLine( &quot;The assembly qualified name of MyClass is &quot;  + 
typeInfo.AssemblyQualifiedName);  That prints to console: Attribute on MyClass: ObsoleteAttribute. Try adding other
attributes to MyClass.
It's important to note that these Attribute objects are instantiated lazily. That is, they
aren't be instantiated until you use GetCustomAttribute or GetCustomAttributes. They're
also instantiated each time. Calling GetCustomAttributes twice in a row returns two
different instances of ObsoleteAttribute.
Attributes are used by many tools and frameworks. NUnit uses attributes like [Test]
and [TestFixture] that are used by the NUnit test runner. ASP.NET MV C uses attributes
like [Authorize] and provides an action filter framework to perform cross-cutting
concerns on MV C actions. PostSharp  uses the attribute syntax to allow aspect-
oriented programming in C#.
Here are a few notable attributes built into the .NET Core base class libraries:
[Obsolete]. This one was used in the above examples, and it lives in the System
namespace. It's useful to provide declarative documentation about a changing
code base. A message can be provided in the form of a string, and another
boolean parameter can be used to escalate from a compiler warning to a compiler
error.
[Conditional]. This attribute is in the System.Diagnostics namespace. This
attribute can be applied to methods (or attribute classes). Y ou must pass a string to
the constructor. If that string doesn't match a #define directive, then the C#
compiler removes any calls to that method (but not the method itself). T ypically
you use this technique for debugging (diagnostics) purposes.
[CallerMemberName]. This attribute can be used on parameters, and lives in the
System.Runtime.CompilerServices namespace. CallerMemberName is an attribute
that is used to inject the name of the method that is calling another method. It's a
way to eliminate 'magic strings' when implementing INotifyPropertyChanged in
various UI frameworks. As an example:
C#var attrs = typeInfo.GetCustomAttributes();<br />
foreach(var attr in attrs) 
Console.WriteLine( &quot;Attribute on MyClass: &quot;  + attr.GetType().Name);<br />
Common attributes in the runtim e
In the above code, you don't have to have a literal &quot;Name&quot; string. Using
CallerMemberName prevents typo-related bugs and also makes for smoother
refactoring/renaming. Attributes bring declarative power to C#, but they're a meta-data
form of code and don't act by themselves.public class MyUIClass  : INotifyPropertyChanged<br />
{ 
public event PropertyChangedEventHandler? PropertyChanged;<br />
public void RaisePropertyChanged ([CallerMemberName] string propertyName<br />
= default!) 
{ 
PropertyChanged?.Invoke( this, new 
PropertyChangedEventArgs(propertyName));<br />
} 
private string? _name;<br />
public string? Name 
{ 
get { return _name;}<br />
set 
{<br />
if (value != _name)<br />
{<br />
_name = value; 
RaisePropertyChanged();   // notice that &quot;Name&quot; is not<br />
needed here explicitly<br />
}<br />
}<br />
} 
} Tutorial: Update interfaces with default
interface metho ds
Article •03/18/2023
You can define an implementation when you declare a member of an interface. The
most common scenario is to safely add members to an interface already released and
used by innumerable clients.
In this tutorial, you'll learn how to:
You need to set up your machine to run .NET, including the C# compiler. The C#
compiler is available with Visual S tudio 2022  or the .NET SDK .
This tutorial starts with version 1 of a customer relationship library. Y ou can get the
starter application on our samples repo on GitHub . The company that built this library
intended customers with existing applications to adopt their library. They provided
minimal interface definitions for users of their library to implement. Here's the interface
definition for a customer:
C#
They defined a second interface that represents an order:Extend interfaces safely by adding methods with implementations.＂
Create parameterized implementations to provide greater flexibility.＂
Enable implementers to provide a more specific implementation in the form of an
override.＂
Prerequisites
Scenario overview
public interface  ICustomer
{
IEnumerable<IOrder> PreviousOrders { get; }
DateTime DateJoined { get; }
DateTime? LastOrder { get; }
string Name { get; }
IDictionary&lt;DateTime, string&gt; Reminders { get; }
}C#
From those interfaces, the team could build a library for their users to create a better
experience for their customers. Their goal was to create a deeper relationship with
existing customers and improve their relationships with new customers.
Now, it's time to upgrade the library for the next release. One of the requested features
enables a loyalty discount for customers that have lots of orders. This new loyalty
discount gets applied whenever a customer makes an order. The specific discount is a
property of each individual customer. Each implementation of ICustomer can set
different rules for the loyalty discount.
The most natural way to add this functionality is to enhance the ICustomer interface
with a method to apply any loyalty discount. This design suggestion caused concern
among experienced developers: &quot;Interfaces are immutable once they've been released!
Don't make a breaking change!&quot; Y ou should use default interface implementations for
upgrading interfaces. The library authors can add new members to the interface and
provide a default implementation for those members.
Default interface implementations enable developers to upgrade an interface while still
enabling any implementors to override that implementation. Users of the library can
accept the default implementation as a non-breaking change. If their business rules are
different, they can override.
The team agreed on the most likely default implementation: a loyalty discount for
customers.
The upgrade should provide the functionality to set two properties: the number of
orders needed to be eligible for the discount, and the percentage of the discount. These
features make it a perfect scenario for default interface methods. Y ou can add a method
to the ICustomer interface, and provide the most likely implementation. All existing, and
any new implementations can use the default implementation, or provide their own.
First, add the new method to the interface, including the body of the method:public interface  IOrder
{
DateTime Purchased { get; }
decimal Cost { get; }
}
Upgrade with default interface methodsC#
The library author wrote a first test to check the implementation:
C#
Notice the following portion of the test:
C#
That cast from SampleCustomer to ICustomer is necessary. The SampleCustomer class
doesn't need to provide an implementation for ComputeLoyaltyDiscount; that's provided// Version 1:
public decimal ComputeLoyaltyDiscount ()
{
DateTime TwoYearsAgo = DateTime.Now.AddYears( -2);
if ((DateJoined &lt; TwoYearsAgo) &amp;&amp; (PreviousOrders.Count() &gt; 10))
{
return 0.10m;
}
return 0;
}
SampleCustomer c = new SampleCustomer( &quot;customer one&quot; , new DateTime( 2010, 5, 
31))
{
Reminders =
{
{ new DateTime( 2010, 08, 12), &quot;childs's birthday&quot;  },
{ new DateTime( 1012, 11, 15), &quot;anniversary&quot;  }
}
};
SampleOrder o = new SampleOrder( new DateTime( 2012, 6, 1), 5m);
c.AddOrder(o);
o = new SampleOrder( new DateTime( 2103, 7, 4), 25m);
c.AddOrder(o);
// Check the discount:
ICustomer theCustomer = c;
Console.WriteLine( $&quot;Current discount: 
{theCustomer.ComputeLoyaltyDiscount()} &quot;);
// Check the discount:
ICustomer theCustomer = c;
Console.WriteLine( $&quot;Current discount: 
{theCustomer.ComputeLoyaltyDiscount()} &quot;);by the ICustomer interface. However, the SampleCustomer class doesn't inherit members
from its interfaces. That rule hasn't changed. In order to call any method declared and
implemented in the interface, the variable must be the type of the interface, ICustomer
in this example.
The default implementation is too restrictive. Many consumers of this system may
choose different thresholds for number of purchases, a different length of membership,
or a different percentage discount. Y ou can provide a better upgrade experience for
more customers by providing a way to set those parameters. Let's add a static method
that sets those three parameters controlling the default implementation:
C#
There are many new language capabilities shown in that small code fragment. Interfaces
can now include static members, including fields and methods. Different access
modifiers are also enabled. The other fields are private, the new method is public. Any of
the modifiers are allowed on interface members.
Applications that use the general formula for computing the loyalty discount, but
different parameters, don't need to provide a custom implementation; they can set theProvide parameterization
// Version 2:
public static void SetLoyaltyThresholds (
TimeSpan ago,
int minimumOrders = 10,
decimal percentageDiscount = 0.10m)
{
length = ago;
orderCount = minimumOrders;
discountPercent = percentageDiscount;
}
private static TimeSpan length = new TimeSpan( 365 * 2, 0,0,0); // two years
private static int orderCount = 10;
private static decimal discountPercent = 0.10m;
public decimal ComputeLoyaltyDiscount ()
{
DateTime start = DateTime.Now - length;
if ((DateJoined &lt; start) &amp;&amp; (PreviousOrders.Count() &gt; orderCount))
{
return discountPercent;
}
return 0;
}arguments through a static method. For example, the following code sets a &quot;customer
appreciation&quot; that rewards any customer with more than one month's membership:
C#
The code you've added so far has provided a convenient implementation for those
scenarios where users want something like the default implementation, or to provide an
unrelated set of rules. For a final feature, let's refactor the code a bit to enable scenarios
where users may want to build on the default implementation.
Consider a startup that wants to attract new customers. They offer a 50% discount off a
new customer's first order. Otherwise, existing customers get the standard discount. The
library author needs to move the default implementation into a protected static
method so that any class implementing this interface can reuse the code in their
implementation. The default implementation of the interface member calls this shared
method as well:
C#
In an implementation of a class that implements this interface, the override can call the
static helper method, and extend that logic to provide the &quot;new customer&quot; discount:
C#ICustomer.SetLoyaltyThresholds( new TimeSpan( 30, 0, 0, 0), 1, 0.25m);
Console.WriteLine( $&quot;Current discount: 
{theCustomer.ComputeLoyaltyDiscount()} &quot;);
Extend the default implementation
public decimal ComputeLoyaltyDiscount () =&gt; DefaultLoyaltyDiscount( this);
protected  static decimal DefaultLoyaltyDiscount (ICustomer c )
{
DateTime start = DateTime.Now - length;
if ((c.DateJoined &lt; start) &amp;&amp; (c.PreviousOrders.Count() &gt; orderCount))
{
return discountPercent;
}
return 0;
}
public decimal ComputeLoyaltyDiscount ()
{
if (PreviousOrders.Any() == false)You can see the entire finished code in our samples repo on GitHub . You can get the
starter application on our samples repo on GitHub .
These new features mean that interfaces can be updated safely when there's a
reasonable default implementation for those new members. Carefully design interfaces
to express single functional ideas implemented by multiple classes. That makes it easier
to upgrade those interface definitions when new requirements are discovered for that
same functional idea.        return 0.50m;
else
return ICustomer.DefaultLoyaltyDiscount( this);
}
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide ..NET feedb ack
The .NET documentation is open
source. Provide feedback here.
 Open a documentation issue
 Provide product feedbackTutorial: Mix functionality in when
creating classes using interfaces with
default interface methods
Article •03/18/2023
You can define an implementation when you declare a member of an interface. This
feature provides new capabilities where you can define default implementations for
features declared in interfaces. Classes can pick when to override functionality, when to
use the default functionality, and when not to declare support for discrete features.
In this tutorial, you'll learn how to:
You need to set up your machine to run .NET, including the C# compiler. The C#
compiler is available with Visual S tudio 2022 , or the .NET SDK .
One way you can implement behavior that appears as part of an interface is to define
extension methods  that provide the default behavior. Interfaces declare a minimum set
of members while providing a greater surface area for any class that implements that
interface. For example, the extension methods in Enumerable  provide the
implementation for any sequence to be the source of a LINQ query.
Extension methods are resolved at compile time, using the declared type of the variable.
Classes that implement the interface can provide a better implementation for any
extension method. V ariable declarations must match the implementing type to enable
the compiler to choose that implementation. When the compile-time type matches the
interface, method calls resolve to the extension method. Another concern with extension
methods is that those methods are accessible wherever the class containing the
extension methods is accessible. Classes can't declare if they should or shouldn't provide
features declared in extension methods.Create interfaces with implementations that describe discrete features. ＂
Create classes that use the default implementations. ＂
Create classes that override some or all of the default implementations. ＂
Prerequisites
Limitations of extension methodsYou can declare the default implementations as interface methods. Then, every class
automatically uses the default implementation. Any class that can provide a better
implementation can override the interface method definition with a better algorithm. In
one sense, this technique sounds similar to how you could use extension methods .
In this article, you'll learn how default interface implementations enable new scenarios.
Consider a home automation application. Y ou probably have many different types of
lights and indicators that could be used throughout the house. Every light must support
APIs to turn them on and off, and to report the current state. Some lights and indicators
may support other features, such as:
Turn light on, then turn it off after a timer.
Blink the light for a period of time.
Some of these extended capabilities could be emulated in devices that support the
minimal set. That indicates providing a default implementation. For those devices that
have more capabilities built in, the device software would use the native capabilities. For
other lights, they could choose to implement the interface and use the default
implementation.
Default interface members provide a better solution for this scenario than extension
methods. Class authors can control which interfaces they choose to implement. Those
interfaces they choose are available as methods. In addition, because default interface
methods are virtual by default, the method dispatch always chooses the implementation
in the class.
Let's create the code to demonstrate these differences.
Start by creating the interface that defines the behavior for all lights:
C#Design the application
Create interfaces
public interface  ILight 
{ 
void SwitchOn (); 
void SwitchOff (); 
bool IsOn(); 
} A basic overhead light fixture might implement this interface as shown in the following
code:
C#
In this tutorial, the code doesn't drive IoT devices, but emulates those activities by
writing messages to the console. Y ou can explore the code without automating your
house.
Next, let's define the interface for a light that can automatically turn off after a timeout:
C#
You could add a basic implementation to the overhead light, but a better solution is to
modify this interface definition to provide a virtual default implementation:
C#public class OverheadLight  : ILight 
{ 
private bool isOn; 
public bool IsOn() =&gt; isOn;<br />
public void SwitchOff () =&gt; isOn = false; 
public void SwitchOn () =&gt; isOn = true; 
public override  string ToString () =&gt; $&quot;The light is {(isOn ? &quot;on&quot; : 
&quot;off&quot;)}&quot;; 
} 
public interface  ITimerLight  : ILight 
{ 
Task TurnOnFor (int duration ); 
} 
public interface  ITimerLight  : ILight 
{ 
public async Task TurnOnFor (int duration ) 
{ 
Console.WriteLine( &quot;Using the default interface method for the<br />
ITimerLight.TurnOnFor.&quot; ); 
SwitchOn();<br />
await Task.Delay(duration);<br />
SwitchOff();<br />
Console.WriteLine( &quot;Completed ITimerLight.TurnOnFor sequence.&quot; ); 
} 
} The OverheadLight class can implement the timer function by declaring support for the
interface:
C#
A different light type may support a more sophisticated protocol. It can provide its own
implementation for TurnOnFor, as shown in the following code:
C#
Unlike overriding virtual class methods, the declaration of TurnOnFor in the
HalogenLight class doesn't use the override keyword.
The advantages of default interface methods become clearer as you introduce more
advanced capabilities. Using interfaces enables you to mix and match capabilities. It also
enables each class author to choose between the default implementation and a custom
implementation. Let's add an interface with a default implementation for a blinking light:public class OverheadLight  : ITimerLight  { } 
public class HalogenLight  : ITimerLight<br />
{ 
private enum HalogenLightState<br />
{ 
Off,<br />
On,<br />
TimerModeOn<br />
} 
private HalogenLightState state;<br />
public void SwitchOn () =&gt; state = HalogenLightState.On;<br />
public void SwitchOff () =&gt; state = HalogenLightState.Off;<br />
public bool IsOn() =&gt; state != HalogenLightState.Off;<br />
public async Task TurnOnFor (int duration ) 
{ 
Console.WriteLine( &quot;Halogen light starting timer function.&quot; ); 
state = HalogenLightState.TimerModeOn;<br />
await Task.Delay(duration);<br />
state = HalogenLightState.Off;<br />
Console.WriteLine( &quot;Halogen light finished custom timer function&quot; ); 
} 
public override  string ToString () =&gt; $&quot;The light is {state}&quot;; 
} 
Mix and match capabilitiesC#
The default implementation enables any light to blink. The overhead light can add both
timer and blink capabilities using the default implementation:
C#
A new light type, the LEDLight supports both the timer function and the blink function
directly. This light style implements both the ITimerLight and IBlinkingLight
interfaces, and overrides the Blink method:
C#public interface  IBlinkingLight  : ILight 
{ 
public async Task Blink(int duration, int repeatCount ) 
{ 
Console.WriteLine( &quot;Using the default interface method for<br />
IBlinkingLight.Blink.&quot; ); 
for (int count = 0; count &lt; repeatCount; count++)<br />
{<br />
SwitchOn();<br />
await Task.Delay(duration);<br />
SwitchOff();<br />
await Task.Delay(duration);<br />
}<br />
Console.WriteLine( &quot;Done with the default interface method for<br />
IBlinkingLight.Blink.&quot; ); 
} 
} 
public class OverheadLight  : ILight, ITimerLight , IBlinkingLight<br />
{ 
private bool isOn; 
public bool IsOn() =&gt; isOn;<br />
public void SwitchOff () =&gt; isOn = false; 
public void SwitchOn () =&gt; isOn = true; 
public override  string ToString () =&gt; $&quot;The light is {(isOn ? &quot;on&quot; : 
&quot;off&quot;)}&quot;; 
} 
public class LEDLight  : IBlinkingLight , ITimerLight , ILight 
{ 
private bool isOn; 
public void SwitchOn () =&gt; isOn = true; 
public void SwitchOff () =&gt; isOn = false; 
public bool IsOn() =&gt; isOn;<br />
public async Task Blink(int duration, int repeatCount ) 
{ An ExtraFancyLight might support both blink and timer functions directly:
C#
The HalogenLight you created earlier doesn't support blinking. So, don't add the
IBlinkingLight to the list of its supported interfaces.
Next, let's write some test code. Y ou can make use of C#'s pattern matching  feature to
determine a light's capabilities by examining which interfaces it supports. The following
method exercises the supported capabilities of each light:
C#        Console.WriteLine( &quot;LED Light starting the Blink function.&quot; ); 
await Task.Delay(duration * repeatCount);<br />
Console.WriteLine( &quot;LED Light has finished the Blink function.&quot; ); 
} 
public override  string ToString () =&gt; $&quot;The light is {(isOn ? &quot;on&quot; : 
&quot;off&quot;)}&quot;; 
} 
public class ExtraFancyLight  : IBlinkingLight , ITimerLight , ILight 
{ 
private bool isOn; 
public void SwitchOn () =&gt; isOn = true; 
public void SwitchOff () =&gt; isOn = false; 
public bool IsOn() =&gt; isOn;<br />
public async Task Blink(int duration, int repeatCount ) 
{ 
Console.WriteLine( &quot;Extra Fancy Light starting the Blink function.&quot; ); 
await Task.Delay(duration * repeatCount);<br />
Console.WriteLine( &quot;Extra Fancy Light has finished the Blink<br />
function.&quot; ); 
} 
public async Task TurnOnFor (int duration ) 
{ 
Console.WriteLine( &quot;Extra Fancy light starting timer function.&quot; ); 
await Task.Delay(duration);<br />
Console.WriteLine( &quot;Extra Fancy light finished custom timer<br />
function&quot; ); 
} 
public override  string ToString () =&gt; $&quot;The light is {(isOn ? &quot;on&quot; : 
&quot;off&quot;)}&quot;; 
} 
Detect the light types using pattern matchingThe following code in your Main method creates each light type in sequence and tests
that light:
C#private static async Task TestLightCapabilities (ILight light ) 
{ 
// Perform basic tests:<br />
light.SwitchOn();<br />
Console.WriteLine( $&quot;\tAfter switching on, the light is {(light.IsOn() ?<br />
&quot;on&quot; : &quot;off&quot;)}&quot;); 
light.SwitchOff();<br />
Console.WriteLine( $&quot;\tAfter switching off, the light is {(light.IsOn() ?<br />
&quot;on&quot; : &quot;off&quot;)}&quot;); 
if (light is ITimerLight timer)<br />
{ 
Console.WriteLine( &quot;\tTesting timer function&quot; ); 
await timer.TurnOnFor( 1000); 
Console.WriteLine( &quot;\tTimer function completed&quot; ); 
} 
else 
{ 
Console.WriteLine( &quot;\tTimer function not supported.&quot; ); 
} 
if (light is IBlinkingLight blinker)<br />
{ 
Console.WriteLine( &quot;\tTesting blinking function&quot; ); 
await blinker.Blink( 500, 5); 
Console.WriteLine( &quot;\tBlink function completed&quot; ); 
} 
else 
{ 
Console.WriteLine( &quot;\tBlink function not supported.&quot; ); 
} 
} 
static async Task Main(string[] args) 
{ 
Console.WriteLine( &quot;Testing the overhead light&quot; ); 
var overhead = new OverheadLight();<br />
await TestLightCapabilities(overhead);<br />
Console.WriteLine();<br />
Console.WriteLine( &quot;Testing the halogen light&quot; ); 
var halogen = new HalogenLight();<br />
await TestLightCapabilities(halogen);<br />
Console.WriteLine();<br />
Console.WriteLine( &quot;Testing the LED light&quot; ); 
var led = new LEDLight();<br />
await TestLightCapabilities(led);  This scenario shows a base interface without any implementations. Adding a method
into the ILight interface introduces new complexities. The language rules governing
default interface methods minimize the effect on the concrete classes that implement
multiple derived interfaces. Let's enhance the original interface with a new method to
show how that changes its use. Every indicator light can report its power status as an
enumerated value:
C#
The default implementation assumes no power:
C#
These changes compile cleanly, even though the ExtraFancyLight declares support for
the ILight interface and both derived interfaces, ITimerLight and IBlinkingLight.
There's only one &quot;closest&quot; implementation declared in the ILight interface. Any class
that declared an override would become the one &quot;closest&quot; implementation. Y ou saw    Console.WriteLine();<br />
Console.WriteLine( &quot;Testing the fancy light&quot; ); 
var fancy = new ExtraFancyLight();<br />
await TestLightCapabilities(fancy);<br />
Console.WriteLine();<br />
} 
How the compiler determines best
implementation
public enum PowerStatus
{ 
NoPower,<br />
ACPower,<br />
FullBattery,<br />
MidBattery,<br />
LowBattery<br />
} 
public interface  ILight 
{ 
void SwitchOn (); 
void SwitchOff (); 
bool IsOn(); 
public PowerStatus Power() =&gt; PowerStatus.NoPower;<br />
} examples in the preceding classes that overrode the members of other derived
interfaces.
Avoid overriding the same method in multiple derived interfaces. Doing so creates an
ambiguous method call whenever a class implements both derived interfaces. The
compiler can't pick a single better method so it issues an error. For example, if both the
IBlinkingLight and ITimerLight implemented an override of PowerStatus, the
OverheadLight would need to provide a more specific override. Otherwise, the compiler
can't pick between the implementations in the two derived interfaces. Y ou can usually
avoid this situation by keeping interface definitions small and focused on one feature. In
this scenario, each capability of a light is its own interface; only classes inherit multiple
interfaces.
This sample shows one scenario where you can define discrete features that can be
mixed into classes. Y ou declare any set of supported functionality by declaring which
interfaces a class supports. The use of virtual default interface methods enables classes
to use or define a different implementation for any or all the interface methods. This
language capability provides new ways to model the real-world systems you're building.
Default interface methods provide a clearer way to express related classes that may mix
and match different features using virtual implementations of those capabilities.Expression Trees
Article •03/09/2023
Expression tr ees represent code in a tree-like data structure, where each node is an
expression, for example, a method call or a binary operation such as x &lt; y.
If you have used LINQ, you have experience with a rich library where the Func types are
part of the API set. (If you aren't familiar with LINQ, you probably want to read the LINQ
tutorial  and the article about lambda expressions  before this one.) Expression T rees
provide richer interaction with the arguments that are functions.
You write function arguments, typically using Lambda Expressions, when you create
LINQ queries. In a typical LINQ query, those function arguments are transformed into a
delegate the compiler creates.
You've likely already written code that uses Expression trees. Entity Framework's LINQ
APIs accept Expression trees as the arguments for the LINQ Query Expression P attern.
That enables Entity Framework  to translate the query you wrote in C# into SQL that
executes in the database engine. Another example is Moq , which is a popular
mocking framework for .NET.
When you want to have a richer interaction, you need to use Expression T rees. Expression
Trees represent code as a structure that you examine, modify, or execute. These tools
give you the power to manipulate code during run time. Y ou write code that examines
running algorithms, or injects new capabilities. In more advanced scenarios, you modify
running algorithms and even translate C# expressions into another form for execution in
another environment.
You compile and run code represented by expression trees. Building and running
expression trees enables dynamic modification of executable code, the execution of
LINQ queries in various databases, and the creation of dynamic queries. For more
information about expression trees in LINQ, see How to use expression trees to build
dynamic queries .
Expression trees are also used in the dynamic language runtime (DLR) to provide
interoperability between dynamic languages and .NET and to enable compiler writers to
emit expression trees instead of Microsoft intermediate language (MSIL). For more
information about the DLR, see Dynamic Language Runtime Overview .
You can have the C# or Visual Basic compiler create an expression tree for you based on
an anonymous lambda expression, or you can create expression trees manually by using
the System.Linq.Expressions  namespace.
When a lambda expression is assigned to a variable of type Expression<TDelegate> , the
compiler emits code to build an expression tree that represents the lambda expression.
The C# compiler generates expression trees only from expression lambdas (or single-
line lambdas). It can't parse statement lambdas (or multi-line lambdas). For more
information about lambda expressions in C#, see Lambda Expressions .
The following code examples demonstrate how to have the C# compiler create an
expression tree that represents the lambda expression num =&gt; num &lt; 5.
C#
You create expression trees in your code. Y ou build the tree by creating each node and
attaching the nodes into a tree structure. Y ou learn how to create expressions in the
article on building expression trees .
Expression trees are immutable. If you want to modify an expression tree, you must
construct a new expression tree by copying the existing one and replacing nodes in it.
You use an expression tree visitor to traverse the existing expression tree. For more
information, see the article on translating expression trees .
Once you build an expression tree, you execute the code represented by the expression
tree.
There are some newer C# language elements that don't translate well into expression
trees. Expression trees can't contain await expressions, or async lambda expressions.
Many of the features added in C# 6 and later don't appear exactly as written in
expression trees. Instead, newer features are exposed in expression trees in the
equivalent, earlier syntax, where possible. Other constructs aren't available. It means that
code that interprets expression trees works the same when new language features are
introduced. However, even with these limitations, expression trees do enable you to
create dynamic algorithms that rely on interpreting and modifying code that is
represented as a data structure. It enables rich libraries such as Entity Framework to
accomplish what they do.
Expression trees won't support new expression node types. It would be a breaking
change for all libraries interpreting expression trees to introduce new node types. The
following list includes most C# language elements that can't be used:Expression&lt;Func&lt; int, bool&gt;&gt; lambda = num =&gt; num &lt; 5;
LimitationsConditional methods  that have been removed
base access
Method group expressions, including address-o f (&amp;) a method group, and
anonymous method expressions
References to local functions
Statements, including assignment ( =) and statement bodied expressions
Partial methods  with only a defining declaration
Unsafe pointer operations
dynamic  operations
Coalescing operators with null or default  literal left side, null coalescing
assignment , and the null propagating operator ( ?.)
Multi-dimensional array initializers , indexed properties, and dictionary initializers
throw  expressions
Accessing static virtual  or abstract  interface members
Lambda expressions that have attributes
Interpolated strings
UTF-8 string conversions or UTF-8 string literals
Method invocations using variable arguments , named arguments or optional
arguments
Expressions using System.Index  or System.Range , index &quot;from end&quot; ( ^) operator  or
range expressions ( ..)
async  lambda expressions or await  expressions , including await foreach  and await
using
Tuple literals, tuple conversions, tuple == or !=, or with expressions
Discards ( _), deconstructing assignment , pattern matching is operator or the
pattern matching switch  expression
COM call with ref omitted on the arguments
ref, in or out parameters, ref return values, out arguments, or any values of ref
struct  type
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide ..NET feedb ack
The .NET documentation is open
source. Provide feedback here.
 Open a documentation issue
 Provide product feedbackExpression trees - data that defines
code
Article •03/09/2023
An Expression T ree is a data structure that defines code. Expression trees are based on
the same structures that a compiler uses to analyze code and generate the compiled
output. As you read this article, you notice quite a bit of similarity between Expression
Trees and the types used in the R oslyn APIs to build Analyzers and CodeFixes .
(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and
suggest potential fixes for a developer.) The concepts are similar, and the end result is a
data structure that allows examination of the source code in a meaningful way.
However, Expression T rees are based on a different set of classes and APIs than the
Roslyn APIs. Here's a line of code:
C#
If you analyze the preceding code as an expression tree, the tree contains several nodes.
The outermost node is a variable declaration statement with assignment ( var sum = 1 +
2;) That outermost node contains several child nodes: a variable declaration, an
assignment operator, and an expression representing the right hand side of the equals
sign. That expression is further subdivided into expressions that represent the addition
operation, and left and right operands of the addition.
Let's drill down a bit more into the expressions that make up the right side of the equals
sign. The expression is 1 + 2, a binary expression. More specifically, it's a binary
addition expression. A binary addition expression has two children, representing the left
and right nodes of the addition expression. Here, both nodes are constant expressions:
The left operand is the value 1, and the right operand is the value 2.
Visually, the entire statement is a tree: Y ou could start at the root node, and travel to
each node in the tree to see the code that makes up the statement:
Variable declaration statement with assignment ( var sum = 1 + 2;)
Implicit variable type declaration ( var sum)
Implicit var keyword ( var)
Variable name declaration ( sum)
Assignment operator ( =)
Binary addition expression ( 1 + 2)
var sum = 1 + 2;Left operand ( 1)
Addition operator ( +)
Right operand ( 2)
The preceding tree may look complicated, but it's very powerful. Following the same
process, you decompose much more complicated expressions. Consider this expression:
C#
The preceding expression is also a variable declaration with an assignment. In this
instance, the right hand side of the assignment is a much more complicated tree. Y ou're
not going to decompose this expression, but consider what the different nodes might
be. There are method calls using the current object as a receiver, one that has an explicit
this receiver, one that doesn't. There are method calls using other receiver objects,
there are constant arguments of different types. And finally, there's a binary addition
operator. Depending on the return type of SecretSauceFunction() or
MoreSecretSauce(), that binary addition operator may be a method call to an overridden
addition operator, resolving to a static method call to the binary addition operator
defined for a class.
Despite this perceived complexity, the preceding expression creates a tree structure
navigated as easily as the first sample. Y ou keep traversing child nodes to find leaf
nodes in the expression. P arent nodes have references to their children, and each node
has a property that describes what kind of node it is.
The structure of an expression tree is very consistent. Once you've learned the basics,
you understand even the most complex code when it's represented as an expression
tree. The elegance in the data structure explains how the C# compiler analyzes the most
complex C# programs and creates proper output from that complicated source code.
Once you become familiar with the structure of expression trees, you find that
knowledge you've gained quickly enables you to work with many more advanced
scenarios. There's incredible power to expression trees.
In addition to translating algorithms to execute in other environments, expression trees
make it easier to write algorithms that inspect code before executing it. Y ou write a
method whose arguments are expressions and then examine those expressions beforevar finalAnswer = this.SecretSauceFunction(
currentState.createInterimResult(), currentState.createSecondValue( 1, 
2),
decisionServer.considerFinalOptions( &quot;hello&quot;)) +
MoreSecretSauce( 'A', DateTime.Now, true);executing the code. The Expression T ree is a full representation of the code: you see
values of any subexpression. Y ou see method and property names. Y ou see the value of
any constant expressions. Y ou convert an expression tree into an executable delegate,
and execute the code.
The APIs for Expression T rees enable you to create trees that represent almost any valid
code construct. However, to keep things as simple as possible, some C# idioms can't be
created in an expression tree. One example is asynchronous expressions (using the
async and await keywords). If your needs require asynchronous algorithms, you would
need to manipulate the Task objects directly, rather than rely on the compiler support.
Another is in creating loops. T ypically, you create these loops by using for, foreach,
while or do loops. As you see later in this series , the APIs for expression trees support a
single loop expression, with break and continue expressions that control repeating the
loop.
The one thing you can't do is modify an expression tree. Expression T rees are immutable
data structures. If you want to mutate (change) an expression tree, you must create a
new tree that is a copy of the original, but with your desired changes..NET Runtime s upport for expression
trees
Article •03/09/2023
There's a large list of classes in the .NET runtime that work with Expression T rees. Y ou
can see the full list at System.Linq.Expressions . Rather than enumerate the full list, let's
understand how the runtime classes have been designed.
In language design, an expression is a body of code that evaluates and returns a value.
Expressions may be simple: the constant expression 1 returns the constant value of 1.
They may be more complicated: The expression (-B + Math.Sqrt(B*B - 4 * A * C)) /
(2 * A) returns one root for a quadratic equation (in the case where the equation has a
solution).
One of the complexities of working with expression trees is that many different kinds of
expressions are valid in many places in programs. Consider an assignment expression.
The right hand side of an assignment could be a constant value, a variable, a method
call expression, or others. That language flexibility means that you may encounter many
different expression types anywhere in the nodes of a tree when you traverse an
expression tree. Therefore, when you work with the base expression type, that's the
simplest way to work. However, sometimes you need to know more. The base
Expression class contains a NodeType property for this purpose. It returns an
ExpressionType, which is an enumeration of possible expression types. Once you know
the type of the node, you cast it to that type, and perform specific actions knowing the
type of the expression node. Y ou can search for certain node types, and then work with
the specific properties of that kind of expression.
For example, this code prints the name of a variable for a variable access expression. The
following code shows the practice of checking the node type, then casting to a variable
access expression and then checking the properties of the specific expression type:
C#System.Linq.Expression and derived types
Expression&lt;Func&lt; int, int&gt;&gt; addFive = (num) =&gt; num + 5; 
if (addFive is LambdaExpression lambdaExp)<br />
{ 
var parameter = lambdaExp.Parameters[ 0];  -- first  The System.Linq.Expression class also contains many static methods to create
expressions. These methods create an expression node using the arguments supplied
for its children. In this way, you build up an expression from its leaf nodes. For example,
this code builds an Add expression:
C#
You can see from this simple example that many types are involved in creating and
working with expression trees. That complexity is necessary to provide the capabilities of
the rich vocabulary provided by the C# language.
There are Expression node types that map to almost all of the syntax elements of the C#
language. Each type has specific methods for that type of language element. It's a lot to
keep in your head at one time. Rather than try to memorize everything, here are the
techniques you use to work with Expression trees:</p>
<ol>
<li>Look at the members of the ExpressionType enum to determine possible nodes
you should be examining. This list helps when you want to traverse and
understand an expression tree.</li>
<li>Look at the static members of the Expression class to build an expression. Those
methods can build any expression type from a set of its child nodes.</li>
<li>Look at the ExpressionVisitor class to build a modified expression tree.
You find more as you look at each of those three areas. Invariably, you find what you
need when you start with one of those three steps.    Console.WriteLine(parameter.Name);<br />
Console.WriteLine(parameter.Type);<br />
} 
Create expression trees
// Addition is an add expression for &quot;1 + 2&quot;<br />
var one = Expression.Constant( 1, typeof(int)); 
var two = Expression.Constant( 2, typeof(int)); 
var addition = Expression.Add(one, two);<br />
Navigate the APIsExecute exp ression trees
Article •03/09/2023
An expression tr ee is a data structure that represents some code. It isn't compiled and
executable code. If you want to execute the .NET code represented by an expression
tree, you must convert it into executable IL instructions. Executing an expression tree
may return a value, or it may just perform an action such as calling a method.
Only expression trees that represent lambda expressions can be executed. Expression
trees that represent lambda expressions are of type LambdaExpression  or
Expression<TDelegate> . To execute these expression trees, call the Compile  method to
create an executable delegate, and then invoke the delegate.
If an expression tree doesn't represent a lambda expression, you can create a new
lambda expression that has the original expression tree as its body, by calling the
Lambda<TDelegate>(Expression, IEnumerable<P arameterExpression>)  method. Then,
you can execute the lambda expression as described earlier in this section.
You can convert any LambdaExpression, or any type derived from LambdaExpression
into executable IL. Other expression types can't be directly converted into code. This
restriction has little effect in practice. Lambda expressions are the only types of
expressions that you would want to execute by converting to executable intermediate
language (IL). (Think about what it would mean to directly execute a
System.Linq.Expressions.ConstantExpression . Would it mean anything useful?) Any
expression tree that is a System.Linq.Expressions.LambdaExpression , or a type derived
from LambdaExpression can be converted to IL. The expression type
System.Linq.Expressions.Expression<TDelegate>  is the only concrete example in the
.NET Core libraries. It's used to represent an expression that maps to any delegate type.
Because this type maps to a delegate type, .NET can examine the expression, and
generate IL for an appropriate delegate that matches the signature of the lambda
expression. The delegate type is based on the expression type. Y ou must know the７ Note
If the type of the delegate is not known, that is, the lambda expression is of type
LambdaExpr ession  and not Expression<TDelegat e>, call the DynamicInv oke
method on the delegate instead of invoking it directly.
Lambda expressions to functionsreturn type and the argument list if you want to use the delegate object in a strongly
typed manner. The LambdaExpression.Compile() method returns the Delegate type. Y ou
have to cast it to the correct delegate type to have any compile-time tools check the
argument list or return type.
In most cases, a simple mapping between an expression and its corresponding delegate
exists. For example, an expression tree represented by Expression&lt;Func<int>&gt; would be
converted to a delegate of the type Func<int>. For a lambda expression with any return
type and argument list, there exists a delegate type that is the target type for the
executable code represented by that lambda expression.
The System.Linq.Expressions.LambdaExpression  type contains
LambdaExpression.Compile  and LambdaExpression.CompileT oMethod  members that
you would use to convert an expression tree to executable code. The Compile method
creates a delegate. The CompileToMethod method updates a
System.R eflection.Emit.MethodBuilder  object with the IL that represents the compiled
output of the expression tree.
Optionally, you can also provide a
System.Runtime.CompilerServices.DebugInfoGenerator  that receives the symbol
debugging information for the generated delegate object. The DebugInfoGenerator
provides full debugging information about the generated delegate.
You would convert an expression into a delegate using the following code:
C#
The following code example demonstrates the concrete types used when you compile
and execute an expression tree.
C#） Impor tant
CompileToMethod is only available in .NET Framework, not in .NET Core or .NET 5
and later.
Expression&lt;Func&lt; int&gt;&gt; add = () =&gt; 1 + 2; 
var func = add.Compile(); // Create Delegate<br />
var answer = func(); // Invoke Delegate<br />
Console.WriteLine(answer);  The following code example demonstrates how to execute an expression tree that
represents raising a number to a power by creating a lambda expression and executing
it. The result, which represents the number raised to the power, is displayed.
C#
You execute the code by invoking the delegate created when you called
LambdaExpression.Compile(). The preceding code, add.Compile(), returns a delegate.
You invoke that delegate by calling func(), which executes the code.Expression&lt;Func&lt; int, bool&gt;&gt; expr = num =&gt; num &lt; 5; 
// Compiling the expression tree into a delegate.<br />
Func&lt;int, bool&gt; result = expr.Compile();<br />
// Invoking the delegate and writing the result to the console.<br />
Console.WriteLine(result( 4)); 
// Prints True.<br />
// You can also use simplified syntax<br />
// to compile and run an expression tree.<br />
// The following line can replace two previous statements.<br />
Console.WriteLine(expr.Compile()( 4)); 
// Also prints True.<br />
// The expression tree to execute.<br />
BinaryExpression be = Expression.Power(Expression.Constant( 2d), 
Expression.Constant( 3d)); 
// Create a lambda expression.<br />
Expression&lt;Func&lt; double&gt;&gt; le = Expression.Lambda&lt;Func&lt; double&gt;&gt;(be); 
// Compile the lambda expression.
Func<double> compiledExpression = le.Compile();<br />
// Execute the lambda expression.
double result = compiledExpression();<br />
// Display the result.<br />
Console.WriteLine(result);<br />
// This code produces the following output:<br />
// 8 
Execution and lifetimesThat delegate represents the code in the expression tree. Y ou can retain the handle to
that delegate and invoke it later. Y ou don't need to compile the expression tree each
time you want to execute the code it represents. (R emember that expression trees are
immutable, and compiling the same expression tree later creates a delegate that
executes the same code.)
Compiling a lambda expression to a delegate and invoking that delegate is one of the
simplest operations you can perform with an expression tree. However, even with this
simple operation, there are caveats you must be aware of.
Lambda Expressions create closures over any local variables that are referenced in the
expression. Y ou must guarantee that any variables that would be part of the delegate
are usable at the location where you call Compile, and when you execute the resulting
delegate. The compiler ensures that variables are in scope. However, if your expression
accesses a variable that implements IDisposable, it's possible that your code might
dispose of the object while it's still held by the expression tree.
For example, this code works fine, because int doesn't implement IDisposable:
C#
The delegate has captured a reference to the local variable constant. That variable is
accessed at any time later, when the function returned by CreateBoundFunc executes.Ｕ Caution
Don't create any more sophisticated caching mechanisms to increase performance
by avoiding unnecessary compile calls. Comparing two arbitrary expression trees to
determine if they represent the same algorithm is a time consuming operation. The
compute time you save avoiding any extra calls to LambdaExpression.Compile() are
likely more than consumed by the time executing code that determines if two
different expression trees result in the same executable code.
Caveats
private static Func&lt;int, int&gt; CreateBoundFunc () 
{ 
var constant = 5; // constant is captured by the expression tree<br />
Expression&lt;Func&lt; int, int&gt;&gt; expression = (b) =&gt; constant + b;<br />
var rVal = expression.Compile();<br />
return rVal; 
} However, consider the following (rather contrived) class that implements
System.IDisposable :
C#
If you use it in an expression as shown in the following code, you get a
System.ObjectDisposedException  when you execute the code referenced by the
Resource.Argument property:
C#
The delegate returned from this method has closed over the constant object, which has
been disposed of. (It's been disposed, because it was declared in a using statement.)
Now, when you execute the delegate returned from this method, you have an
ObjectDisposedException thrown at the point of execution.public class Resource  : IDisposable<br />
{ 
private bool _isDisposed = false; 
public int Argument<br />
{ 
get 
{<br />
if (!_isDisposed)<br />
return 5; 
else throw new ObjectDisposedException( &quot;Resource&quot; ); 
}<br />
} 
public void Dispose() 
{ 
_isDisposed = true; 
} 
} 
private static Func&lt;int, int&gt; CreateBoundResource () 
{ 
using (var constant = new Resource()) // constant is captured by the<br />
expression tree<br />
{ 
Expression&lt;Func&lt; int, int&gt;&gt; expression = (b) =&gt; constant.Argument +<br />
b; 
var rVal = expression.Compile();<br />
return rVal; 
} 
} It does seem strange to have a runtime error representing a compile-time construct, but
that's the world you enter when you work with expression trees.
There are numerous permutations of this problem, so it's hard to offer general guidance
to avoid it. Be careful about accessing local variables when defining expressions, and be
careful about accessing state in the current object (represented by this) when creating
an expression tree returned via a public API.
The code in your expression may reference methods or properties in other assemblies.
That assembly must be accessible when the expression is defined, when it's compiled,
and when the resulting delegate is invoked. Y ou're met with a
ReferencedAssemblyNotFoundException in cases where it isn't present.
Expression T rees that represent lambda expressions can be compiled to create a
delegate that you can execute. Expression trees provide one mechanism to execute the
code represented by an expression tree.
The Expression T ree does represent the code that would execute for any given construct
you create. As long as the environment where you compile and execute the code
matches the environment where you create the expression, everything works as
expected. When that doesn't happen, the errors are predictable, and they're caught in
your first tests of any code using the expression trees.SummaryInterpret expressions
Article •03/09/2023
The following code example demonstrates how the expression tree that represents the
lambda expression num =&gt; num &lt; 5 can be decomposed into its parts.
C#
Now, let's write some code to examine the structure of an expression tr ee. Every node in
an expression tree is an object of a class that is derived from Expression.
That design makes visiting all the nodes in an expression tree a relatively straightforward
recursive operation. The general strategy is to start at the root node and determine what
kind of node it is.
If the node type has children, recursively visit the children. At each child node, repeat the
process used at the root node: determine the type, and if the type has children, visit
each of the children.
Let's start by visiting each node in a simple expression tree. Here's the code that creates
a constant expression and then examines its properties:
C#// Add the following using directive to your code file:<br />
// using System.Linq.Expressions;
// Create an expression tree.<br />
Expression&lt;Func&lt; int, bool&gt;&gt; exprTree = num =&gt; num &lt; 5; 
// Decompose the expression tree.
ParameterExpression param = (ParameterExpression)exprTree.Parameters[ 0]; 
BinaryExpression operation = (BinaryExpression)exprTree.Body;<br />
ParameterExpression left = (ParameterExpression)operation.Left;<br />
ConstantExpression right = (ConstantExpression)operation.Right;<br />
Console.WriteLine( &quot;Decomposed expression: {0} =&gt; {1} {2} {3}&quot; , 
param.Name, left.Name, operation.NodeType, right.Value);<br />
// This code produces the following output:<br />
// Decomposed expression: num =&gt; num LessThan 5<br />
Examine an expression with no childrenThe preceding code prints the following output:
Output
Now, let's write the code that would examine this expression and write out some
important properties about it.
Let's start with the addition sample from the introduction to this section.
C#
The root node is a LambdaExpression. In order to get the interesting code on the right-
hand side of the =&gt; operator, you need to find one of the children of the
LambdaExpression. You do that with all the expressions in this section. The parent node
does help us find the return type of the LambdaExpression.
To examine each node in this expression, you need to recursively visit many nodes.
Here's a simple first implementation:
C#var constant = Expression.Constant( 24, typeof(int)); 
Console.WriteLine( $&quot;This is a/an {constant.NodeType}  expression type&quot; ); 
Console.WriteLine( $&quot;The type of the constant value is {constant.Type} &quot;); 
Console.WriteLine( $&quot;The value of the constant value is {constant.Value} &quot;); 
This is a/an Constant expression type<br />
The type of the constant value is System.Int32<br />
The value of the constant value is 24<br />
Addition expression
Expression&lt;Func&lt; int&gt;&gt; sum = () =&gt; 1 + 2; 
７ Note
Don't use var to declare this expression tree, because the natural type of the
delegate is Func<int>, not Expression&lt;Func<int>&gt;.
Expression&lt;Func&lt; int, int, int&gt;&gt; addition = (a, b) =&gt; a + b;  This sample prints the following output:
Output
You notice much repetition in the preceding code sample. Let's clean that up and build a
more general purpose expression node visitor. That's going to require us to write a
recursive algorithm. Any node could be of a type that might have children. Any node
that has children requires us to visit those children and determine what that node is.
Here's the cleaned up version that utilizes recursion to visit the addition operations:
C#Console.WriteLine( $&quot;This expression is a {addition.NodeType}  expression<br />
type&quot;); 
Console.WriteLine( $&quot;The name of the lambda is {((addition.Name == null) ? &quot;
<null>&quot; : addition.Name)} &quot;); 
Console.WriteLine( $&quot;The return type is {addition.ReturnType.ToString()} &quot;); 
Console.WriteLine( $&quot;The expression has {addition.Parameters.Count}<br />
arguments. They are:&quot; ); 
foreach (var argumentExpression in addition.Parameters)<br />
{ 
Console.WriteLine( $&quot;\tParameter Type:<br />
{argumentExpression.Type.ToString()} , Name: {argumentExpression.Name} &quot;); 
} 
var additionBody = (BinaryExpression)addition.Body;<br />
Console.WriteLine( $&quot;The body is a {additionBody.NodeType}  expression&quot; ); 
Console.WriteLine( $&quot;The left side is a {additionBody.Left.NodeType}<br />
expression&quot; ); 
var left = (ParameterExpression)additionBody.Left;<br />
Console.WriteLine( $&quot;\tParameter Type: {left.Type.ToString()} , Name: 
{left.Name} &quot;); 
Console.WriteLine( $&quot;The right side is a {additionBody.Right.NodeType}<br />
expression&quot; ); 
var right = (ParameterExpression)additionBody.Right;<br />
Console.WriteLine( $&quot;\tParameter Type: {right.Type.ToString()} , Name: 
{right.Name} &quot;); 
This expression is a/an Lambda expression type<br />
The name of the lambda is <null><br />
The return type is System.Int32<br />
The expression has 2 arguments. They are:<br />
Parameter Type: System.Int32, Name: a<br />
Parameter Type: System.Int32, Name: b<br />
The body is a/an Add expression<br />
The left side is a Parameter expression<br />
Parameter Type: System.Int32, Name: a<br />
The right side is a Parameter expression<br />
Parameter Type: System.Int32, Name: b  using System.Linq.Expressions;<br />
namespace  Visitors ; 
// Base Visitor class:<br />
public abstract  class Visitor 
{ 
private readonly  Expression node;<br />
protected  Visitor(Expression node ) =&gt; this.node = node;<br />
public abstract  void Visit(string prefix); 
public ExpressionType NodeType =&gt; node.NodeType;<br />
public static Visitor CreateFromExpression (Expression node ) =&gt; 
node.NodeType switch 
{<br />
ExpressionType.Constant =&gt; new 
ConstantVisitor((ConstantExpression)node),<br />
ExpressionType.Lambda =&gt; new 
LambdaVisitor((LambdaExpression)node),<br />
ExpressionType.Parameter =&gt; new 
ParameterVisitor((ParameterExpression)node),<br />
ExpressionType.Add =&gt; new BinaryVisitor((BinaryExpression)node),<br />
_ =&gt; throw new NotImplementedException( $&quot;Node not processed yet:<br />
{node.NodeType} &quot;), 
};<br />
} 
// Lambda Visitor<br />
public class LambdaVisitor  : Visitor 
{ 
private readonly  LambdaExpression node;<br />
public LambdaVisitor (LambdaExpression node ) : base(node) =&gt; this.node = 
node; 
public override  void Visit(string prefix) 
{ 
Console.WriteLine( $&quot;{prefix} This expression is a {NodeType}<br />
expression type&quot; ); 
Console.WriteLine( $&quot;{prefix} The name of the lambda is {((node.Name<br />
== null) ? &quot;<null>&quot;  : node.Name)} &quot;); 
Console.WriteLine( $&quot;{prefix} The return type is {node.ReturnType} &quot;); 
Console.WriteLine( $&quot;{prefix} The expression has<br />
{node.Parameters.Count}  argument(s). They are:&quot; ); 
// Visit each parameter:<br />
foreach (var argumentExpression in node.Parameters)<br />
{<br />
var argumentVisitor = CreateFromExpression(argumentExpression);<br />
argumentVisitor.Visit(prefix + &quot;\t&quot;); 
}<br />
Console.WriteLine( $&quot;{prefix} The expression body is:&quot; ); 
// Visit the body:<br />
var bodyVisitor = CreateFromExpression(node.Body);<br />
bodyVisitor.Visit(prefix + &quot;\t&quot;);     } 
} 
// Binary Expression Visitor:<br />
public class BinaryVisitor  : Visitor 
{ 
private readonly  BinaryExpression node;<br />
public BinaryVisitor (BinaryExpression node ) : base(node) =&gt; this.node = 
node; 
public override  void Visit(string prefix) 
{ 
Console.WriteLine( $&quot;{prefix} This binary expression is a {NodeType}<br />
expression&quot; ); 
var left = CreateFromExpression(node.Left);<br />
Console.WriteLine( $&quot;{prefix} The Left argument is:&quot; ); 
left.Visit(prefix + &quot;\t&quot;); 
var right = CreateFromExpression(node.Right);<br />
Console.WriteLine( $&quot;{prefix} The Right argument is:&quot; ); 
right.Visit(prefix + &quot;\t&quot;); 
} 
} 
// Parameter visitor:<br />
public class ParameterVisitor  : Visitor 
{ 
private readonly  ParameterExpression node;<br />
public ParameterVisitor (ParameterExpression node ) : base(node) 
{ 
this.node = node;<br />
} 
public override  void Visit(string prefix) 
{ 
Console.WriteLine( $&quot;{prefix} This is an {NodeType}  expression type&quot; ); 
Console.WriteLine( $&quot;{prefix} Type: {node.Type} , Name: {node.Name} , 
ByRef: {node.IsByRef} &quot;); 
} 
} 
// Constant visitor:<br />
public class ConstantVisitor  : Visitor 
{ 
private readonly  ConstantExpression node;<br />
public ConstantVisitor (ConstantExpression node ) : base(node) =&gt; 
this.node = node;<br />
public override  void Visit(string prefix) 
{ 
Console.WriteLine( $&quot;{prefix} This is an {NodeType}  expression type&quot; ); 
Console.WriteLine( $&quot;{prefix} The type of the constant value is<br />
{node.Type} &quot;); 
Console.WriteLine( $&quot;{prefix} The value of the constant value is<br />
{node.Value} &quot;); This algorithm is the basis of an algorithm that visits any arbitrary LambdaExpression. The
code you created only looks for a small sample of the possible sets of expression tree
nodes that it may encounter. However, you can still learn quite a bit from what it
produces. (The default case in the Visitor.CreateFromExpression method prints a
message to the error console when a new node type is encountered. That way, you
know to add a new expression type.)
When you run this visitor on the preceding addition expression, you get the following
output:
Output
Now that you've built a more general visitor implementation, you can visit and process
many more different types of expressions.
Let's try a more complicated example, yet still limit the node types to addition only:
C#
Before you run these examples on the visitor algorithm, try a thought exercise to work
out what the output might be. R emember that the + operator is a binar y oper ator: it    } 
} 
This expression is a/an Lambda expression type<br />
The name of the lambda is <null><br />
The return type is System.Int32<br />
The expression has 2 argument(s). They are:<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: a, ByRef: False<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: b, ByRef: False<br />
The expression body is:<br />
This binary expression is a Add expression<br />
The Left argument is:<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: a, ByRef: False<br />
The Right argument is:<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: b, ByRef: False<br />
Addition Expression with more operands
Expression&lt;Func&lt; int&gt;&gt; sum = () =&gt; 1 + 2 + 3 + 4; must have two children, representing the left and right operands. There are several
possible ways to construct a tree that could be correct:
C#
You can see the separation into two possible answers to highlight the most promising.
The first represents right ass ociativ e expressions. The second represent left associativ e
expressions. The advantage of both of those two formats is that the format scales to any
arbitrary number of addition expressions.
If you do run this expression through the visitor, you see this output, verifying that the
simple addition expression is left associativ e.
In order to run this sample, and see the full expression tree, you make one change to
the source expression tree. When the expression tree contains all constants, the
resulting tree simply contains the constant value of 10. The compiler performs all the
addition and reduces the expression to its simplest form. Simply adding one variable in
the expression is sufficient to see the original tree:
C#
Create a visitor for this sum and run the visitor you see this output:
OutputExpression&lt;Func&lt; int&gt;&gt; sum1 = () =&gt; 1 + (2 + (3 + 4)); 
Expression&lt;Func&lt; int&gt;&gt; sum2 = () =&gt; (( 1 + 2) + 3) + 4; 
Expression&lt;Func&lt; int&gt;&gt; sum3 = () =&gt; ( 1 + 2) + (3 + 4); 
Expression&lt;Func&lt; int&gt;&gt; sum4 = () =&gt; 1 + ((2 + 3) + 4); 
Expression&lt;Func&lt; int&gt;&gt; sum5 = () =&gt; ( 1 + (2 + 3)) + 4; 
Expression&lt;Func&lt; int, int&gt;&gt; sum = (a) =&gt; 1 + a + 3 + 4; 
This expression is a/an Lambda expression type<br />
The name of the lambda is <null><br />
The return type is System.Int32<br />
The expression has 1 argument(s). They are:<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: a, ByRef: False<br />
The expression body is:<br />
This binary expression is a Add expression<br />
The Left argument is:<br />
This binary expression is a Add expression<br />
The Left argument is:<br />
This binary expression is a Add expression<br />
The Left argument is:  You can run any of the other samples through the visitor code and see what tree it
represents. Here's an example of the preceding sum3 expression (with an additional
parameter to prevent the compiler from computing the constant):
C#
Here's the output from the visitor:
Output                                This is an Constant expression type<br />
The type of the constant value is<br />
System.Int32<br />
The value of the constant value is 1<br />
The Right argument is:<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: a, ByRef: False<br />
The Right argument is:<br />
This is an Constant expression type<br />
The type of the constant value is System.Int32<br />
The value of the constant value is 3<br />
The Right argument is:<br />
This is an Constant expression type<br />
The type of the constant value is System.Int32<br />
The value of the constant value is 4<br />
Expression&lt;Func&lt; int, int, int&gt;&gt; sum3 = (a, b) =&gt; ( 1 + a) + ( 3 + b); 
This expression is a/an Lambda expression type<br />
The name of the lambda is <null><br />
The return type is System.Int32<br />
The expression has 2 argument(s). They are:<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: a, ByRef: False<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: b, ByRef: False<br />
The expression body is:<br />
This binary expression is a Add expression<br />
The Left argument is:<br />
This binary expression is a Add expression<br />
The Left argument is:<br />
This is an Constant expression type<br />
The type of the constant value is System.Int32<br />
The value of the constant value is 1<br />
The Right argument is:<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: a, ByRef: False<br />
The Right argument is:<br />
This binary expression is a Add expression<br />
The Left argument is:<br />
This is an Constant expression type  Notice that the parentheses aren't part of the output. There are no nodes in the
expression tree that represent the parentheses in the input expression. The structure of
the expression tree contains all the information necessary to communicate the
precedence.
The sample deals with only the most rudimentary expression trees. The code you've
seen in this section only handles constant integers and the binary + operator. As a final
sample, let's update the visitor to handle a more complicated expression. Let's make it
work for the following factorial expression:
C#
This code represents one possible implementation for the mathematical factorial
function. The way you've written this code highlights two limitations of building
expression trees by assigning lambda expressions to Expressions. First, statement
lambdas aren't allowed. That means you can't use loops, blocks, if / else statements, and
other control structures common in C#. Y ou're limited to using expressions. Second, you
can't recursively call the same expression. Y ou could if it were already a delegate, but
you can't call it in its expression tree form. In the section on building expression trees ,
you learn techniques to overcome these limitations.
In this expression, you encounter nodes of all these types:</li>
<li>Equal (binary expression)</li>
<li>Multiply (binary expression)</li>
<li>Conditional (the ? : expression)</li>
<li>Method Call Expression (calling Range() and Aggregate())
One way to modify the visitor algorithm is to keep executing it, and write the node type
every time you reach your default clause. After a few iterations, you've see each of the                        The type of the constant value is System.Int32<br />
The value of the constant value is 3<br />
The Right argument is:<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: b, ByRef: False<br />
Extending this sample
Expression&lt;Func&lt; int, int&gt;&gt; factorial = (n) =&gt;<br />
n == 0 ? 
1 : 
Enumerable.Range( 1, n).Aggregate((product, factor) =&gt; product * factor);  potential nodes. Then, you have all you need. The result would be something like this:
C#
The ConditionalVisitor and MethodCallVisitor process those two nodes:
C#public static Visitor CreateFromExpression (Expression node ) =&gt; 
node.NodeType switch 
{ 
ExpressionType.Constant    =&gt; new 
ConstantVisitor((ConstantExpression)node),<br />
ExpressionType.Lambda      =&gt; new 
LambdaVisitor((LambdaExpression)node),<br />
ExpressionType.Parameter   =&gt; new 
ParameterVisitor((ParameterExpression)node),<br />
ExpressionType.Add         =&gt; new 
BinaryVisitor((BinaryExpression)node),<br />
ExpressionType.Equal       =&gt; new 
BinaryVisitor((BinaryExpression)node),<br />
ExpressionType.Multiply    =&gt; new BinaryVisitor((BinaryExpression)<br />
node), 
ExpressionType.Conditional =&gt; new 
ConditionalVisitor((ConditionalExpression) node),<br />
ExpressionType.Call        =&gt; new 
MethodCallVisitor((MethodCallExpression) node),<br />
_ =&gt; throw new NotImplementedException( $&quot;Node not processed yet:<br />
{node.NodeType} &quot;), 
}; 
public class ConditionalVisitor  : Visitor 
{ 
private readonly  ConditionalExpression node;<br />
public ConditionalVisitor (ConditionalExpression node ) : base(node) 
{ 
this.node = node;<br />
} 
public override  void Visit(string prefix) 
{ 
Console.WriteLine( $&quot;{prefix} This expression is a {NodeType}<br />
expression&quot; ); 
var testVisitor = Visitor.CreateFromExpression(node.Test);
Console.WriteLine( $&quot;{prefix} The Test for this expression is:&quot; ); 
testVisitor.Visit(prefix + &quot;\t&quot;); 
var trueVisitor = Visitor.CreateFromExpression(node.IfTrue);<br />
Console.WriteLine( $&quot;{prefix} The True clause for this expression<br />
is:&quot;); 
trueVisitor.Visit(prefix + &quot;\t&quot;); 
var falseVisitor = Visitor.CreateFromExpression(node.IfFalse);<br />
Console.WriteLine( $&quot;{prefix} The False clause for this expression  And the output for the expression tree would be:
Outputis:&quot;); 
falseVisitor.Visit(prefix + &quot;\t&quot;); 
} 
} 
public class MethodCallVisitor  : Visitor 
{ 
private readonly  MethodCallExpression node;<br />
public MethodCallVisitor (MethodCallExpression node ) : base(node) 
{ 
this.node = node;<br />
} 
public override  void Visit(string prefix) 
{ 
Console.WriteLine( $&quot;{prefix} This expression is a {NodeType}<br />
expression&quot; ); 
if (node.Object == null) 
Console.WriteLine( $&quot;{prefix} This is a static method call&quot; ); 
else 
{<br />
Console.WriteLine( $&quot;{prefix} The receiver (this) is:&quot; );
var receiverVisitor = Visitor.CreateFromExpression(node.Object);<br />
receiverVisitor.Visit(prefix + &quot;\t&quot;); 
}<br />
var methodInfo = node.Method;<br />
Console.WriteLine( $&quot;{prefix} The method name is<br />
{methodInfo.DeclaringType} .{methodInfo.Name} &quot;); 
// There is more here, like generic arguments, and so on.<br />
Console.WriteLine( $&quot;{prefix} The Arguments are:&quot; ); 
foreach (var arg in node.Arguments)<br />
{<br />
var argVisitor = Visitor.CreateFromExpression(arg);<br />
argVisitor.Visit(prefix + &quot;\t&quot;); 
}<br />
} 
} 
This expression is a/an Lambda expression type<br />
The name of the lambda is <null><br />
The return type is System.Int32<br />
The expression has 1 argument(s). They are:<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: n, ByRef: False<br />
The expression body is:<br />
This expression is a Conditional expression<br />
The Test for this expression is:<br />
This binary expression is a Equal expression  The samples in this section show the core techniques to visit and examine nodes in an
expression tree. It simplified the types of nodes you'll encounter to concentrate on the                The Left argument is:<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: n, ByRef: False<br />
The Right argument is:<br />
This is an Constant expression type<br />
The type of the constant value is System.Int32<br />
The value of the constant value is 0<br />
The True clause for this expression is:<br />
This is an Constant expression type<br />
The type of the constant value is System.Int32<br />
The value of the constant value is 1<br />
The False clause for this expression is:<br />
This expression is a Call expression<br />
This is a static method call<br />
The method name is System.Linq.Enumerable.Aggregate<br />
The Arguments are:<br />
This expression is a Call expression<br />
This is a static method call<br />
The method name is System.Linq.Enumerable.Range<br />
The Arguments are:<br />
This is an Constant expression type<br />
The type of the constant value is<br />
System.Int32<br />
The value of the constant value is 1<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: n, ByRef: False<br />
This expression is a Lambda expression type<br />
The name of the lambda is <null><br />
The return type is System.Int32<br />
The expression has 2 arguments. They are:<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: product, ByRef:<br />
False 
This is an Parameter expression type<br />
Type: System.Int32, Name: factor, ByRef:<br />
False 
The expression body is:<br />
This binary expression is a Multiply<br />
expression<br />
The Left argument is:<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: product,<br />
ByRef: False<br />
The Right argument is:<br />
This is an Parameter expression type<br />
Type: System.Int32, Name: factor,<br />
ByRef: False<br />
Extend the Sample Librarycore tasks of visiting and accessing nodes in an expression tree.
First, the visitors only handle constants that are integers. Constant values could be any
other numeric type, and the C# language supports conversions and promotions
between those types. A more robust version of this code would mirror all those
capabilities.
Even the last example recognizes a subset of the possible node types. Y ou can still feed
it many expressions that cause it to fail. A full implementation is included in .NET
Standard under the name ExpressionVisitor  and can handle all the possible node types.
Finally, the library used in this article was built for demonstration and learning. It's not
optimized. It makes the structures clear, and to highlight the techniques used to visit the
nodes and analyze what's there.
Even with those limitations, you should be well on your way to writing algorithms that
read and understand expression trees.Build expression trees
Article •03/09/2023
The C# compiler created all the expression trees you've seen so far. Y ou created a
lambda expression assigned to a variable typed as an Expression&lt;Func<T>&gt; or some
similar type. For many scenarios, you build an expression in memory at run time.
Expression trees are immutable. Being immutable means that you must build the tree
from the leaves up to the root. The APIs you use to build expression trees reflect this
fact: The methods you use to build a node take all its children as arguments. Let's walk
through a few examples to show you the techniques.
You start with the addition expression you've been working with throughout these
sections:
C#
To construct that expression tree, you first construct the leaf nodes. The leaf nodes are
constants. Use the Constant  method to create the nodes:
C#
Next, build the addition expression:
C#
Once you've built the addition expression, you create the lambda expression:
C#Create nodes
Expression&lt;Func&lt; int&gt;&gt; sum = () =&gt; 1 + 2; 
var one = Expression.Constant( 1, typeof(int)); 
var two = Expression.Constant( 2, typeof(int)); 
var addition = Expression.Add(one, two);<br />
var lambda = Expression.Lambda(addition);  This lambda expression contains no arguments. Later in this section, you see how to
map arguments to parameters and build more complicated expressions.
For expressions like this one, you may combine all the calls into a single statement:
C#
The previous section showed the basics of building an expression tree in memory. More
complex trees generally mean more node types, and more nodes in the tree. Let's run
through one more example and show two more node types that you typically build
when you create expression trees: the argument nodes, and method call nodes. Let's
build an expression tree to create this expression:
C#
You start by creating parameter expressions for x and y:
C#
Creating the multiplication and addition expressions follows the pattern you've already
seen:
C#
Next, you need to create a method call expression for the call to Math.Sqrt.var lambda2 = Expression.Lambda(<br />
Expression.Add(<br />
Expression.Constant( 1, typeof(int)), 
Expression.Constant( 2, typeof(int)) 
) 
); 
Build a tree
Expression&lt;Func&lt; double, double, double&gt;&gt; distanceCalc =<br />
(x, y) =&gt; Math.Sqrt(x * x + y * y);<br />
var xParameter = Expression.Parameter( typeof(double), &quot;x&quot;); 
var yParameter = Expression.Parameter( typeof(double), &quot;y&quot;); 
var xSquared = Expression.Multiply(xParameter, xParameter);<br />
var ySquared = Expression.Multiply(yParameter, yParameter);<br />
var sum = Expression.Add(xSquared, ySquared);  C#
The GetMethod call could return null if the method isn't found. Most likely that's
because you've misspelled the method name. Otherwise, it could mean the required
assembly isn't loaded. Finally, you put the method call into a lambda expression, and
make sure to define the arguments to the lambda expression:
C#
In this more complicated example, you see a couple more techniques that you often
need to create expression trees.
First, you need to create the objects that represent parameters or local variables before
you use them. Once you've created those objects, you can use them in your expression
tree wherever you need.
Second, you need to use a subset of the R eflection APIs to create a
System.R eflection.MethodInfo  object so that you can create an expression tree to access
that method. Y ou must limit yourself to the subset of the R eflection APIs that are
available on the .NET Core platform. Again, these techniques extend to other expression
trees.
You aren't limited in what you can build using these APIs. However, the more
complicated expression tree that you want to build, the more difficult the code is to
manage and to read.
Let's build an expression tree that is the equivalent of this code:
C#var sqrtMethod = typeof(Math).GetMethod( &quot;Sqrt&quot;, new[] { typeof(double) }) ?? 
throw new InvalidOperationException( &quot;Math.Sqrt not found!&quot; ); 
var distance = Expression.Call(sqrtMethod, sum);<br />
var distanceLambda = Expression.Lambda(<br />
distance,<br />
xParameter,<br />
yParameter);<br />
Build code in depth
Func&lt;int, int&gt; factorialFunc = (n) =&gt;<br />
{ 
var res = 1; The preceding code didn't build the expression tree, but simply the delegate. Using the
Expression class, you can't build statement lambdas. Here's the code that is required to
build the same functionality. There isn't an API for building a while loop, instead you
need to build a loop that contains a conditional test, and a label target to break out of
the loop.
C#
The code to build the expression tree for the factorial function is quite a bit longer,
more complicated, and it's riddled with labels and break statements and other elements
you'd like to avoid in our everyday coding tasks.    while (n &gt; 1) 
{ 
res = res * n;<br />
n--;<br />
} 
return res; 
}; 
var nArgument = Expression.Parameter( typeof(int), &quot;n&quot;); 
var result = Expression.Variable( typeof(int), &quot;result&quot; ); 
// Creating a label that represents the return value<br />
LabelTarget label = Expression.Label( typeof(int)); 
var initializeResult = Expression.Assign(result, Expression.Constant( 1)); 
// This is the inner block that performs the multiplication,<br />
// and decrements the value of 'n'<br />
var block = Expression.Block(<br />
Expression.Assign(result,<br />
Expression.Multiply(result, nArgument)),<br />
Expression.PostDecrementAssign(nArgument)<br />
); 
// Creating a method body.<br />
BlockExpression body = Expression.Block(<br />
new[] { result },<br />
initializeResult,<br />
Expression.Loop(<br />
Expression.IfThenElse(<br />
Expression.GreaterThan(nArgument, Expression.Constant( 1)), 
block,<br />
Expression.Break(label, result)<br />
),<br />
label<br />
) 
); For this section, you wrote code to visit every node in this expression tree and write out
information about the nodes that are created in this sample. Y ou can view or download
the sample code  at the dotnet/docs GitHub repository. Experiment for yourself by
building and running the samples.
The following code example demonstrates an expression tree that represents the
lambda expression num =&gt; num &lt; 5 by using the API.
C#
The expression trees API also supports assignments and control flow expressions such
as loops, conditional blocks, and try-catch blocks. By using the API, you can create
expression trees that are more complex than those that can be created from lambda
expressions by the C# compiler. The following example demonstrates how to create an
expression tree that calculates the factorial of a number.
C#
Map code constructs to expressions
// Manually build the expression tree for<br />
// the lambda expression num =&gt; num &lt; 5.<br />
ParameterExpression numParam = Expression.Parameter( typeof(int), &quot;num&quot;); 
ConstantExpression five = Expression.Constant( 5, typeof(int)); 
BinaryExpression numLessThanFive = Expression.LessThan(numParam, five);<br />
Expression&lt;Func&lt; int, bool&gt;&gt; lambda1 =<br />
Expression.Lambda&lt;Func&lt; int, bool&gt;&gt;( 
numLessThanFive,<br />
new ParameterExpression[] { numParam });<br />
// Creating a parameter expression.<br />
ParameterExpression value = Expression.Parameter( typeof(int), &quot;value&quot;); 
// Creating an expression to hold a local variable.<br />
ParameterExpression result = Expression.Parameter( typeof(int), &quot;result&quot; ); 
// Creating a label to jump to from a loop.<br />
LabelTarget label = Expression.Label( typeof(int)); 
// Creating a method body.<br />
BlockExpression block = Expression.Block(<br />
// Adding a local variable.<br />
new[] { result },<br />
// Assigning a constant to a local variable: result = 1<br />
Expression.Assign(result, Expression.Constant( 1)), 
// Adding a loop.<br />
Expression.Loop(<br />
// Adding a conditional block into the loop.  For more information, see Generating Dynamic Methods with Expression T rees in Visual
Studio 2010 , which also applies to later versions of Visual S tudio.           Expression.IfThenElse(
// Condition: value &gt; 1<br />
Expression.GreaterThan( value, Expression.Constant( 1)), 
// If true: result <em>= value --<br />
Expression.MultiplyAssign(result,<br />
Expression.PostDecrementAssign( value)), 
// If false, exit the loop and go to the label.<br />
Expression.Break(label, result)<br />
),<br />
// Label to jump to.<br />
label<br />
) 
); 
// Compile and execute an expression tree.<br />
int factorial = Expression.Lambda&lt;Func&lt; int, int&gt;&gt;(block, value).Compile()
(5); 
Console.WriteLine(factorial);<br />
// Prints 120.<br />
Translate exp ression trees
Article •03/09/2023
In this article, you learn how to visit each node in an expression tree while building a
modified copy of that expression tree. Y ou translate expression trees to understand the
algorithms so that it can be translated into another environment. Y ou change the
algorithm that has been created. Y ou might add logging, intercept method calls and
track them, or other purposes.
The code you build to translate an expression tree is an extension of what you've
already seen to visit all the nodes in a tree. When you translate an expression tree, you
visit all the nodes, and while visiting them, build the new tree. The new tree may contain
references to the original nodes, or new nodes that you've placed in the tree.
Let's visit an expression tree, and creating a new tree with some replacement nodes. In
this example, let's replace any constant with a constant that is 10 times larger.
Otherwise, you leave the expression tree intact. Rather than reading the value of the
constant and replacing it with a new constant, you make this replacement by replacing
the constant node with a new node that performs the multiplication.
Here, once you find a constant node, you create a new multiplication node whose
children are the original constant and the constant 10:
C#
Create a new tree by replacing the original node with the substitute. Y ou verify the
changes by compiling and executing the replaced tree.
C#private static Expression ReplaceNodes (Expression original ) 
{ 
if (original.NodeType == ExpressionType.Constant)<br />
{ 
return Expression.Multiply(original, Expression.Constant( 10)); 
} 
else if (original.NodeType == ExpressionType.Add)<br />
{ 
var binaryExpression = (BinaryExpression)original;<br />
return Expression.Add(<br />
ReplaceNodes(binaryExpression.Left),<br />
ReplaceNodes(binaryExpression.Right));<br />
} 
return original;<br />
} Building a new tree is a combination of visiting the nodes in the existing tree, and
creating new nodes and inserting them into the tree. The previous example shows the
importance of expression trees being immutable. Notice that the new tree created in the
preceding code contains a mixture of newly created nodes, and nodes from the existing
tree. Nodes can be used in both trees because the nodes in the existing tree can't be
modified. R eusing nodes results in significant memory efficiencies. The same nodes can
be used throughout a tree, or in multiple expression trees. Since nodes can't be
modified, the same node can be reused whenever it's needed.
Let's verify the new tree by building a second visitor that walks the tree of addition
nodes and computes the result. Make a couple modifications to the visitor that you've
seen so far. In this new version, the visitor returns the partial sum of the addition
operation up to this point. For a constant expression it's simply the value of the constant
expression. For an addition expression, the result is the sum of the left and right
operands, once those trees have been traversed.
C#var one = Expression.Constant( 1, typeof(int)); 
var two = Expression.Constant( 2, typeof(int)); 
var addition = Expression.Add(one, two);<br />
var sum = ReplaceNodes(addition);<br />
var executableFunc = Expression.Lambda(sum);<br />
var func = (Func&lt; int&gt;)executableFunc.Compile();<br />
var answer = func();<br />
Console.WriteLine(answer);<br />
Traverse and execute an addition
var one = Expression.Constant( 1, typeof(int)); 
var two = Expression.Constant( 2, typeof(int)); 
var three = Expression.Constant( 3, typeof(int)); 
var four = Expression.Constant( 4, typeof(int)); 
var addition = Expression.Add(one, two);<br />
var add2 = Expression.Add(three, four);<br />
var sum = Expression.Add(addition, add2);<br />
// Declare the delegate, so you can call it<br />
// from itself recursively:<br />
Func&lt;Expression, int&gt; aggregate = null!; 
// Aggregate, return constants, or the sum of the left and right operand.<br />
// Major simplification: Assume every binary expression is an addition.<br />
aggregate = (exp) =&gt;<br />
exp.NodeType == ExpressionType.Constant ?<br />
(int)((ConstantExpression)exp).Value :<br />
aggregate(((BinaryExpression)exp).Left) +  There's quite a bit of code here, but the concepts are approachable. This code visits
children in a depth first search. When it encounters a constant node, the visitor returns
the value of the constant. After the visitor has visited both children, those children have
computed the sum computed for that subtree. The addition node can now compute its
sum. Once all the nodes in the expression tree have been visited, the sum has been
computed. Y ou can trace the execution by running the sample in the debugger and
tracing the execution.
Let's make it easier to trace how the nodes are analyzed and how the sum is computed
by traversing the tree. Here's an updated version of the Aggregate method that includes
quite a bit of tracing information:
C#aggregate(((BinaryExpression)exp).Right);<br />
var theSum = aggregate(sum);<br />
Console.WriteLine(theSum);<br />
private static int Aggregate (Expression exp ) 
{ 
if (exp.NodeType == ExpressionType.Constant)<br />
{ 
var constantExp = (ConstantExpression)exp;<br />
Console.Error.WriteLine( $&quot;Found Constant: {constantExp.Value} &quot;); 
if (constantExp.Value is int value) 
{<br />
return value; 
}<br />
else 
{<br />
return 0; 
}<br />
} 
else if (exp.NodeType == ExpressionType.Add)<br />
{ 
var addExp = (BinaryExpression)exp;<br />
Console.Error.WriteLine( &quot;Found Addition Expression&quot; ); 
Console.Error.WriteLine( &quot;Computing Left node&quot; ); 
var leftOperand = Aggregate(addExp.Left);<br />
Console.Error.WriteLine( $&quot;Left is: {leftOperand} &quot;); 
Console.Error.WriteLine( &quot;Computing Right node&quot; ); 
var rightOperand = Aggregate(addExp.Right);<br />
Console.Error.WriteLine( $&quot;Right is: {rightOperand} &quot;); 
var sum = leftOperand + rightOperand;<br />
Console.Error.WriteLine( $&quot;Computed sum: {sum}&quot;); 
return sum; 
} 
else throw new NotSupportedException( &quot;Haven't written this yet&quot; ); 
} Running it on the sum expression yields the following output:
Output
Trace the output and follow along in the preceding code. Y ou should be able to work
out how the code visits each node and computes the sum as it goes through the tree
and finds the sum.
Now, let's look at a different run, with the expression given by sum1:
C#
Here's the output from examining this expression:
Output10 
Found Addition Expression<br />
Computing Left node<br />
Found Addition Expression<br />
Computing Left node<br />
Found Constant: 1<br />
Left is: 1<br />
Computing Right node<br />
Found Constant: 2<br />
Right is: 2<br />
Computed sum: 3<br />
Left is: 3<br />
Computing Right node<br />
Found Addition Expression<br />
Computing Left node<br />
Found Constant: 3<br />
Left is: 3<br />
Computing Right node<br />
Found Constant: 4<br />
Right is: 4<br />
Computed sum: 7<br />
Right is: 7<br />
Computed sum: 10<br />
10 
Expression&lt;Func&lt; int&gt;&gt; sum1 = () =&gt; 1 + (2 + (3 + 4)); 
Found Addition Expression<br />
Computing Left node<br />
Found Constant: 1<br />
Left is: 1<br />
Computing Right node<br />
Found Addition Expression  While the final answer is the same, the tree traversal is different. The nodes are traveled
in a different order, because the tree was constructed with different operations
occurring first.
Create a new Console Application  project. Add a using directive to the file for the
System.Linq.Expressions namespace. Add the AndAlsoModifier class to your project.
C#Computing Left node<br />
Found Constant: 2<br />
Left is: 2<br />
Computing Right node<br />
Found Addition Expression<br />
Computing Left node<br />
Found Constant: 3<br />
Left is: 3<br />
Computing Right node<br />
Found Constant: 4<br />
Right is: 4<br />
Computed sum: 7<br />
Right is: 7<br />
Computed sum: 9<br />
Right is: 9<br />
Computed sum: 10<br />
10 
Create a modified copy
public class AndAlsoModifier  : ExpressionVisitor<br />
{ 
public Expression Modify(Expression expression ) 
{ 
return Visit(expression);<br />
} 
protected  override  Expression VisitBinary (BinaryExpression b ) 
{ 
if (b.NodeType == ExpressionType.AndAlso)<br />
{<br />
Expression left = this.Visit(b.Left);<br />
Expression right = this.Visit(b.Right);<br />
// Make this binary expression an OrElse operation instead of an<br />
AndAlso operation.<br />
return Expression.MakeBinary(ExpressionType.OrElse, left, right,<br />
b.IsLiftedToNull, b.Method);<br />
}<br />
return base.VisitBinary(b);  This class inherits the ExpressionVisitor  class and is specialized to modify expressions
that represent conditional AND operations. It changes these operations from a
conditional AND to a conditional OR. The class overrides the VisitBinary  method of the
base type, because conditional AND expressions are represented as binary expressions.
In the VisitBinary method, if the expression that is passed to it represents a conditional
AND operation, the code constructs a new expression that contains the conditional OR
operator instead of the conditional AND operator. If the expression that is passed to
VisitBinary doesn't represent a conditional AND operation, the method defers to the
base class implementation. The base class methods construct nodes that are like the
expression trees that are passed in, but the nodes have their sub trees replaced with the
expression trees produced recursively by the visitor.
Add a using directive to the file for the System.Linq.Expressions namespace. Add code
to the Main method in the Program.cs file to create an expression tree and pass it to the
method that modifies it.
C#
The code creates an expression that contains a conditional AND operation. It then
creates an instance of the AndAlsoModifier class and passes the expression to the
Modify method of this class. Both the original and the modified expression trees are
outputted to show the change. Compile and run the application.    } 
} 
Expression&lt;Func&lt; string, bool&gt;&gt; expr = name =&gt; name.Length &gt; 10 &amp;&amp; 
name.StartsWith( &quot;G&quot;); 
Console.WriteLine(expr);<br />
AndAlsoModifier treeModifier = new AndAlsoModifier();<br />
Expression modifiedExpr = treeModifier.Modify((Expression)expr);<br />
Console.WriteLine(modifiedExpr);<br />
/</em>  This code produces the following output:<br />
name =&gt; ((name.Length &gt; 10) &amp;&amp; name.StartsWith(&quot;G&quot;))<br />
name =&gt; ((name.Length &gt; 10) || name.StartsWith(&quot;G&quot;))<br />
<em>/ 
Learn moreThis sample shows a small subset of the code you would build to traverse and interpret
the algorithms represented by an expression tree. For information on building a general
purpose library that translates expression trees into another language, read this series
by Matt W arren. It goes into great detail on how to translate any of the code you might
find in an expression tree.
You've now seen the true power of expression trees. Y ou examine a set of code, make
any changes you'd like to that code, and execute the changed version. Because the
expression trees are immutable, you create new trees by using the components of
existing trees. R eusing nodes minimizes the amount of memory needed to create
modified expression trees.Debugging expression trees in Visual
Studio
Article •03/09/2023
You can analyze the structure and content of expression trees when you debug your
applications. T o get a quick overview of the expression tree structure, you can use the
DebugView property, which represents expression trees using a special syntax . DebugView
is available only in debug mode.
Since DebugView is a string, you can use the built-in T ext Visualizer  to view it across
multiple lines, by selecting Text Visualizer  from the magnifying glass icon next to the
DebugView label.
Alternatively, you can install and use a custom visualizer  for expression trees, such as:
Readable Expressions  (MIT license , available at the Visual S tudio
Marketplace ), renders the expression tree as themeable C# code, with various
rendering options:
Expression T ree Visualizer  (MIT license ) provides a tree view of the expression
tree and its individual nodes:
Select the magnifying glass icon that appears next to the expression tree in DataTips , a
Watch window, the Autos window, or the Locals  window. A list of available visualizers is
displayed:
Select the visualizer you want to use.
Open a visualizer for an expression treeDebugging in Visual S tudio
Create Custom Visualizers
DebugView  syntaxSee alsoDebugView syntax
Article •03/09/2023
The DebugView  property (available only when debugging) provides a string rendering
of expression trees. Most of the syntax is fairly straightforward to understand; the
special cases are described in the following sections.
Each example is followed by a block comment, containing the DebugView .
ParameterExpression  variable names are displayed with a $ symbol at the beginning.
If a parameter doesn't have a name, it's assigned an automatically generated name, such
as $var1 or $var2.
C#
For ConstantExpression  objects that represent integer values, strings, and null, the
value of the constant is displayed.
For numeric types that have standard suffixes as C# literals, the suffix is added to the
value. The following table shows the suffixes associated with various numeric types.
Type Keyword Suffix
System.UInt32 uint U
System.Int64 long L
System.UInt64 ulong ULParameterExpression
ParameterExpression numParam =  Expression.Parameter( typeof(int), &quot;num&quot;); 
/</em> 
$num<br />
<em>/ 
ParameterExpression numParam =  Expression.Parameter( typeof(int)); 
/</em> 
$var1<br />
<em>/ 
ConstantExpressionType Keyword Suffix
System.Double double D
System.Single float F
System.Decimal decimal M
C#
If the type of a BlockExpression  object differs from the type of the last expression in the
block, the type is displayed within angle brackets ( &lt; and &gt;). Otherwise, the type of the
BlockExpression  object isn't displayed.
C#int num = 10; 
ConstantExpression expr = Expression.Constant(num);<br />
/</em> 
10 
<em>/ 
double num = 10; 
ConstantExpression expr = Expression.Constant(num);<br />
/</em> 
10D 
<em>/ 
BlockExpression
BlockExpression block = Expression.Block(Expression.Constant( &quot;test&quot;)); 
/</em> 
.Block() {<br />
&quot;test&quot;<br />
} 
<em>/ 
BlockExpression block =  Expression.Block( typeof(Object),<br />
Expression.Constant( &quot;test&quot;)); 
/</em> 
.Block&lt;System.Object&gt;() {<br />
&quot;test&quot;<br />
} 
<em>/ 
LambdaExpressionLambdaExpression  objects are displayed together with their delegate types.
If a lambda expression doesn't have a name, it's assigned an automatically generated
name, such as #Lambda1 or #Lambda2.
C#
If you specify a default value for the LabelExpression  object, this value is displayed
before the LabelT arget  object.
The .Label token indicates the start of the label. The .LabelTarget token indicates the
destination of the target to jump to.
If a label doesn't have a name, it's assigned an automatically generated name, such as
#Label1 or #Label2.
C#LambdaExpression lambda =  Expression.Lambda&lt;Func&lt; int&gt;&gt;
(Expression.Constant( 1)); 
/</em> 
.Lambda #Lambda1&lt;System.Func'1[System.Int32]&gt;() {<br />
1<br />
} 
<em>/ 
LambdaExpression lambda =  Expression.Lambda&lt;Func&lt; int&gt;&gt;
(Expression.Constant( 1), &quot;SampleLambda&quot; , null); 
/</em> 
.Lambda #SampleLambda&lt;System.Func'1[System.Int32]&gt;() {<br />
1<br />
} 
<em>/ 
LabelExpression
LabelTarget target = Expression.Label( typeof(int), &quot;SampleLabel&quot; ); 
BlockExpression block = Expression.Block(<br />
Expression.Goto(target, Expression.Constant( 0)), 
Expression.Label(target, Expression.Constant( -1)) 
); 
/</em> 
.Block() {<br />
.Goto SampleLabel { 0 };<br />
.Label<br />
-1<br />
.LabelTarget SampleLabel:
} Checked operators are displayed with the # symbol in front of the operator. For
example, the checked addition operator is displayed as #+.
C#<em>/ 
LabelTarget target = Expression.Label();<br />
BlockExpression block = Expression.Block(<br />
Expression.Goto(target),<br />
Expression.Label(target)<br />
); 
/</em> 
.Block() {<br />
.Goto #Label1 { };<br />
.Label<br />
.LabelTarget #Label1:<br />
} 
<em>/ 
Checked Operators
Expression expr = Expression.AddChecked( Expression.Constant( 1), 
Expression.Constant( 2)); 
/</em> 
1 #+ 2<br />
<em>/ 
Expression expr = Expression.ConvertChecked( Expression.Constant( 10.0), 
typeof(int)); 
/</em> 
#(System.Int32)10D<br />
*/ Interoperability Overview
Article •02/25/2023
Interoperability enables you to preserve and take advantage of existing investments in
unmanaged code. Code that runs under the control of the common language runtime
(CLR) is managed c ode, and code that runs outside the CLR is unmanaged c ode. COM,
COM+, C++ components, ActiveX components, and Microsoft Windows API are
examples of unmanaged code.
.NET enables interoperability with unmanaged code through platform invoke services,
the System.Runtime.InteropServices  namespace, C++ interoperability, and C OM
interoperability (C OM interop).
Platfor m invoke is a service that enables managed code to call unmanaged functions
implemented in dynamic link libraries (DLLs), such as the Microsoft Windows API. It
locates and invokes an exported function and marshals its arguments (integers, strings,
arrays, structures, and so on) across the interoperation boundary as needed.
For more information, see Consuming Unmanaged DLL Functions  and How to use
platform invoke to play a W AV file .
You can use C++ interop, also known as It Just W orks (IJW), to wrap a native C++ class.
C++ interop enables code authored in C# or another .NET language to access it. Y ou
write C++ code to wrap a native DLL or C OM component. Unlike other .NET languages,
Visual C++ has interoperability support that enables managed and unmanaged code in
the same application and even in the same file. Y ou then build the C++ code by using
the /clr compiler switch to produce a managed assembly. Finally, you add a reference toPlatform Invoke
７ Note
The Common Language Runtime  (CLR) manages access to system resources.
Calling unmanaged code that is outside the CLR bypasses this security mechanism,
and therefore presents a security risk. For example, unmanaged code might call
resources in unmanaged code directly, bypassing CLR security mechanisms. For
more information, see Security in .NE T.
C++ Interopthe assembly in your C# project and use the wrapped objects just as you would use
other managed classes.
You can consume a C OM component from a C# project. The general steps are as
follows:</li>
<li>Locate a C OM component to use and register it. Use regsvr32.exe to register or
un–register a C OM DLL.</li>
<li>Add to the project a reference to the C OM component or type library. When you
add the reference, Visual S tudio uses the Tlbimp.exe (T ype Library Importer) , which
takes a type library as input, to output a .NET interop assembly. The assembly, also
named a runtime callable wrapper (R CW), contains managed classes and interfaces
that wrap the C OM classes and interfaces that are in the type library. Visual S tudio
adds to the project a reference to the generated assembly.</li>
<li>Create an instance of a class defined in the R CW. Creating an instance of that class
creates an instance of the C OM object.</li>
<li>Use the object just as you use other managed objects. When the object is
reclaimed by garbage collection, the instance of the C OM object is also released
from memory.
For more information, see Exposing C OM Components to the .NET Framework .
COM clients can consume C# types that have been correctly exposed. The basic steps to
expose C# types are as follows:</li>
<li>Add interop attributes in the C# project. Y ou can make an assembly C OM visible by
modifying C# project properties. For more information, see Assembly Information
Dialog Box .</li>
<li>Generate a C OM type library and register it for C OM usage. Y ou can modify C#
project properties to automatically register the C# assembly for C OM interop.
Visual S tudio uses the Regasm.exe (Assembly R egistration T ool), using the /tlb
command-line switch, which takes a managed assembly as input, to generate a
type library. This type library describes the public types in the assembly and adds
registry entries so that C OM clients can create managed classes.
For more information, see Exposing .NET Framework Components to C OM and Example
COM Class .Exposing COM Components to C#
Exposing C# to COMImproving Interop P erformance
Introduction to Interoperability between C OM and .NET
Introduction to C OM Interop in Visual Basic
Marshaling between Managed and Unmanaged Code
Interoperating with Unmanaged CodeSee alsoExample COM Class
Article •02/25/2023
The following code is an example of a class that you would expose as a C OM object.
After you place this code in a .cs file added to your project, set the Regist er for C OM
Interop property to True. For more information, see How to: R egister a Component for
COM Interop .
Exposing C# objects to C OM requires declaring a class interface, an &quot;events interface&quot; if
necessary, and the class itself. Class members must follow these rules to be visible to
COM:
The class must be public.
Properties, methods, and events must be public.
Properties and methods must be declared on the class interface.
Events must be declared in the event interface.
Other public members in the class that you don't declare in these interfaces aren't
visible to C OM, but they're visible to other .NET objects. T o expose properties and
methods to C OM, you must declare them on the class interface and mark them with a
DispId attribute, and implement them in the class. The order in which you declare the
members in the interface is the order used for the C OM vtable. T o expose events from
your class, you must declare them on the events interface and mark them with a DispId
attribute. The class shouldn't implement this interface.
The class implements the class interface; it can implement more than one interface, but
the first implementation is the default class interface. Implement the methods and
properties exposed to C OM here. They must be public and must match the declarations
in the class interface. Also, declare the events raised by the class here. They must be
public and must match the declarations in the events interface.
C#Example
using System.Runtime.InteropServices;<br />
namespace  project_name<br />
{ 
[Guid(&quot;EAA4976A-45C3-4BC5-BC0B-E474F4C3C83F&quot; )] 
public interface  ComClass1Interface<br />
{ 
} Interoperability
Build P age, Project Designer (C#)    [Guid(&quot;7BD20046-DF8C-44A6-8F6B-687FAA26FA71&quot; ), 
InterfaceType(ComInterfaceType.InterfaceIsIDispatch) ] 
public interface  ComClass1Events<br />
{ 
} 
[Guid(&quot;0D53A3E8-E51A-49C7-944E-E72A2064F938&quot; ), 
ClassInterface(ClassInterfaceType.None),<br />
ComSourceInterfaces(typeof(ComClass1Events)) ] 
public class ComClass1  : ComClass1Interface<br />
{ 
} 
} 
See alsoWalkthrough: Office Programming in C#
Article •03/01/2023
C# offers features that improve Microsoft Office programming. Helpful C# features
include named and optional arguments and return values of type dynamic. In C OM
programming, you can omit the ref keyword and gain access to indexed properties.
Both languages enable embedding of type information, which allows deployment of
assemblies that interact with C OM components without deploying primary interop
assemblies (PIAs) to the user's computer. For more information, see Walkthrough:
Embedding T ypes from Managed Assemblies .
This walkthrough demonstrates these features in the context of Office programming,
but many of these features are also useful in general programming. In the walkthrough,
you use an Excel Add-in application to create an Excel workbook. Next, you create a
Word document that contains a link to the workbook. Finally, you see how to enable
and disable the PIA dependency.
You must have Microsoft Office Excel and Microsoft Office W ord installed on your
computer to complete this walkthrough.） Impor tant
VSTO (Visual S tudio T ools for Office)  relies on the .NET Framew ork. COM add-ins
can also be written with the .NET Framework. Office Add-ins cannot be created with
.NET Cor e and .NE T 5+ , the latest versions of .NET. This is because .NET Core/.NET
5+ cannot work together with .NET Framework in the same process and may lead
to add-in load failures. Y ou can continue to use .NET Framework to write VST O and
COM add-ins for Office. Microsoft will not be updating VST O or the C OM add-in
platform to use .NET Core or .NET 5+. Y ou can take advantage of .NET Core and
.NET 5+, including ASP.NET Core, to create the server side of Office W eb Add-ins .
Prerequisites
７ Note
Your computer might show different names or locations for some of the Visual
Studio user interface elements in the following instructions. The Visual S tudio1. Start Visual S tudio.</li>
<li>On the File menu, point to New , and then select Project .</li>
<li>In the Installed T emplat es pane, expand C#, expand Office , and then select the
version year of the Office product.</li>
<li>In the Templat es pane, select Excel <v ersion> Add-in .</li>
<li>Look at the top of the Templat es pane to make sure that .NET Framew ork 4 , or a
later version, appears in the Target Framew ork box.</li>
<li>Type a name for your project in the Name  box, if you want to.</li>
<li>Select OK.</li>
<li>The new project appears in Solution Explor er.</li>
<li>In Solution Explor er, right-click your project's name and then select Add
Reference . The Add R eference  dialog box appears.</li>
<li>On the Assemblies  tab, select Microsoft.Office.Int erop.Ex cel, version
<version>.0.0.0 (for a key to the Office product version numbers, see Microsoft
Versions ), in the Component Name  list, and then hold down the CTRL key and
select Microsoft.Office.Int erop.W ord, version <version>.0.0.0. If you don't see
the assemblies, you may need to install them (see How to: Install Office Primary
Interop Assemblies ).</li>
<li>Select OK.
In Solution Explor er, right-click the ThisAddIn.cs  file and then select View Code . Add
the following using directives (C#) to the top of the code file if they aren't already
present.
C#edition that you have and the settings that you use determine these elements. For
more information, see Personalizing the IDE .
Set up an Excel Add-in application
Add references
Add necessary Imports statements or using
directives
using System.Collections.Generic;
using Excel = Microsoft.Office.Interop.Excel;In Solution Explor er, right-click your project's name, select Add, and then select Class .
Name the class Account.cs. Select Add. Replace the definition of the Account class with
the following code. The class definitions use auto-implement ed pr operties.
C#
To create a bankAccounts list that contains two accounts, add the following code to the
ThisAddIn_Startup method in ThisAddIn.cs . The list declarations use collection
initializer s.
C#
In the same file, add the following method to the ThisAddIn class. The method sets up
an Excel workbook and exports data to it.
C#using Word = Microsoft.Office.Interop.Word;
Create a list of bank accounts
class Account
{
public int ID { get; set; }
public double Balance { get; set; }
}
var bankAccounts = new List<Account>
{
new Account
{
ID = 345,
Balance = 541.27
},
new Account
{
ID = 123,
Balance = -127.44
}
};
Export data to Excel
void DisplayInExcel (IEnumerable<Account> accounts,
Action&lt;Account, Excel.Range&gt; DisplayFunc )Method Add has an optional p aramet er for specifying a particular template.
Optional parameters enable you to omit the argument for that parameter if you
want to use the parameter's default value. Because the previous example has no
arguments, Add uses the default template and creates a new workbook. The
equivalent statement in earlier versions of C# requires a placeholder argument:
excelApp.Workbooks.Add(Type.Missing). For more information, see Named and
Optional Arguments .
The Range and Offset properties of the Range  object use the index ed pr operties
feature. This feature enables you to consume these properties from C OM types by
using the following typical C# syntax. Indexed properties also enable you to use
the Value property of the Range object, eliminating the need to use the Value2
property. The Value property is indexed, but the index is optional. Optional
arguments and indexed properties work together in the following example.
C#
You can't create indexed properties of your own. The feature only supports consumption
of existing indexed properties.
Add the following code at the end of DisplayInExcel to adjust the column widths to fit
the content.
C#{
var excelApp = this.Application;
// Add a new Excel workbook.
excelApp.Workbooks.Add();
excelApp.Visible = true;
excelApp.Range[ &quot;A1&quot;].Value = &quot;ID&quot;;
excelApp.Range[ &quot;B1&quot;].Value = &quot;Balance&quot; ;
excelApp.Range[ &quot;A2&quot;].Select();
foreach (var ac in accounts)
{
DisplayFunc(ac, excelApp.ActiveCell);
excelApp.ActiveCell.Offset[ 1, 0].Select();
}
// Copy the results to the Clipboard.
excelApp.Range[ &quot;A1:B3&quot;].Copy();
}
// Visual C# 2010 provides indexed properties for COM programming.
excelApp.Range[ &quot;A1&quot;].Value = &quot;ID&quot;;
excelApp.ActiveCell.Offset[ 1, 0].Select();These additions demonstrate another feature in C#: treating Object values returned
from C OM hosts such as Office as if they have type dynamic . COM objects are treated as
dynamic automatically when Embed Int erop Types  has its default value, True, or,
equivalently, when you reference the assembly with the EmbedInt eropTypes  compiler
option. For more information about embedding interop types, see procedures &quot;T o find
the PIA reference&quot; and &quot;T o restore the PIA dependency&quot; later in this article. For more
information about dynamic, see dynamic  or Using T ype dynamic .
Add the following code at the end of the ThisAddIn_StartUp method. The call to
DisplayInExcel contains two arguments. The first argument is the name of the list of
accounts processed. The second argument is a multiline lambda expression defining
how to process the data. The ID and balance values for each account are displayed in
adjacent cells, and the row is displayed in red if the balance is less than zero. For more
information, see Lambda Expressions .
C#
To run the program, press F5. An Excel worksheet appears that contains the data from
the accounts.
Add the following code at the end of the ThisAddIn_StartUp method to create a W ord
document that contains a link to the Excel workbook.excelApp.Columns[ 1].AutoFit();
excelApp.Columns[ 2].AutoFit();
Invoke DisplayInExcel
DisplayInExcel(bankAccounts, (account, cell) =&gt;
// This multiline lambda expression sets custom processing rules
// for the bankAccounts.
{
cell.Value = account.ID;
cell.Offset[ 0, 1].Value = account.Balance;
if (account.Balance &lt; 0)
{
cell.Interior.Color = 255;
cell.Offset[ 0, 1].Interior.Color = 255;
}
});
Add a Word documentC#
This code demonstrates several of the features in C#: the ability to omit the ref
keyword in C OM programming, named arguments, and optional arguments.The
PasteSpecial  method has seven parameters, all of which are optional reference
parameters. Named and optional arguments enable you to designate the parameters
you want to access by name and to send arguments to only those parameters. In this
example, arguments indicate creating a link to the workbook on the Clipboard
(parameter Link) and displaying that the link in the W ord document as an icon
(parameter DisplayAsIcon). C# also enables you to omit the ref keyword for these
arguments.
Press F5 to run the application. Excel starts and displays a table that contains the
information from the two accounts in bankAccounts. Then a W ord document appears
that contains a link to the Excel table.
In Visual S tudio, select Clean Solution  on the Build  menu. Otherwise, the add-in runs
every time that you open Excel on your computer.</li>
<li>Run the application again, but don't select Clean Solution .</li>
<li>Select the Start. Locate Microsoft Visual S tudio <v ersion>  and open a developer
command prompt.</li>
<li>Type ildasm in the Developer Command Prompt for Visual S tudio window, and
then press ENTER. The IL D ASM window appears.</li>
<li>On the File menu in the IL D ASM window, select File &gt; Open . Double-click Visual
Studio <v ersion> , and then double-click Projects . Open the folder for your
project, and look in the bin/Debug folder for your pr oject name .dll. Double-click
your pr oject name .dll. A new window displays your project's attributes, in addition
to references to other modules and assemblies. The assembly includes thevar wordApp = new Word.Application();
wordApp.Visible = true;
wordApp.Documents.Add();
wordApp.Selection.PasteSpecial(Link: true, DisplayAsIcon: true);
Run the application
Clean up the completed project
Find the PIA referencenamespaces Microsoft.Office.Interop.Excel and Microsoft.Office.Interop.Word.
By default in Visual S tudio, the compiler imports the types you need from a
referenced PIA into your assembly. For more information, see How to: View
Assembly Contents .</li>
<li>Double-click the MANIFEST  icon. A window appears that contains a list of
assemblies that contain items referenced by the project.
Microsoft.Office.Interop.Excel and Microsoft.Office.Interop.Word aren't in the
list. Because you imported the types your project needs into your assembly, you
aren't required to install references to a PIA. Importing the types into your
assembly makes deployment easier. The PIAs don't have to be present on the
user's computer. An application doesn't require deployment of a specific version of
a PIA. Applications can work with multiple versions of Office, provided that the
necessary APIs exist in all versions. Because deployment of PIAs is no longer
necessary, you can create an application in advanced scenarios that works with
multiple versions of Office, including earlier versions. Y our code can't use any APIs
that aren't available in the version of Office you're working with. It isn't always clear
whether a particular API was available in an earlier version. W orking with earlier
versions of Office isn't recommended.</li>
<li>Close the manifest window and the assembly window.</li>
<li>In Solution Explor er, select the Show All Files  button. Expand the References
folder and select Microsoft.Office.Int erop.Ex cel. Press F4 to display the Proper ties
window.</li>
<li>In the Proper ties window, change the Embed Int erop Types  property from True to
False.</li>
<li>Repeat steps 1 and 2 in this procedure for Microsoft.Office.Interop.Word.</li>
<li>In C#, comment out the two calls to Autofit at the end of the DisplayInExcel
method.</li>
<li>Press F5 to verify that the project still runs correctly.</li>
<li>Repeat steps 1-3 from the previous procedure to open the assembly window.
Notice that Microsoft.Office.Interop.Word and Microsoft.Office.Interop.Excel
are no longer in the list of embedded assemblies.</li>
<li>Double-click the MANIFEST  icon and scroll through the list of referenced
assemblies. Both Microsoft.Office.Interop.Word and
Microsoft.Office.Interop.Excel are in the list. Because the application references
the Excel and W ord PIAs, and the Embed Int erop Types  property is False, both
assemblies must exist on the end user's computer.Restore the PIA dependency8. In Visual S tudio, select Clean Solution  on the Build  menu to clean up the
completed project.
Auto-Implemented Properties (C#)
Object and Collection Initializers
Visual S tudio T ools for Office (VST O)
Named and Optional Arguments
dynamic
Using T ype dynamic
Lambda Expressions (C#)
Walkthrough: Embedding T ype Information from Microsoft Office Assemblies in
Visual S tudio
Walkthrough: Embedding T ypes from Managed Assemblies
Walkthrough: Creating Y our First VST O Add-in for ExcelSee also
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide ..NET feedb ack
The .NET documentation is open
source. Provide feedback here.
 Open a documentation issue
 Provide product feedbackHow to use platform invoke to play a
WAV file
Article •02/25/2023
The following C# code example illustrates how to use platform invoke services to play a
WAV sound file on the Windows operating system.
This example code uses DllImportAttribute  to import winmm.dll's PlaySound method
entry point as Form1 PlaySound(). The example has a simple Windows Form with a
button. Clicking the button opens a standard windows OpenFileDialog  dialog box so
that you can open a file to play. When a wave file is selected, it's played by using the
PlaySound() method of the winmm.dll  library. For more information about this method,
see Using the PlaySound function with W aveform-Audio Files . Browse and select a file
that has a .wav extension, and then select Open  to play the wave file by using platform
invoke. A text box shows the full path of the file selected.
C#Example
using System.Runtime.InteropServices;<br />
namespace  WinSound ; 
public partial class Form1 : Form 
{ 
private TextBox textBox1;<br />
private Button button1;<br />
public Form1()  // Constructor.<br />
{ 
InitializeComponent();<br />
} 
[DllImport( &quot;winmm.DLL&quot; , EntryPoint = &quot;PlaySound&quot; , SetLastError = true,<br />
CharSet = CharSet.Unicode, ThrowOnUnmappableChar = true) ] 
private static extern bool PlaySound (string szSound, System.IntPtr hMod,<br />
PlaySoundFlags flags ); 
[System.Flags ] 
public enum PlaySoundFlags : int 
{ 
SND_SYNC = 0x0000, 
SND_ASYNC = 0x0001, 
SND_NODEFAULT = 0x0002, The Open Files  dialog box is filtered to show only files that have a .wav extension
through the filter settings.
Create a new C# Windows Forms Application project in Visual S tudio and name it
WinSound . Copy the preceding code, and paste it over the contents of the Form1.cs  file.
Copy the following code, and paste it in the Form1.Designer .cs file, in the
InitializeComponent() method, after any existing code.
C#        SND_LOOP = 0x0008, 
SND_NOSTOP = 0x0010, 
SND_NOWAIT = 0x00002000 , 
SND_FILENAME = 0x00020000 , 
SND_RESOURCE = 0x00040004
} 
private void button1_Click (object sender, System.EventArgs e ) 
{ 
var dialog1 = new OpenFileDialog();<br />
dialog1.Title = &quot;Browse to find sound file to play&quot; ; 
dialog1.InitialDirectory = @&quot;c:&quot;; 
//<Snippet5><br />
dialog1.Filter = &quot;Wav Files (<em>.wav)|</em>.wav&quot; ; 
//</Snippet5><br />
dialog1.FilterIndex = 2; 
dialog1.RestoreDirectory = true; 
if (dialog1.ShowDialog() == DialogResult.OK)<br />
{<br />
textBox1.Text = dialog1.FileName;<br />
PlaySound(dialog1.FileName, new System.IntPtr(),<br />
PlaySoundFlags.SND_SYNC);<br />
}<br />
} 
private void Form1_Load (object sender, EventArgs e ) 
{ 
// Including this empty method in the sample because in the IDE,<br />
// when users click on the form, generates code that looks for a<br />
default method<br />
// with this name. We add it here to prevent confusion for those<br />
using the samples.<br />
} 
} 
Compiling the codeCompile and run the code.
A Closer Look at Platform Invoke
Marshaling Data with Platform Invokethis.button1 = new System.Windows.Forms.Button();<br />
this.textBox1 = new System.Windows.Forms.TextBox();<br />
this.SuspendLayout();<br />
// 
// button1<br />
// 
this.button1.Location = new System.Drawing.Point( 192, 40); 
this.button1.Name = &quot;button1&quot; ; 
this.button1.Size = new System.Drawing.Size( 88, 24); 
this.button1.TabIndex = 0; 
this.button1.Text = &quot;Browse&quot; ; 
this.button1.Click += new System.EventHandler( this.button1_Click);<br />
// 
// textBox1<br />
// 
this.textBox1.Location = new System.Drawing.Point( 8, 40); 
this.textBox1.Name = &quot;textBox1&quot; ; 
this.textBox1.Size = new System.Drawing.Size( 168, 20); 
this.textBox1.TabIndex = 1; 
this.textBox1.Text = &quot;File path&quot; ; 
// 
// Form1<br />
// 
this.AutoScaleDimensions = new System.Drawing.SizeF( 5, 13); 
this.ClientSize = new System.Drawing.Size( 292, 266); 
this.Controls.Add( this.textBox1);<br />
this.Controls.Add( this.button1);<br />
this.Name = &quot;Form1&quot;; 
this.Text = &quot;Platform Invoke WinSound C#&quot; ; 
this.ResumeLayout( false); 
this.PerformLayout();<br />
See alsoHow to use indexed properties in COM
interop programming
Article •03/01/2023
Indexed properties work together with other features in C#, such as named and optional
arguments , a new type ( dynamic ), and embedded type information , to enhance
Microsoft Office programming.
In earlier versions of C#, methods are accessible as properties only if the get method
has no parameters and the set method has one and only one value parameter.
However, not all C OM properties meet those restrictions. For example, the Excel Range[]
property has a get accessor that requires a parameter for the name of the range. In the
past, because you couldn't access the Range property directly, you had to use the
get_Range method instead, as shown in the following example.
{language}
Indexed properties enable you to write the following instead:
{language}） Impor tant
VSTO relies on the .NET Framew ork. COM add-ins can also be written with the .NET
Framework. Office Add-ins cannot be created with .NET Cor e and .NE T 5+ , the
latest versions of .NET. This is because .NET Core/.NET 5+ cannot work together
with .NET Framework in the same process and may lead to add-in load failures. Y ou
can continue to use .NET Framework to write VST O and C OM add-ins for Office.
Microsoft will not be updating VST O or the C OM add-in platform to use .NET Core
or .NET 5+. Y ou can take advantage of .NET Core and .NET 5+, including ASP.NET
Core, to create the server side of Office W eb Add-ins .
// Visual C# 2008 and earlier.<br />
var excelApp = new Excel.Application();<br />
// . . .<br />
Excel.Range targetRange = excelApp.get_Range(&quot;A1&quot;, Type.Missing);<br />
// Visual C# 2010.<br />
var excelApp = new Excel.Application();<br />
// . . .<br />
Excel.Range targetRange = excelApp.Range[&quot;A1&quot;];  The previous example also uses the optional arguments  feature, which enables you to
omit Type.Missing.
Indexed properties enable you to write the following code.
{language}
You can't create indexed properties of your own. The feature only supports consumption
of existing indexed properties.
The following code shows a complete example. For more information about how to set
up a project that accesses the Office API, see How to access Office interop objects by
using C# features .
{language}// Visual C# 2010.<br />
targetRange.Value = &quot;Name&quot;;<br />
Example
// You must add a reference to Microsoft.Office.Interop.Excel to run<br />
// this example.<br />
using System;<br />
using Excel = Microsoft.Office.Interop.Excel;<br />
namespace IndexedProperties<br />
{ 
class Program<br />
{ 
static void Main(string[] args)<br />
{<br />
CSharp2010();<br />
}<br />
static void CSharp2010()<br />
{<br />
var excelApp = new Excel.Application();<br />
excelApp.Workbooks.Add();<br />
excelApp.Visible = true;<br />
Excel.Range targetRange = excelApp.Range[&quot;A1&quot;];<br />
targetRange.Value = &quot;Name&quot;;<br />
}<br />
static void CSharp2008()<br />
{<br />
var excelApp = new Excel.Application();  Named and Optional Arguments
dynamic
Using T ype dynamic            excelApp.Workbooks.Add(Type.Missing);<br />
excelApp.Visible = true;<br />
Excel.Range targetRange = excelApp.get_Range(&quot;A1&quot;,<br />
Type.Missing);<br />
targetRange.set_Value(Type.Missing, &quot;Name&quot;);<br />
// Or<br />
//targetRange.Value2 = &quot;Name&quot;;<br />
}<br />
} 
} 
See alsoHow to access Office interop objects
Article •03/01/2023
C# has features that simplify access to Office API objects. The new features include
named and optional arguments, a new type called dynamic, and the ability to pass
arguments to reference parameters in C OM methods as if they were value parameters.
In this article, you use the new features to write code that creates and displays a
Microsoft Office Excel worksheet. Y ou write code to add an Office W ord document that
contains an icon that is linked to the Excel worksheet.
To complete this walkthrough, you must have Microsoft Office Excel 2007 and Microsoft
Office W ord 2007, or later versions, installed on your computer.</li>
<li>Start Visual S tudio.</li>
<li>On the File menu, point to New , and then select Project . The New Pr oject  dialog
box appears.</li>
<li>In the Installed T emplat es pane, expand C#, and then select Windows .７ Note
Your computer might show different names or locations for some of the Visual
Studio user interface elements in the following instructions. The Visual S tudio
edition that you have and the settings that you use determine these elements. For
more information, see Personalizing the IDE .
） Impor tant
VSTO relies on the .NET Framew ork. COM add-ins can also be written with the .NET
Framework. Office Add-ins cannot be created with .NET Cor e and .NE T 5+ , the
latest versions of .NET. This is because .NET Core/.NET 5+ cannot work together
with .NET Framework in the same process and may lead to add-in load failures. Y ou
can continue to use .NET Framework to write VST O and C OM add-ins for Office.
Microsoft will not be updating VST O or the C OM add-in platform to use .NET Core
or .NET 5+. Y ou can take advantage of .NET Core and .NET 5+, including ASP.NET
Core, to create the server side of Office W eb Add-ins .
To create a new console application4. Look at the top of the New Pr oject  dialog box to make sure to select .NET
Framew ork 4  (or later version) as a target framework.</li>
<li>In the Templat es pane, select Console Application .</li>
<li>Type a name for your project in the Name  field.</li>
<li>Select OK.
The new project appears in Solution Explor er.</li>
<li>In Solution Explor er, right-click your project's name and then select Add
Reference . The Add R eference  dialog box appears.</li>
<li>On the Assemblies  page, select Microsoft.Office.Int erop.W ord in the Component
Name  list, and then hold down the CTRL key and select
Microsoft.Office.Int erop.Ex cel. If you don't see the assemblies, you may need to
install them. See How to: Install Office Primary Interop Assemblies .</li>
<li>Select OK.
In Solution Explor er, right-click the Program.cs  file and then select View Code . Add the
following using directives to the top of the code file:
C#
Paste the following class definition into Program.cs , under the Program class.
C#To add references
To add necessary using directives
using Excel = Microsoft.Office.Interop.Excel;<br />
using Word = Microsoft.Office.Interop.Word;<br />
To create a list of bank accounts
public class Account 
{ 
public int ID { get; set; } 
public double Balance { get; set; } 
} Add the following code to the Main method to create a bankAccounts list that contains
two accounts.
C#</li>
<li>Add the following method to the Program class to set up an Excel worksheet.
Method Add has an optional parameter for specifying a particular template.
Optional parameters enable you to omit the argument for that parameter if you
want to use the parameter's default value. Because you didn't supply an argument,
Add uses the default template and creates a new workbook. The equivalent
statement in earlier versions of C# requires a placeholder argument:
ExcelApp.Workbooks.Add(Type.Missing).
C#// Create a list of accounts.<br />
var bankAccounts = new List<Account> {<br />
new Account {<br />
ID = 345678, 
Balance = 541.27 
},<br />
new Account {<br />
ID = 1230221, 
Balance = -127.44 
}<br />
}; 
To declare a method that exports account
information to Excel
static void DisplayInExcel (IEnumerable<Account> accounts ) 
{ 
var excelApp = new Excel.Application();<br />
// Make the object visible.<br />
excelApp.Visible = true; 
// Create a new, empty workbook and add it to the collection returned<br />
// by property Workbooks. The new workbook becomes the active workbook.<br />
// Add has an optional parameter for specifying a particular template.<br />
// Because no argument is sent in this example, Add creates a new<br />
workbook.<br />
excelApp.Workbooks.Add();<br />
// This example uses a single workSheet. The explicit type casting is<br />
// removed in a later procedure.<br />
Excel._Worksheet workSheet = (Excel.Worksheet)excelApp.ActiveSheet;<br />
} Add the following code at the end of DisplayInExcel. The code inserts values into the
first two columns of the first row of the worksheet.
C#
Add the following code at the end of DisplayInExcel. The foreach loop puts the
information from the list of accounts into the first two columns of successive rows of the
worksheet.
C#
Add the following code at the end of DisplayInExcel to adjust the column widths to fit
the content.
C#
Earlier versions of C# require explicit casting for these operations because
ExcelApp.Columns[1] returns an Object, and AutoFit is an Excel Range  method. The
following lines show the casting.
C#
C# converts the returned Object to dynamic automatically if the assembly is referenced
by the EmbedInt eropTypes  compiler option or, equivalently, if the Excel Embed Int erop// Establish column headings in cells A1 and B1.<br />
workSheet.Cells[ 1, &quot;A&quot;] = &quot;ID Number&quot; ; 
workSheet.Cells[ 1, &quot;B&quot;] = &quot;Current Balance&quot; ; 
var row = 1; 
foreach (var acct in accounts)<br />
{ 
row++;<br />
workSheet.Cells[row, &quot;A&quot;] = acct.ID;<br />
workSheet.Cells[row, &quot;B&quot;] = acct.Balance;<br />
} 
workSheet.Columns[ 1].AutoFit();<br />
workSheet.Columns[ 2].AutoFit();<br />
((Excel.Range)workSheet.Columns[ 1]).AutoFit();<br />
((Excel.Range)workSheet.Columns[ 2]).AutoFit();  Types  property is true. T rue is the default value for this property.
Add the following line at the end of Main.
C#
Press CTRL+F5. An Excel worksheet appears that contains the data from the two
accounts.
The following code opens a W ord application and creates an icon that links to the Excel
worksheet. P aste method CreateIconInWordDoc, provided later in this step, into the
Program class. CreateIconInWordDoc uses named and optional arguments to reduce the
complexity of the method calls to Add and PasteSpecial . These calls incorporate two
other features that simplify calls to C OM methods that have reference parameters. First,
you can send arguments to the reference parameters as if they were value parameters.
That is, you can send values directly, without creating a variable for each reference
parameter. The compiler generates temporary variables to hold the argument values,
and discards the variables when you return from the call. Second, you can omit the ref
keyword in the argument list.
The Add method has four reference parameters, all of which are optional. Y ou can omit
arguments for any or all of the parameters if you want to use their default values.
The PasteSpecial method inserts the contents of the Clipboard. The method has seven
reference parameters, all of which are optional. The following code specifies arguments
for two of them: Link, to create a link to the source of the Clipboard contents, and
DisplayAsIcon, to display the link as an icon. Y ou can use named arguments for those
two arguments and omit the others. Although these arguments are reference
parameters, you don't have to use the ref keyword, or to create variables to send in as
arguments. Y ou can send the values directly.
C#To run the project
// Display the list in an Excel spreadsheet.<br />
DisplayInExcel(bankAccounts);<br />
To add a Word documentAdd the following statement at the end of Main.
C#
Add the following statement at the end of DisplayInExcel. The Copy method adds the
worksheet to the Clipboard.
C#
Press CTRL+F5. A W ord document appears that contains an icon. Double-click the icon
to bring the worksheet to the foreground.
More enhancements are possible when you call a C OM type that doesn't require a
primary interop assembly (PIA) at run time. R emoving the dependency on PIAs results in
version independence and easier deployment. For more information about thestatic void CreateIconInWordDoc () 
{ 
var wordApp = new Word.Application();<br />
wordApp.Visible = true; 
// The Add method has four reference parameters, all of which are<br />
// optional. Visual C# allows you to omit arguments for them if<br />
// the default values are what you want.<br />
wordApp.Documents.Add();<br />
// PasteSpecial has seven reference parameters, all of which are<br />
// optional. This example uses named arguments to specify values<br />
// for two of the parameters. Although these are reference<br />
// parameters, you do not need to use the ref keyword, or to create<br />
// variables to send in as arguments. You can send the values directly.<br />
wordApp.Selection.PasteSpecial( Link: true, DisplayAsIcon: true); 
} 
// Create a Word document that contains an icon that links to<br />
// the spreadsheet.<br />
CreateIconInWordDoc();<br />
// Put the spreadsheet contents on the clipboard. The Copy method has one<br />
// optional parameter for specifying a destination. Because no argument<br />
// is sent, the destination is the Clipboard.<br />
workSheet.Range[ &quot;A1:B3&quot;].Copy();<br />
To set the Embed Interop Types propertyadvantages of programming without PIAs, see Walkthrough: Embedding T ypes from
Managed Assemblies .
In addition, programming is easier because the dynamic type represents the required
and returned types declared in C OM methods. V ariables that have type dynamic aren't
evaluated until run time, which eliminates the need for explicit casting. For more
information, see Using T ype dynamic .
Embedding type information instead of using PIAs is default behavior. Because of that
default, several of the previous examples are simplified. Y ou don't need any explicit
casting. For example, the declaration of worksheet in DisplayInExcel is written as
Excel._Worksheet workSheet = excelApp.ActiveSheet rather than Excel._Worksheet
workSheet = (Excel.Worksheet)excelApp.ActiveSheet. The calls to AutoFit in the same
method also would require explicit casting without the default, because
ExcelApp.Columns[1] returns an Object, and AutoFit is an Excel method. The following
code shows the casting.
C#
To change the default and use PIAs instead of embedding type information, expand the
References node in Solution Explorer, and then select Microsoft.Office.Int erop.Ex cel or
Microsoft.Office.Int erop.W ord. If you can't see the Proper ties window, press F4. Find
Embed Int erop Types  in the list of properties, and change its value to False.
Equivalently, you can compile by using the References  compiler option instead of
EmbedInt eropTypes  at a command prompt.
Replace the two calls to AutoFit in DisplayInExcel with the following statement.
C#
The AutoFormat  method has seven value parameters, all of which are optional. Named
and optional arguments enable you to provide arguments for none, some, or all of
them. In the previous statement, you supply an argument for only one of the((Excel.Range)workSheet.Columns[ 1]).AutoFit();<br />
((Excel.Range)workSheet.Columns[ 2]).AutoFit();<br />
To add additional formatting  to the table
// Call to AutoFormat in Visual C# 2010.<br />
workSheet.Range[ &quot;A1&quot;, &quot;B3&quot;].AutoFormat(<br />
Excel.XlRangeAutoFormat.xlRangeAutoFormatClassic2);  parameters, Format. Because Format is the first parameter in the parameter list, you
don't have to provide the parameter name. However, the statement might be easier to
understand if you include the parameter name, as shown in the following code.
C#
Press CTRL+F5 to see the result. Y ou can find other formats in the listed in the
XlRangeAutoFormat  enumeration.
The following code shows the complete example.
C#// Call to AutoFormat in Visual C# 2010.<br />
workSheet.Range[ &quot;A1&quot;, &quot;B3&quot;].AutoFormat(Format:<br />
Excel.XlRangeAutoFormat.xlRangeAutoFormatClassic2);<br />
Example
using System.Collections.Generic;
using Excel = Microsoft.Office.Interop.Excel;<br />
using Word = Microsoft.Office.Interop.Word;<br />
namespace  OfficeProgrammingWalkthruComplete<br />
{ 
class Walkthrough<br />
{ 
static void Main(string[] args) 
{<br />
// Create a list of accounts.<br />
var bankAccounts = new List<Account><br />
{<br />
new Account {<br />
ID = 345678, 
Balance = 541.27 
},<br />
new Account {<br />
ID = 1230221, 
Balance = -127.44 
}<br />
};<br />
// Display the list in an Excel spreadsheet.<br />
DisplayInExcel(bankAccounts);<br />
// Create a Word document that contains an icon that links to<br />
// the spreadsheet.<br />
CreateIconInWordDoc();<br />
}          static void DisplayInExcel (IEnumerable<Account> accounts ) 
{<br />
var excelApp = new Excel.Application();<br />
// Make the object visible.<br />
excelApp.Visible = true; 
// Create a new, empty workbook and add it to the collection<br />
returned<br />
// by property Workbooks. The new workbook becomes the active<br />
workbook.<br />
// Add has an optional parameter for specifying a particular<br />
template.<br />
// Because no argument is sent in this example, Add creates a<br />
new workbook.<br />
excelApp.Workbooks.Add();<br />
// This example uses a single workSheet.<br />
Excel._Worksheet workSheet = excelApp.ActiveSheet;<br />
// Earlier versions of C# require explicit casting.<br />
//Excel._Worksheet workSheet =<br />
(Excel.Worksheet)excelApp.ActiveSheet;<br />
// Establish column headings in cells A1 and B1.<br />
workSheet.Cells[ 1, &quot;A&quot;] = &quot;ID Number&quot; ; 
workSheet.Cells[ 1, &quot;B&quot;] = &quot;Current Balance&quot; ; 
var row = 1; 
foreach (var acct in accounts)<br />
{<br />
row++;<br />
workSheet.Cells[row, &quot;A&quot;] = acct.ID;<br />
workSheet.Cells[row, &quot;B&quot;] = acct.Balance;<br />
}<br />
workSheet.Columns[ 1].AutoFit();<br />
workSheet.Columns[ 2].AutoFit();<br />
// Call to AutoFormat in Visual C#. This statement replaces the<br />
// two calls to AutoFit.<br />
workSheet.Range[ &quot;A1&quot;, &quot;B3&quot;].AutoFormat(<br />
Excel.XlRangeAutoFormat.xlRangeAutoFormatClassic2);<br />
// Put the spreadsheet contents on the clipboard. The Copy<br />
method has one<br />
// optional parameter for specifying a destination. Because no<br />
argument<br />
// is sent, the destination is the Clipboard.<br />
workSheet.Range[ &quot;A1:B3&quot;].Copy();<br />
}<br />
static void CreateIconInWordDoc () 
{<br />
var wordApp = new Word.Application();  Type.Missing
dynamic
Named and Optional Arguments
How to use named and optional arguments in Office programming            wordApp.Visible = true; 
// The Add method has four reference parameters, all of which<br />
are 
// optional. Visual C# allows you to omit arguments for them if<br />
// the default values are what you want.<br />
wordApp.Documents.Add();<br />
// PasteSpecial has seven reference parameters, all of which are<br />
// optional. This example uses named arguments to specify values<br />
// for two of the parameters. Although these are reference<br />
// parameters, you do not need to use the ref keyword, or to<br />
create 
// variables to send in as arguments. You can send the values<br />
directly.<br />
wordApp.Selection.PasteSpecial(Link: true, DisplayAsIcon: true); 
}<br />
} 
public class Account 
{ 
public int ID { get; set; } 
public double Balance { get; set; } 
} 
} 
See alsoHow to use named and optional
arguments in Office programming
Article •03/01/2023
Named arguments and optional arguments enhance convenience, flexibility, and
readability in C# programming. In addition, these features greatly facilitate access to
COM interfaces such as the Microsoft Office automation APIs.
In the following example, method ConvertT oTable has 16 parameters that represent
characteristics of a table, such as number of columns and rows, formatting, borders,
fonts, and colors. All 16 parameters are optional, because most of the time you don't
want to specify particular values for all of them. However, without named and optional
arguments, you must provide a value or a placeholder value. With named and optional
arguments, you specify values only for the parameters required for your project.
You must have Microsoft Office W ord installed on your computer to complete these
procedures.） Impor tant
VSTO relies on the .NET Framew ork. COM add-ins can also be written with the .NET
Framework. Office Add-ins cannot be created with .NET Cor e and .NE T 5+ , the
latest versions of .NET. This is because .NET Core/.NET 5+ cannot work together
with .NET Framework in the same process and may lead to add-in load failures. Y ou
can continue to use .NET Framework to write VST O and C OM add-ins for Office.
Microsoft will not be updating VST O or the C OM add-in platform to use .NET Core
or .NET 5+. Y ou can take advantage of .NET Core and .NET 5+, including ASP.NET
Core, to create the server side of Office W eb Add-ins .
７ Note
Your computer might show different names or locations for some of the Visual
Studio user interface elements in the following instructions. The Visual S tudio
edition that you have and the settings that you use determine these elements. For
more information, see Personalizing the IDE .
Create a new console applicationStart Visual S tudio. On the File menu, point to New , and then select Project . In the
Templat es Cat egories  pane, expand C#, and then select Windows . Look in the top of
the Templat es pane to make sure that .NET Framew ork 4  appears in the Target
Framew ork box. In the Templat es pane, select Console Application . Type a name for
your project in the Name  field. Select OK. The new project appears in Solution Explor er.
In Solution Explor er, right-click your project's name and then select Add R eference . The
Add R eference  dialog box appears. On the .NET page, select
Microsoft.Office.Int erop.W ord in the Component Name  list. Select OK.
In Solution Explor er, right-click the Program.cs  file and then select View Code . Add the
following using directives to the top of the code file:
C#
In the Program class in Program.cs , add the following method to create a W ord
application and a W ord document. The Add method has four optional parameters. This
example uses their default values. Therefore, no arguments are necessary in the calling
statement.
C#Add a reference
Add necessary using directives
using Word = Microsoft.Office.Interop.Word;<br />
Display text in a Word document
static void DisplayInWord () 
{ 
var wordApp = new Word.Application();<br />
wordApp.Visible = true; 
// docs is a collection of all the Document objects currently<br />
// open in Word.<br />
Word.Documents docs = wordApp.Documents;<br />
// Add a document to the collection and name it doc.<br />
Word.Document doc = docs.Add();<br />
} Add the following code at the end of the method to define where to display text in the
document, and what text to display:
C#
Add the following statement to Main:
C#
Press CTRL+F5 to run the project. A W ord document appears that contains the
specified text.
Use the ConvertToTable method to enclose the text in a table. The method has 16
optional parameters. IntelliSense encloses optional parameters in brackets, as shown in
the following illustration.
Named and optional arguments enable you to specify values for only the parameters
that you want to change. Add the following code to the end of method DisplayInWord
to create a table. The argument specifies that the commas in the text string in range
separate the cells of the table.// Define a range, a contiguous area in the document, by specifying<br />
// a starting and ending character position. Currently, the document<br />
// is empty.<br />
Word.Range range = doc.Range( 0, 0); 
// Use the InsertAfter method to insert a string at the end of the<br />
// current range.<br />
range.InsertAfter( &quot;Testing, testing, testing. . .&quot; ); 
Run the application
DisplayInWord();<br />
Change the text to a tableC#
Press CTRL+F5 to run the project.
Change the table so that it has one column and three rows, replace the last line in
DisplayInWord with the following statement and then type CTRL+F5.
C#
Specify a predefined format for the table, replace the last line in DisplayInWord with the
following statement and then type CTRL+F5. The format can be any of the
WdTableFormat  constants.
C#
The following code includes the full example:
C#// Convert to a simple table. The table will have a single row with<br />
// three columns.<br />
range.ConvertToTable(Separator: &quot;,&quot;); 
Experiment with other parameters
range.ConvertToTable(Separator: &quot;,&quot;, AutoFit: true, NumColumns: 1); 
range.ConvertToTable(Separator: &quot;,&quot;, AutoFit: true, NumColumns: 1, 
Format: Word.WdTableFormat.wdTableFormatElegant);<br />
Example
using System;<br />
using Word = Microsoft.Office.Interop.Word;<br />
namespace  OfficeHowTo<br />
{ 
class WordProgram<br />
{ 
static void Main(string[] args) 
{<br />
DisplayInWord();<br />
}<br />
static void DisplayInWord ()         {<br />
var wordApp = new Word.Application();<br />
wordApp.Visible = true; 
// docs is a collection of all the Document objects currently<br />
// open in Word.<br />
Word.Documents docs = wordApp.Documents;<br />
// Add a document to the collection and name it doc.<br />
Word.Document doc = docs.Add();<br />
// Define a range, a contiguous area in the document, by<br />
specifying<br />
// a starting and ending character position. Currently, the<br />
document<br />
// is empty.<br />
Word.Range range = doc.Range( 0, 0); 
// Use the InsertAfter method to insert a string at the end of<br />
the 
// current range.<br />
range.InsertAfter( &quot;Testing, testing, testing. . .&quot; ); 
// You can comment out any or all of the following statements to<br />
// see the effect of each one in the Word document.<br />
// Next, use the ConvertToTable method to put the text into a<br />
table. 
// The method has 16 optional parameters. You only have to<br />
specify 
// values for those you want to change.<br />
// Convert to a simple table. The table will have a single row<br />
with 
// three columns.<br />
range.ConvertToTable(Separator: &quot;,&quot;); 
// Change to a single column with three rows..<br />
range.ConvertToTable(Separator: &quot;,&quot;, AutoFit: true, NumColumns:<br />
1); 
// Format the table.<br />
range.ConvertToTable(Separator: &quot;,&quot;, AutoFit: true, NumColumns:<br />
1, 
Format: Word.WdTableFormat.wdTableFormatElegant);<br />
}<br />
} 
} Using type dynamic
Article •02/25/2023
The dynamic type is a static type, but an object of type dynamic bypasses static type
checking. In most cases, it functions like it has type object. The compiler assumes a
dynamic element supports any operation. Therefore, you don't have to determine
whether the object gets its value from a C OM API, from a dynamic language such as
IronPython, from the HTML Document Object Model (DOM), from reflection, or from
somewhere else in the program. However, if the code isn't valid, errors surface at run
time.
For example, if instance method exampleMethod1 in the following code has only one
parameter, the compiler recognizes that the first call to the method,
ec.exampleMethod1(10, 4), isn't valid because it contains two arguments. The call causes
a compiler error. The compiler doesn't check the second call to the method,
dynamic_ec.exampleMethod1(10, 4), because the type of dynamic_ec is dynamic.
Therefore, no compiler error is reported. However, the error doesn't escape notice
indefinitely. It appears at run time and causes a run-time exception.
C#
C#static void Main(string[] args) 
{ 
ExampleClass ec = new ExampleClass();<br />
// The following call to exampleMethod1 causes a compiler error<br />
// if exampleMethod1 has only one parameter. Uncomment the line<br />
// to see the error.<br />
//ec.exampleMethod1(10, 4);<br />
dynamic dynamic_ec = new ExampleClass();<br />
// The following line is not identified as an error by the<br />
// compiler, but it causes a run-time exception.<br />
dynamic_ec.exampleMethod1( 10, 4); 
// The following calls also do not cause compiler errors, whether<br />
// appropriate methods exist or not.<br />
dynamic_ec.someMethod( &quot;some argument&quot; , 7, null); 
dynamic_ec.nonexistentMethod();<br />
} 
class ExampleClass<br />
{ 
public ExampleClass () { } The role of the compiler in these examples is to package together information about
what each statement is proposing to do to the dynamic object or expression. The
runtime examines the stored information and any statement that isn't valid causes a
run-time exception.
The result of most dynamic operations is itself dynamic. For example, if you rest the
mouse pointer over the use of testSum in the following example, IntelliSense displays
the type (local v ariable) dynamic t estSum .
C#
Operations in which the result isn't dynamic include:
Conversions from dynamic to another type.
Constructor calls that include arguments of type dynamic.
For example, the type of testInstance in the following declaration is ExampleClass, not
dynamic:
C#
Conversions between dynamic objects and other types are easy. Conversions enable the
developer to switch between dynamic and non-dynamic behavior.
You can convert any to dynamic implicitly, as shown in the following examples.
C#    public ExampleClass (int v) { } 
public void exampleMethod1 (int i) { } 
public void exampleMethod2 (string str) { } 
} 
dynamic d = 1; 
var testSum = d + 3; 
// Rest the mouse pointer over testSum in the following statement.<br />
System.Console.WriteLine(testSum);<br />
var testInstance = new ExampleClass(d);<br />
ConversionsConversely, you can dynamically apply any implicit conversion to any expression of type
dynamic.
C#
Overload resolution occurs at run time instead of at compile time if one or more of the
arguments in a method call have the type dynamic, or if the receiver of the method call
is of type dynamic. In the following example, if the only accessible exampleMethod2
method takes a string argument, sending d1 as the argument doesn't cause a compiler
error, but it does cause a run-time exception. Overload resolution fails at run time
because the run-time type of d1 is int, and exampleMethod2 requires a string.
C#
The dynamic language runtime (DLR) provides the infrastructure that supports the
dynamic type in C#, and also the implementation of dynamic programming languagesdynamic d1 = 7; 
dynamic d2 = &quot;a string&quot; ; 
dynamic d3 = System.DateTime.Today;<br />
dynamic d4 = System.Diagnostics.Process.GetProcesses();<br />
int i = d1;<br />
string str = d2;<br />
DateTime dt = d3;<br />
System.Diagnostics.Process[] procs = d4;<br />
Overload resolutio n with arguments of type
dynamic
// Valid.<br />
ec.exampleMethod2( &quot;a string&quot; ); 
// The following statement does not cause a compiler error, even though ec<br />
is not 
// dynamic. A run-time exception is raised because the run-time type of d1<br />
is int. 
ec.exampleMethod2(d1);<br />
// The following statement does cause a compiler error.<br />
//ec.exampleMethod2(7);<br />
Dynamic language runtim esuch as IronPython and IronRuby. For more information about the DLR, see Dynamic
Language Runtime Overview .
Many C OM methods allow for variation in argument types and return type by
designating the types as object. COM interop necessitates explicit casting of the values
to coordinate with strongly typed variables in C#. If you compile by using the
EmbedInt eropTypes  (C# Compiler Options)  option, the introduction of the dynamic type
enables you to treat the occurrences of object in COM signatures as if they were of
type dynamic, and thereby to avoid much of the casting. For more information on using
the dynamic type with C OM objects, see the article on How to access Office interop
objects by using C# features .
Title Descr iption
dynamic Describes the usage of the dynamic keyword.
Dynamic Language
Runtime OverviewProvides an overview of the DLR, which is a runtime environment that
adds a set of services for dynamic languages to the common language
runtime (CLR).
Walkthrough: Creating
and Using Dynamic
ObjectsProvides step-by-step instructions for creating a custom dynamic object
and for creating a project that accesses an IronPython library.COM interop
Related articlesWalkthrough: Creating and Using
Dynamic Objects in C#
Article •02/25/2023
Dynamic objects expose members such as properties and methods at run time, instead
of at compile time. Dynamic objects enable you to create objects to work with structures
that don't match a static type or format. For example, you can use a dynamic object to
reference the HTML Document Object Model (DOM), which can contain any
combination of valid HTML markup elements and attributes. Because each HTML
document is unique, the members for a particular HTML document are determined at
run time. A common method to reference an attribute of an HTML element is to pass
the name of the attribute to the GetProperty method of the element. T o reference the
id attribute of the HTML element <div id="Div1">, you first obtain a reference to the</li>
</ol>
<div> element, and then use divElement.GetProperty("id"). If you use a dynamic
object, you can reference the id attribute as divElement.id.
Dynamic objects also provide convenient access to dynamic languages such as
IronPython and IronRuby. Y ou can use a dynamic object to refer to a dynamic script
interpreted at run time.
You reference a dynamic object by using late binding. Y ou specify the type of a late-
bound object as dynamic.For more information, see dynamic .
You can create custom dynamic objects by using the classes in the System.Dynamic
namespace. For example, you can create an ExpandoObject  and specify the members of
that object at run time. Y ou can also create your own type that inherits the
DynamicObject  class. Y ou can then override the members of the DynamicObject  class to
provide run-time dynamic functionality.
This article contains two independent walkthroughs:
Create a custom object that dynamically exposes the contents of a text file as
properties of an object.
Create a project that uses an IronPython library.
Visual S tudio 2022 version 17.3 or a later version  with the .NET desk top
development  workload installed. The .NET 7 SDK is included when you select this
workload.PrerequisitesFor the second walkthrough, install IronPython  for .NET. Go to their Download
page  to obtain the latest version.
The first walkthrough defines a custom dynamic object that searches the contents of a
text file. A dynamic property specifies the text to search for. For example, if calling code
specifies dynamicFile.Sample, the dynamic class returns a generic list of strings that
contains all of the lines from the file that begin with "Sample". The search is case-
insensitive. The dynamic class also supports two optional arguments. The first argument
is a search option enum value that specifies that the dynamic class should search for
matches at the start of the line, the end of the line, or anywhere in the line. The second
argument specifies that the dynamic class should trim leading and trailing spaces from
each line before searching. For example, if calling code specifies
dynamicFile.Sample(StringSearchOption.Contains), the dynamic class searches for
"Sample" anywhere in a line. If calling code specifies
dynamicFile.Sample(StringSearchOption.StartsWith, false), the dynamic class searches
for "Sample" at the start of each line, and doesn't remove leading and trailing spaces.
The default behavior of the dynamic class is to search for a match at the start of each
line and to remove leading and trailing spaces.
Start Visual S tudio. Select Create a new pr oject . In the Create a new pr oject  dialog,
select C#, select Console Application , and then select Next . In the Configur e your new
project  dialog, enter DynamicSample for the Project name , and then select Next . In the
Additional information  dialog, select .NET 7.0 (Curr ent) for the Target Framew ork, and
then select Create. In Solution Explor er, right-click the DynamicSample project and
select Add > Class . In the Name  box, type ReadOnlyFile, and then select Add. At the
top of the ReadOnlyFile.cs  or ReadOnlyFile.vb  file, add the following code to import the
System.IO  and System.Dynamic  namespaces.７ Note
Your computer might show different names or locations for some of the Visual
Studio user interface elements in the following instructions. The Visual S tudio
edition that you have and the settings that you use determine these elements. For
more information, see Personalizing the IDE .
Create a Custom Dynamic Object
Create a custom dynamic classC#
The custom dynamic object uses an enum to determine the search criteria. Before the
class statement, add the following enum definition.
C#
Update the class statement to inherit the DynamicObject class, as shown in the following
code example.
C#
Add the following code to the ReadOnlyFile class to define a private field for the file
path and a constructor for the ReadOnlyFile class.
C#
1. Add the following GetPropertyValue method to the ReadOnlyFile class. The
GetPropertyValue method takes, as input, search criteria and returns the lines fromusing System.IO;  
using System.Dynamic;  
public enum StringSearchOption  
{ 
    StartsWith,  
    Contains,  
    EndsWith  
} 
class ReadOnlyFile  : DynamicObject  
// Store the path to the file and the initial line count value.  
private string p_filePath;  
// Public constructor. Verify that file exists and store the path in  
// the private variable.  
public ReadOnlyFile (string filePath ) 
{ 
    if (!File.Exists(filePath))  
    { 
        throw new Exception( "File path does not exist." ); 
    } 
    p_filePath = filePath;  
} a text file that match that search criteria. The dynamic methods provided by the
ReadOnlyFile class call the GetPropertyValue method to retrieve their respective
results.
C#
public List<string> GetPropertyValue (string propertyName,  
                                     StringSearchOption StringSearchOption =  
StringSearchOption.StartsWith,  
                                     bool trimSpaces = true) 
{ 
    StreamReader sr = null; 
    List< string> results = new List<string>();
    string line = ""; 
    string testLine = ""; 
    try 
    { 
        sr = new StreamReader(p_filePath);  
        while (!sr.EndOfStream)  
        {  
            line = sr.ReadLine();
            // Perform a case-insensitive search by using the specified  
search options.  
            testLine = line.ToUpper();  
            if (trimSpaces) { testLine = testLine.Trim(); }  
            switch (StringSearchOption)  
            {  
                case StringSearchOption.StartsWith:  
                    if (testLine.StartsWith(propertyName.ToUpper())) {  
results.Add(line); }  
                    break; 
                case StringSearchOption.Contains:  
                    if (testLine.Contains(propertyName.ToUpper())) {  
results.Add(line); }  
                    break; 
                case StringSearchOption.EndsWith:  
                    if (testLine.EndsWith(propertyName.ToUpper())) {  
results.Add(line); }  
                    break; 
            }  
        }  
    } 
    catch  
    { 
        // Trap any exception that occurs in reading the file and return  
null. 
        results = null; 
    } 
    finally After the GetPropertyValue method, add the following code to override the
TryGetMember  method of the DynamicObject  class. The TryGetMember  method is called
when a member of a dynamic class is requested and no arguments are specified. The
binder argument contains information about the referenced member, and the result
argument references the result returned for the specified member. The TryGetMember
method returns a Boolean value that returns true if the requested member exists;
otherwise it returns false.
C#
After the TryGetMember method, add the following code to override the
TryInvokeMember  method of the DynamicObject  class. The TryInvokeMember  method is
called when a member of a dynamic class is requested with arguments. The binder
argument contains information about the referenced member, and the result
argument references the result returned for the specified member. The args argument
contains an array of the arguments that are passed to the member. The
TryInvokeMember  method returns a Boolean value that returns true if the requested
member exists; otherwise it returns false.
The custom version of the TryInvokeMember method expects the first argument to be a
value from the StringSearchOption enum that you defined in a previous step. The
TryInvokeMember method expects the second argument to be a Boolean value. If one or
both arguments are valid values, they're passed to the GetPropertyValue method to
retrieve the results.
C#    { 
        if (sr != null) {sr.Close();}  
    } 
    return results;  
} 
// Implement the TryGetMember method of the DynamicObject class for dynamic  
member calls.  
public override  bool TryGetMember (GetMemberBinder binder,  
                                  out object result) 
{ 
    result = GetPropertyValue(binder.Name);  
    return result == null ? false : true; 
} Save and close the file.
In Solution Explor er, right-click the DynamicSample project and select Add > New It em.
In the Installed T emplat es pane, select General , and then select the Text File  template.
Leave the default name of TextFile1.t xt in the Name  box, and then select Add. Copy the
following text to the TextFile1.t xt file.
text// Implement the TryInvokeMember method of the DynamicObject class for  
// dynamic member calls that have arguments.  
public override  bool TryInvokeMember (InvokeMemberBinder binder,  
                                     object[] args,  
                                     out object result) 
{ 
    StringSearchOption StringSearchOption = StringSearchOption.StartsWith;  
    bool trimSpaces = true; 
    try 
    { 
        if (args.Length > 0) { StringSearchOption =  
(StringSearchOption)args[ 0]; } 
    } 
    catch  
    { 
        throw new ArgumentException( "StringSearchOption argument must be a  
StringSearchOption enum value." );
    } 
    try 
    { 
        if (args.Length > 1) { trimSpaces = ( bool)args[1]; } 
    } 
    catch  
    { 
        throw new ArgumentException( "trimSpaces argument must be a Boolean  
value."); 
    } 
    result = GetPropertyValue(binder.Name, StringSearchOption, trimSpaces);  
    return result == null ? false : true; 
} 
Create a sample text file
List of customers and suppliers  
Supplier: Lucerne Publishing (https://www.lucernepublishing.com/)  
Customer: Preston, Chris  Save and close the file.
In Solution Explor er, double-click the Program.cs  file. Add the following code to the
Main procedure to create an instance of the ReadOnlyFile class for the TextFile1.t xt file.
The code uses late binding to call dynamic members and retrieve lines of text that
contain the string "Customer".
C#
Save the file and press Ctrl+F5 to build and run the application.
The following walkthrough creates a project that accesses a library written in the
dynamic language IronPython.
In Visual S tudio, select File > New  > Project . In the Create a new pr oject  dialog, select
C#, select Console Application , and then select Next . In the Configur e your new pr oject
dialog, enter DynamicIronPythonSample for the Project name , and then select Next . InCustomer: Hines, Patrick  
Customer: Cameron, Maria  
Supplier: Graphic Design Institute (https://www.graphicdesigninstitute.com/)  
Supplier: Fabrikam, Inc. (https://www.fabrikam.com/)  
Customer: Seubert, Roxanne  
Supplier: Proseware, Inc. (http://www.proseware.com/)  
Customer: Adolphi, Stephan  
Customer: Koch, Paul  
Create a sample application that uses the custom
dynamic object
dynamic rFile = new ReadOnlyFile( @"..\..\..\TextFile1.txt" ); 
foreach (string line in rFile.Customer)  
{ 
    Console.WriteLine(line);  
} 
Console.WriteLine( "----------------------------" ); 
foreach (string line in rFile.Customer(StringSearchOption.Contains, true)) 
{ 
    Console.WriteLine(line);  
} 
Call a dynamic language library
To create a custom dynamic classthe Additional information  dialog, select .NET 7.0 (Curr ent) for the Target Framew ork,
and then select Create. Install the IronPython  NuGet package. Edit the Program.cs  file.
At the top of the file, add the following code to import the Microsoft.Scripting.Hosting
and IronPython.Hosting namespaces from the IronPython libraries and the System.Linq
namespace.
C#
In the Main method, add the following code to create a new
Microsoft.Scripting.Hosting.ScriptRuntime object to host the IronPython libraries. The
ScriptRuntime object loads the IronPython library module random.py.
C#
After the code to load the random.py module, add the following code to create an array
of integers. The array is passed to the shuffle method of the random.py module, which
randomly sorts the values in the array.
C#
using System.Linq;  
using Microsoft.Scripting.Hosting;  
using IronPython.Hosting;  
// Set the current directory to the IronPython libraries.  
System.IO.Directory.SetCurrentDirectory(  
   Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) +  
   @"\IronPython 2.7\Lib" ); 
// Create an instance of the random.py IronPython library.  
Console.WriteLine( "Loading random.py" ); 
ScriptRuntime py = Python.CreateRuntime();  
dynamic random = py.UseFile( "random.py" ); 
Console.WriteLine( "random.py loaded." ); 
// Initialize an enumerable set of integers.  
int[] items = Enumerable.Range( 1, 7).ToArray();  
// Randomly shuffle the array of integers by using IronPython.  
for (int i = 0; i < 5; i++) 
{ 
    random.shuffle(items);  
    foreach (int item in items) 
    { 
        Console.WriteLine(item);  
    } 
    Console.WriteLine( "-------------------" ); 
} Save the file and press Ctrl+F5 to build and run the application.
System.Dynamic
System.Dynamic.DynamicObject
Using T ype dynamic
dynamic
Implementing Dynamic Interfaces (downloadable PDF from Microsoft T echNet)See also
Reduce memo ry allocations using new
C# features
Article •10/17/2023
Performance work in .NET often means removing allocations from your code. Every
block of memory you allocate must eventually be freed. Fewer allocations reduce time
spent in garbage collection. It allows for more predictable execution time by removing
garbage collections from specific code paths.
A common tactic to reduce allocations is to change critical data structures from class
types to struct types. This change impacts the semantics of using those types.
Parameters and returns are now passed by value instead of by reference. The cost of
copying a value is negligible if the types are small, three words or less (considering one
word being of natural size of one integer). It's measurable and can have real
performance impact for larger types. T o combat the effect of copying, developers can
pass these types by ref to get back the intended semantics.
The C# ref features give you the ability to express the desired semantics for struct
types without negatively impacting their overall usability. Prior to these enhancements,
developers needed to resort to unsafe constructs with pointers and raw memory to
achieve the same performance impact. The compiler generates verifiably s afe code for
the new ref related features. Verifiably s afe code means the compiler detects possible） Impor tant
The techniques described in this section improve performance when applied to hot
paths in your code. Hot p aths are those sections of your codebase that are
executed often and repeatedly in normal operations. Applying these techniques to
code that isn't often executed will have minimal impact. Before making any
changes to improve performance, it's critical to measure a baseline. Then, analyze
that baseline to determine where memory bottlenecks occur. Y ou can learn about
many cross platform tools to measure your application's performance in the section
on Diagnostics and instrumentation . You can practice a profiling session in the
tutorial to Measur e memor y usage  in the Visual S tudio documentation.
Once you've measured memory usage and have determined that you can reduce
allocations, use the techniques in this section to reduce allocations. After each
successive change, measure memory usage again. Make sure each change has a
positive impact on the memory usage in your application.buffer overruns or accessing unallocated or freed memory. The compiler detects and
prevents some errors.
Variables in C# store values . In struct types, the value is the contents of an instance of
the type. In class types, the value is a reference to a block of memory that stores an
instance of the type. Adding the ref modifier means that the variable stores the
reference to the value. In struct types, the reference points to the storage containing
the value. In class types, the reference points to the storage containing the reference to
the block of memory.
In C#, parameters to methods are passed by value, and return values are return by value.
The value of the argument is passed to the method. The value of the return argument is
the return value.
The ref, in, ref readonly, or out modifier indicates that the argument is passed by
reference. A reference to the storage location is passed to the method. Adding ref to
the method signature means the return value is returned b y reference. A reference to the
storage location is the return value.
You can also use ref assignment  to have a variable refer to another variable. A typical
assignment copies the value of the right hand side to the variable on the left hand side
of the assignment. A ref assignment  copies the memory location of the variable on the
right hand side to the variable on the left hand side. The ref now refers to the original
variable:
C#
When you assign  a variable, you change its value. When you ref assign  a variable, you
change what it refers to.Pass and return by reference
int anInteger = 42; // assignment.
ref int location = ref anInteger; // ref assignment.
ref int sameLocation = ref location; // ref assignment
Console.WriteLine(location); // output: 42
sameLocation = 19; // assignment
Console.WriteLine(anInteger); // output: 19You can work directly with the storage for values using ref variables, pass by reference,
and ref assignment. Scope rules enforced by the compiler ensure safety when working
directly with storage.
The ref readonly and in modifiers both indicate that the argument should be passed
by reference and can't be reassigned in the method. The difference is that ref readonly
indicates that the method uses the parameter as a variable. The method might capture
the parameter, or it might return the parameter by readonly reference. In those cases,
you should use the ref readonly modifier. Otherwise, the in modifier offers more
flexibility. Y ou don't need to add the in modifier to an argument for an in parameter,
so you can update existing API signatures safely using the in modifier. The compiler
issues a warning if you don't add either the ref or in modifier to an argument for a
ref readonly parameter.
C# includes rules for ref expressions to ensure that a ref expression can't be accessed
where the storage it refers to is no longer valid. Consider the following example:
C#
The compiler reports an error because you can't return a reference to a local variable
from a method. The caller can't access the storage being referred to. The ref safe context
defines the scope in which a ref expression is safe to access or modify. The following
table lists the ref safe contexts for variable types. ref fields can't be declared in a class
or a non-ref struct, so those rows aren't in the table:
Declaration ref safe c ontext
non-ref local block where local is declared
non-ref parameter current method
ref, ref readonly, in parameter calling method
out parameter current methodRef safe context
public ref int CantEscape ()
{
    int index = 42;
    return ref index; // Error: index's ref safe context is the body of  
CantEscape
}Declaration ref safe c ontext
class field calling method
non-ref struct field current method
ref field of ref struct calling method
A variable can be ref returned if its ref safe context is the calling method. If its ref safe
context is the current method or a block, ref return is disallowed. The following snippet
shows two examples. A member field can be accessed from the scope calling a method,
so a class or struct field's ref safe context is the calling method. The ref safe context for a
parameter with the ref, or in modifiers is the entire method. Both can be ref returned
from a member method:
C#
The compiler ensures that a reference can't escape its ref safe context. You can use ref
parameters, ref return, and ref local variables safely because the compiler detects if
you've accidentally written code where a ref expression could be accessed when its
storage isn't valid.private int anIndex;
public ref int RetrieveIndexRef ()
{
    return ref anIndex;
}
public ref int RefMin(ref int left, ref int right)
{
    if (left < right)
        return ref left;
    else
        return ref right;
}
７ Note
When the ref readonly or in modifier is applied to a parameter, that parameter
can be returned by ref readonly, not ref.
Safe context and ref structsref struct types require more rules to ensure they can be used safely. A ref struct
type can include ref fields. That requires the introduction of a safe context. For most
types, the safe context is the calling method. In other words, a value that's not a ref
struct can always be returned from a method.
Informally, the safe context for a ref struct is the scope where all of its ref fields can
be accessed. In other words, it's the intersection of the ref safe context of all its ref
fields. The following method returns a ReadOnlySpan<char> to a member field, so its safe
context is the method:
C#
In contrast, the following code emits an error because the ref field member of the
Span<int> refers to the stack allocated array of integers. It can't escape the method:
C#
The introduction of System.Span<T>  and System.Memory<T>  provide a unified model
for working with memory. System.R eadOnlySpan<T>  and System.R eadOnlyMemory<T>
provide readonly versions for accessing memory. They all provide an abstraction over a
block of memory storing an array of similar elements. The difference is that Span<T> and
ReadOnlySpan<T> are ref struct types whereas Memory<T> and ReadOnlyMemory<T> are
struct types. Spans contain a ref field. Therefore instances of a span can't leave itsprivate string longMessage = "This is a long message" ;
public ReadOnlySpan< char> Safe()
{
    var span = longMessage.AsSpan();
    return span;
}
public Span<int> M()
{
    int length = 3;
    Span<int> numbers = stackalloc  int[length];
    for (var i = 0; i < length; i++)
    {
        numbers[i] = i;
    }
    return numbers; // Error! numbers can't escape this method.
}
Unify memory typessafe context. The safe context of a ref struct is the ref safe context of its ref field. The
implementation of Memory<T> and ReadOnlyMemory<T> remove this restriction. Y ou use
these types to directly access memory buffers.
Using these features to improve performance involves these tasks:
Avoid allocations : When you change a type from a class to a struct, you change
how it's stored. Local variables are stored on the stack. Members are stored inline
when the container object is allocated. This change means fewer allocations and
that decreases the work the garbage collector does. It might also decrease
memory pressure so the garbage collector runs less often.
Preserve reference semantics : Changing a type from a class to a struct changes
the semantics of passing a variable to a method. Code that modified the state of
its parameters needs modification. Now that the parameter is a struct, the
method is modifying a copy of the original object. Y ou can restore the original
semantics by passing that parameter as a ref parameter. After that change, the
method modifies the original struct again.
Avoid copying dat a: Copying larger struct types can impact performance in some
code paths. Y ou can also add the ref modifier to pass larger data structures to
methods by reference instead of by value.
Restrict modi fications : When a struct type is passed by reference, the called
method could modify the state of the struct. Y ou can replace the ref modifier with
the ref readonly or in modifiers to indicate that the argument can't be modified.
Prefer ref readonly when the method captures the parameter or returns it by
readonly reference. Y ou can also create readonly struct types or struct types
with readonly members to provide more control over what members of a struct
can be modified.
Directly manipulat e memor y: Some algorithms are most efficient when treating
data structures as a block of memory containing a sequence of elements. The Span
and Memory types provide safe access to blocks of memory.
None of these techniques require unsafe code. Used wisely, you can get performance
characteristics from safe code that was previously only possible by using unsafe
techniques. Y ou can try the techniques yourself in the tutorial on reducing memory
allocations .Improve performance with ref safety６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide ..NET feedb ack
The .NET documentation is open
source. Provide feedback here.
 Open a documentation issue
 Provide product feedbackTutorial: Reduce me mory allocations
with ref safety
Article •10/13/2023
Often, performance tuning for a .NET application involves two techniques. First, reduce
the number and size of heap allocations. Second, reduce how often data is copied.
Visual S tudio provides great tools  that help analyze how your application is using
memory. Once you've determined where your app makes unnecessary allocations, you
make changes to minimize those allocations. Y ou convert class types to struct types.
You use ref safety features  to preserve semantics and minimize extra copying.
Use Visual S tudio 17.5  for the best experience with this tutorial. The .NET object
allocation tool used to analyze memory usage is part of Visual S tudio. Y ou can use Visual
Studio Code  and the command line to run the application and make all the changes.
However, you won't be able to see the analysis results of your changes.
The application you'll use is a simulation of an IoT application that monitors several
sensors to determine if an intruder has entered a secret gallery with valuables. The IoT
sensors are constantly sending data that measures the mix of Oxygen (O2) and Carbon
Dioxide (C O2) in the air. They also report the temperature and relative humidity. Each of
these values is fluctuating slightly all the time. However, when a person enters the room,
the change a bit more, and always in the same direction: Oxygen decreases, Carbon
Dioxide increases, temperature increases, as does relative humidity. When the sensors
combine to show increases, the intruder alarm is triggered.
In this tutorial, you'll run the application, take measurements on memory allocations,
then improve the performance by reducing the number of allocations. The source code
is available in the samples browser .
Download the application and run the starter sample. The starter application works
correctly, but because it allocates many small objects with each measurement cycle, its
performance slowly degrades as it runs over time.
Console
Explore the starter application
Press <return> to start simulation
Debounced measurements:
    Temp:      67.332Many rows removed.
Console
You can explore the code to learn how the application works. The main program runs
the simulation. After you press <Enter>, it creates a room, and gathers some initial    Humidity:  41.077%
    Oxygen:    21.097%
    CO2 (ppm): 404.906
Average measurements:
    Temp:      67.332
    Humidity:  41.077%
    Oxygen:    21.097%
    CO2 (ppm): 404.906
Debounced measurements:
    Temp:      67.349
    Humidity:  46.605%
    Oxygen:    20.998%
    CO2 (ppm): 408.707
Average measurements:
    Temp:      67.349
    Humidity:  46.605%
    Oxygen:    20.998%
    CO2 (ppm): 408.707
Debounced measurements:
    Temp:      67.597
    Humidity:  46.543%
    Oxygen:    19.021%
    CO2 (ppm): 429.149
Average measurements:
    Temp:      67.568
    Humidity:  45.684%
    Oxygen:    19.631%
    CO2 (ppm): 423.498
Current intruders: 3
Calculated intruder risk: High
Debounced measurements:
    Temp:      67.602
    Humidity:  46.835%
    Oxygen:    19.003%
    CO2 (ppm): 429.393
Average measurements:
    Temp:      67.568
    Humidity:  45.684%
    Oxygen:    19.631%
    CO2 (ppm): 423.498
Current intruders: 3
Calculated intruder risk: Highbaseline data:
C#
Once that baseline data has been established, it runs the simulation on the room, where
a random number generator determines if an intruder has entered the room:
C#
Other types contain the measurements, a debounced measurement that is the average
of the last 50 measurements, and the average of all measurements taken.Console.WriteLine( "Press <return> to start simulation" );
Console.ReadLine();
var room = new Room("gallery" );
var r = new Random();
int counter = 0;
room.TakeMeasurements(
    m =>
    {
        Console.WriteLine(room.Debounce);
        Console.WriteLine(room.Average);
        Console.WriteLine();
        counter++;
        return counter < 20000;
    });
counter = 0;
room.TakeMeasurements(
    m =>
    {
        Console.WriteLine(room.Debounce);
        Console.WriteLine(room.Average);
        room.Intruders += (room.Intruders, r.Next( 5)) switch
        {
            ( > 0, 0) => -1,
            ( < 3, 1) => 1,
            _ => 0
        };
        Console.WriteLine( $"Current intruders: {room.Intruders} ");
        Console.WriteLine( $"Calculated intruder risk: {room.RiskStatus} ");
        Console.WriteLine();
        counter++;
        return counter < 200000;
    });Next, run the application using the .NET object allocation tool . Make sure you're using
the Release build, not the Debug build. On the Debug  menu, open the Performanc e
profiler. Check the .NET Object Allocation T racking  option, but nothing else. Run your
application to completion. The profiler measures object allocations and reports on
allocations and garbage collection cycles. Y ou should see a graph similar to the
following image:
The previous graph shows that working to minimize allocations will provide
performance benefits. Y ou see a sawtooth pattern in the live objects graph. That tells
you that numerous objects are created that quickly become garbage. They're later
collected, as shown in the object delta graph. The downward red bars indicate a
garbage collection cycle.
Next, look at the Allocations  tab below the graphs. This table shows what types are
allocated the most:
The System.S tring  type accounts for the most allocations. The most important task
should be to minimize the frequency of string allocations. This application prints
numerous formatted output to the console constantly. For this simulation, we want to
keep messages, so we'll concentrate on the next two rows: the SensorMeasurement type,
and the IntruderRisk type.
Double-click on the SensorMeasurement line. Y ou can see that all the allocations take
place in the static method SensorMeasurement.TakeMeasurement. You can see the
method in the following snippet:C#
Every measurement allocates a new SensorMeasurement object, which is a class type.
Every SensorMeasurement created causes a heap allocation.
The following code shows the initial declaration of SensorMeasurement:
C#public static SensorMeasurement TakeMeasurement (string room, int intruders )
{
    return new SensorMeasurement
    {
        CO2 = (CO2Concentration + intruders * 10) + (20 * 
generator.NextDouble() - 10.0),
        O2 = (O2Concentration - intruders * 0.01) + (0.005 * 
generator.NextDouble() - 0.0025),
        Temperature = (TemperatureSetting + intruders * 0.05) + (0.5 * 
generator.NextDouble() - 0.25),
        Humidity = (HumiditySetting + intruders * 0.005) + (0.20 * 
generator.NextDouble() - 0.10),
        Room = room,
        TimeRecorded = DateTime.Now
    };
}
Change classes to structs
public class SensorMeasurement
{
    private static readonly  Random generator = new Random();
    public static SensorMeasurement TakeMeasurement (string room, int 
intruders )
    {
        return new SensorMeasurement
        {
            CO2 = (CO2Concentration + intruders * 10) + (20 * 
generator.NextDouble() - 10.0),
            O2 = (O2Concentration - intruders * 0.01) + (0.005 * 
generator.NextDouble() - 0.0025),
            Temperature = (TemperatureSetting + intruders * 0.05) + (0.5 * 
generator.NextDouble() - 0.25),
            Humidity = (HumiditySetting + intruders * 0.005) + (0.20 * 
generator.NextDouble() - 0.10),
            Room = room,
            TimeRecorded = DateTime.Now
        };
    }The type was originally created as a class because it contains numerous double
measurements. It's larger than you'd want to copy in hot paths. However, that decision
meant a large number of allocations. Change the type from a class to a struct.
Changing from a class to struct introduces a few compiler errors because the original
code used null reference checks in a few spots. The first is in the DebounceMeasurement
class, in the AddMeasurement method:
C#    private const double CO2Concentration = 409.8; // increases with people.
    private const double O2Concentration = 0.2100; // decreases
    private const double TemperatureSetting = 67.5; // increases
    private const double HumiditySetting = 0.4500; // increases
    public required double CO2 { get; init; }
    public required double O2 { get; init; }
    public required double Temperature { get; init; }
    public required double Humidity { get; init; }
    public required string Room { get; init; }
    public required DateTime TimeRecorded { get; init; }
    public override  string ToString () => $"""
            Room: {Room} at {TimeRecorded}:
                Temp:      {Temperature:F3}
                Humidity:  {Humidity:P3}
                Oxygen:    {O2:P3}
                CO2 (ppm): {CO2:F3}
            """;
}
public void AddMeasurement (SensorMeasurement datum )
{
    int index = totalMeasurements % debounceSize;
    recentMeasurements[index] = datum;
    totalMeasurements++;
    double sumCO2 = 0;
    double sumO2 = 0;
    double sumTemp = 0;
    double sumHumidity = 0;
    for (int i = 0; i < debounceSize; i++)
    {
        if (recentMeasurements[i] is not null)
        {
            sumCO2 += recentMeasurements[i].CO2;
            sumO2+= recentMeasurements[i].O2;
            sumTemp+= recentMeasurements[i].Temperature;
            sumHumidity += recentMeasurements[i].Humidity;
        }
    }
    O2 = sumO2 / ((totalMeasurements > debounceSize) ? debounceSize :  The DebounceMeasurement type contains an array of 50 measurements. The readings for a
sensor are reported as the average of the last 50 measurements. That reduces the noise
in the readings. Before a full 50 readings have been taken, these values are null. The
code checks for null reference to report the correct average on system startup. After
changing the SensorMeasurement type to a struct, you must use a different test. The
SensorMeasurement type includes a string for the room identifier, so you can use that
test instead:
C#
The other three compiler errors are all in the method that repeatedly takes
measurements in a room:
C#
In the starter method, the local variable for the SensorMeasurement is a nullable r eference:
C#
Now that the SensorMeasurement is a struct instead of a class, the nullable is a nullable
value type . You can change the declaration to a value type to fix the remaining compilertotalMeasurements);
    CO2 = sumCO2 / ((totalMeasurements > debounceSize) ? debounceSize :  
totalMeasurements);
    Temperature = sumTemp / ((totalMeasurements > debounceSize) ?  
debounceSize : totalMeasurements);
    Humidity = sumHumidity / ((totalMeasurements > debounceSize) ?  
debounceSize : totalMeasurements);
}
if (recentMeasurements[i].Room is not null)         
public void TakeMeasurements (Func<SensorMeasurement, bool> 
MeasurementHandler )
{
    SensorMeasurement? measure = default;
    do {
        measure = SensorMeasurement.TakeMeasurement(Name, Intruders);
        Average.AddMeasurement(measure);
        Debounce.AddMeasurement(measure);
    } while (MeasurementHandler(measure));
}
SensorMeasurement? measure = default;errors:
C#
Now that the compiler errors have been addressed, you should examine the code to
ensure the semantics haven't changed. Because struct types are passed by value,
modifications made to method parameters aren't visible after the method returns.
The SensorMeasurement type doesn't include any methods that change state, so that's
not a concern in this sample. Y ou can prove that by adding the readonly modifier to the
SensorMeasurement struct:
C#
The compiler enforces the readonly nature of the SensorMeasurement struct. If your
inspection of the code missed some method that modified state, the compiler would tell
you. Y our app still builds without errors, so this type is readonly. Adding the readonly
modifier when you change a type from a class to a struct can help you find members
that modify the state of the struct.
You've removed a large number of unnecessary allocations from your app. The
SensorMeasurement type doesn't appear in the table anywhere.SensorMeasurement measure = default;
） Impor tant
Changing a type from a class to a struct can change the semantics of your
program. When a class type is passed to a method, any mutations made in the
method are made to the argument. When a struct type is passed to a method,
and mutations made in the method are made to a copy of the argument. That
means any method that modifies its arguments by design should be updated to
use the ref modifier on any argument type you've changed from a class to a
struct.
public readonly  struct SensorMeasurement
Avoid making copiesNow, it's doing extra working copying the SensorMeasurement structure every time it's
used as a parameter or a return value. The SensorMeasurement struct contains four
doubles, a DateTime  and a string. That structure is measurably larger than a reference.
Let's add the ref or in modifiers to places where the SensorMeasurement type is used.
The next step is to find methods that return a measurement, or take a measurement as
an argument, and use references where possible. S tart in the SensorMeasurement struct.
The static TakeMeasurement method creates and returns a new SensorMeasurement:
C#
We'll leave this one as is, returning by value. If you tried to return by ref, you'd get a
compiler error. Y ou can't return a ref to a new structure locally created in the method.
The design of the immutable struct means you can only set the values of the
measurement at construction. This method must create a new measurement struct.
Let's look again at DebounceMeasurement.AddMeasurement. You should add the in
modifier to the measurement parameter:
C#public static SensorMeasurement TakeMeasurement (string room, int intruders )
{
    return new SensorMeasurement
    {
        CO2 = (CO2Concentration + intruders * 10) + (20 * 
generator.NextDouble() - 10.0),
        O2 = (O2Concentration - intruders * 0.01) + (0.005 * 
generator.NextDouble() - 0.0025),
        Temperature = (TemperatureSetting + intruders * 0.05) + (0.5 * 
generator.NextDouble() - 0.25),
        Humidity = (HumiditySetting + intruders * 0.005) + (0.20 * 
generator.NextDouble() - 0.10),
        Room = room,
        TimeRecorded = DateTime.Now
    };
}
public void AddMeasurement (in SensorMeasurement datum )
{
    int index = totalMeasurements % debounceSize;
    recentMeasurements[index] = datum;
    totalMeasurements++;
    double sumCO2 = 0;
    double sumO2 = 0;
    double sumTemp = 0;
    double sumHumidity = 0;
    for (int i = 0; i < debounceSize; i++)That saves one copy operation. The in parameter is a reference to the copy already
created by the caller. Y ou can also save a copy with the TakeMeasurement method in the
Room type. This method illustrates how the compiler provides safety when you pass
arguments by ref. The initial TakeMeasurement method in the Room type takes an
argument of Func<SensorMeasurement, bool>. If you try to add the in or ref modifier to
that declaration, the compiler reports an error. Y ou can't pass a ref argument to a
lambda expression. The compiler can't guarantee that the called expression doesn't
copy the reference. If the lambda expression captur es the reference, the reference could
have a lifetime longer than the value it refers to. Accessing it outside its ref safe context
would result in memory corruption. The ref safety rules don't allow it. Y ou can learn
more in the overview of ref safety features .
The final sets of changes won't have a major impact on this application's performance
because the types aren't created in hot paths. These changes illustrate some of the
other techniques you'd use in your performance tuning. Let's take a look at the initial
Room class:
C#    {
        if (recentMeasurements[i].Room is not null)
        {
            sumCO2 += recentMeasurements[i].CO2;
            sumO2+= recentMeasurements[i].O2;
            sumTemp+= recentMeasurements[i].Temperature;
            sumHumidity += recentMeasurements[i].Humidity;
        }
    }
    O2 = sumO2 / ((totalMeasurements > debounceSize) ? debounceSize :  
totalMeasurements);
    CO2 = sumCO2 / ((totalMeasurements > debounceSize) ? debounceSize :  
totalMeasurements);
    Temperature = sumTemp / ((totalMeasurements > debounceSize) ?  
debounceSize : totalMeasurements);
    Humidity = sumHumidity / ((totalMeasurements > debounceSize) ?  
debounceSize : totalMeasurements);
}
Preserve semantics
public class Room
{
    public AverageMeasurement Average { get; } = new ();
    public DebounceMeasurement Debounce { get; } = new ();
    public string Name { get; }This type contains several properties. Some are class types. Creating a Room object
involves multiple allocations. One for the Room itself, and one for each of the members
of a class type that it contains. Y ou can convert two of these properties from class
types to struct types: the DebounceMeasurement and AverageMeasurement types. Let's
work through that transformation with both types.
Change the DebounceMeasurement type from a class to struct. That introduces a
compiler error CS8983: A 'struct' with field initializers must include an explicitly
declared constructor. You can fix this by adding an empty parameterless constructor:
C#    public IntruderRisk RiskStatus
    {
        get
        {
            var CO2Variance = (Debounce.CO2 - Average.CO2) > 10.0 / 4;
            var O2Variance = (Average.O2 - Debounce.O2) > 0.005 / 4.0;
            var TempVariance = (Debounce.Temperature - Average.Temperature)  
> 0.05 / 4.0;
            var HumidityVariance = (Debounce.Humidity - Average.Humidity) > 
0.20 / 4;
            IntruderRisk risk = IntruderRisk.None;
            if (CO2Variance) { risk++; }
            if (O2Variance) { risk++; }
            if (TempVariance) { risk++; }
            if (HumidityVariance) { risk++; }
            return risk;
        }
    }
    public int Intruders { get; set; }
<pre><code>public Room(string name)
{
    Name = name;
}
public void TakeMeasurements (Func&lt;SensorMeasurement, bool&gt; 
</code></pre>
<p>MeasurementHandler )
{
SensorMeasurement? measure = default;
do {
measure = SensorMeasurement.TakeMeasurement(Name, Intruders);
Average.AddMeasurement(measure);
Debounce.AddMeasurement(measure);
} while (MeasurementHandler(measure));
}
}You can learn more about this requirement in the language reference article on structs .
The Object.T oString()  override doesn't modify any of the values of the struct. Y ou can
add the readonly modifier to that method declaration. The DebounceMeasurement type is
mutable, so you'll need to take care that modifications don't affect copies that are
discarded. The AddMeasurement method does modify the state of the object. It's called
from the Room class, in the TakeMeasurements method. Y ou want those changes to persist
after calling the method. Y ou can change the Room.Debounce property to return a
reference to a single instance of the DebounceMeasurement type:
C#
There are a few changes in the previous example. First, the property is a readonly
property that returns a readonly reference to the instance owned by this room. It's now
backed by a declared field that's initialized when the Room object is instantiated. After
making these changes, you'll update the implementation of AddMeasurement method. It
uses the private backing field, debounce, not the readonly property Debounce. That way,
the changes take place on the single instance created during initialization.
The same technique works with the Average property. First, you modify the
AverageMeasurement type from a class to a struct, and add the readonly modifier on
the ToString method:
C#public DebounceMeasurement () { }
private DebounceMeasurement debounce = new();
public ref readonly  DebounceMeasurement Debounce { get { return ref 
debounce; } }
namespace  IntruderAlert ;
public struct AverageMeasurement
{
private double sumCO2 = 0;
private double sumO2 = 0;
private double sumTemperature = 0;
private double sumHumidity = 0;
private int totalMeasurements = 0;
public AverageMeasurement () { }
public readonly  double CO2 =&gt; sumCO2 / totalMeasurements;
public readonly  double O2 =&gt; sumO2 / totalMeasurements;Then, you modify the Room class following the same technique you used for the
Debounce property. The Average property returns a readonly ref to the private field for
the average measurement. The AddMeasurement method modifies the internal fields.
C#
There's one final change to improve performance. The main program is printing stats for
the room, including the risk assessment:
C#
The call to the generated ToString boxes the enum value. Y ou can avoid that by writing
an override in the Room class that formats the string based on the value of estimated
risk:    public readonly  double Temperature =&gt; sumTemperature /<br />
totalMeasurements;
public readonly  double Humidity =&gt; sumHumidity / totalMeasurements;
public void AddMeasurement (in SensorMeasurement datum )
{
totalMeasurements++;
sumCO2 += datum.CO2;
sumO2 += datum.O2;
sumTemperature += datum.Temperature;
sumHumidity+= datum.Humidity;
}
public readonly  override  string ToString () =&gt; $&quot;&quot;&quot;
Average measurements:
Temp:      {Temperature:F3}
Humidity:  {Humidity:P3}
Oxygen:    {O2:P3}
CO2 (ppm): {CO2:F3}
&quot;&quot;&quot;;
}
private AverageMeasurement average = new();
public  ref readonly  AverageMeasurement Average { get { return ref average;<br />
} }
Avoid boxing
Console.WriteLine( $&quot;Current intruders: {room.Intruders} &quot;);
Console.WriteLine( $&quot;Calculated intruder risk: {room.RiskStatus} &quot;);C#
Then, modify the code in the main program to call this new ToString method:
C#
Run the app using the profiler and look at the updated table for allocations.
You've removed numerous allocations, and provided your app with a performance
boost.
These techniques are low-level performance tuning. They can increase performance in
your application when applied to hot paths, and when you've measured the impact
before and after the changes. In most cases, the cycle you'll follow is:
Measur e allocations : Determine what types are being allocated the most, and when
you can reduce the heap allocations.public override  string ToString () =&gt;
$&quot;Calculated intruder risk: {RiskStatus switch
{
IntruderRisk.None =&gt; &quot;None&quot;,
IntruderRisk.Low =&gt; &quot;Low&quot;,
IntruderRisk.Medium =&gt; &quot;Medium&quot; ,
IntruderRisk.High =&gt; &quot;High&quot;,
IntruderRisk.Extreme =&gt; &quot;Extreme&quot; ,
_ =&gt; &quot;Error!&quot;
}}, Current intruders: {Intruders.ToString()} &quot;;
Console.WriteLine(room.ToString());
Using ref safety in your applicationConvert class t o struct: Many times, types can be converted from a class to a
struct. Your app uses stack space instead of making heap allocations.
Preserve semantics : Converting a class to a struct can impact the semantics for
parameters and return values. Any method that modifies its parameters should
now mark those parameters with the ref modifier. That ensures the modifications
are made to the correct object. Similarly, if a property or method return value
should be modified by the caller, that return should be marked with the ref
modifier.
Avoid copies : When you pass a large struct as a parameter, you can mark the
parameter with the in modifier. Y ou can pass a reference in fewer bytes, and
ensure that the method doesn't modify the original value. Y ou can also return
values by readonly ref to return a reference that can't be modified.
Using these techniques you can improve performance in hot paths of your code.
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide ..NET feedb ack
The .NET documentation is open
source. Provide feedback here.
 Open a documentation issue
 Provide product feedbackThe .NET Compiler Platform SDK
Article •09/15/2021
Compilers build a detailed model of application code as they validate the syntax and
semantics of that code. They use this model to build the executable output from the
source code. The .NET Compiler Platform SDK provides access to this model.
Increasingly, we rely on integrated development environment (IDE) features such as
IntelliSense, refactoring, intelligent rename, &quot;Find all references,&quot; and &quot;Go to definition&quot;
to increase our productivity. W e rely on code analysis tools to improve our code quality,
and code generators to aid in application construction. As these tools get smarter, they
need access to more and more of the model that only compilers create as they process
application code. This is the core mission of the R oslyn APIs: opening up the opaque
boxes and allowing tools and end users to share in the wealth of information compilers
have about our code. Instead of being opaque source-code-in and object-code-out
translators, through R oslyn, compilers become platforms: APIs that you can use for
code-related tasks in your tools and applications.
The .NET Compiler Platform SDK dramatically lowers the barrier to entry for creating
code focused tools and applications. It creates many opportunities for innovation in
areas such as meta-programming, code generation and transformation, interactive use
of the C# and Visual Basic languages, and embedding of C# and Visual Basic in domain-
specific languages.
The .NET Compiler Platform SDK enables you to build analyzer s and code f ixes that find
and correct coding mistakes. Analyzer s understand the syntax (structure of code) and
semantics to detect practices that should be corrected. Code f ixes provide one or more
suggested fixes for addressing coding mistakes found by analyzers or compiler
diagnostics. T ypically, an analyzer and the associated code fixes are packaged together
in a single project.
Analyzers and code fixes use static analysis to understand code. They do not run the
code or provide other testing benefits. They can, however, point out practices that often
lead to bugs, unmaintainable code, or standard guideline violation.
In addition to analyzers and code fixes, The .NET Compiler Platform SDK also enables
you to build code r efact orings. It also provides a single set of APIs that enable you to
examine and understand a C# or Visual Basic codebase. Because you can use this single
codebase, you can write analyzers and code fixes more easily by leveraging the syntactic.NET Compiler Platform SDK conceptsand semantic analysis APIs provided by the .NET Compiler Platform SDK. Freed from the
large task of replicating the analysis done by the compiler, you can concentrate on the
more focused task of finding and fixing common coding errors for your project or
library.
A smaller benefit is that your analyzers and code fixes are smaller and use much less
memory when loaded in Visual S tudio than they would if you wrote your own codebase
to understand the code in a project. By leveraging the same classes used by the
compiler and Visual S tudio, you can create your own static analysis tools. This means
your team can use analyzers and code fixes without a noticeable impact on the IDE's
performance.
There are three main scenarios for writing analyzers and code fixes:</p>
<ol>
<li>Enfor ce team c oding st andar ds</li>
<li>Provide guidanc e with libr ary packages</li>
<li>Provide gener al guidanc e
Many teams have coding standards that are enforced through code reviews with other
team members. Analyzers and code fixes can make this process much more efficient.
Code reviews happen when a developer shares their work with others on the team. The
developer will have invested all the time needed to complete a new feature before
getting any comments. W eeks may go by while the developer reinforces habits that
don't match the team's practices.
Analyzers run as a developer writes code. The developer gets immediate feedback that
encourages following the guidance immediately. The developer builds habits to write
compliant code as soon as they begin prototyping. When the feature is ready for
humans to review, all the standard guidance has been enforced.
Teams can build analyzers and code fixes that look for the most common practices that
violate team coding practices. These can be installed on each developer's machine to
enforce the standards.Enforce team coding standards
 Tip
Before building your own analyzer, check out the built-in ones. For more
information, see Code-style rules .There is a wealth of libraries available for .NET developers on NuGet. Some of these
come from Microsoft, some from third-party companies, and others from community
members and volunteers. These libraries get more adoption and higher reviews when
developers can succeed with those libraries.
In addition to providing documentation, you can provide analyzers and code fixes that
find and correct common mis-uses of your library. These immediate corrections will help
developers succeed more quickly.
You can package analyzers and code fixes with your library on NuGet. In that scenario,
every developer who installs your NuGet package will also install the analyzer package.
All developers using your library will immediately get guidance from your team in the
form of immediate feedback on mistakes and suggested corrections.
The .NET developer community has discovered, through experience, patterns that work
well and patterns that are best avoided. Several community members have created
analyzers that enforce those recommended patterns. As we learn more, there is always
room for new ideas.
These analyzers can be uploaded to the Visual S tudio Marketplace  and downloaded
by developers using Visual S tudio. Newcomers to the language and the platform learn
accepted practices quickly and become productive earlier in their .NET journey. As these
become more widely used, the community adopts these practices.
The .NET Compiler Platform SDK includes the latest language object models for code
generation, analysis, and refactoring. This section provides a conceptual overview of the
.NET Compiler Platform SDK. Further details can be found in the quickstarts, samples,
and tutorials sections.
You can learn more about the concepts in the .NET Compiler Platform SDK in these five
topics:
Explore code with the syntax visualizer
Understand the compiler API model
Work with syntax
Work with semanticsProvide guidance with library packages
Provide general guidance
Next stepsWork with a workspace
To get started, you'll need to install the .NET Compiler Platform SDK :
There are two different ways to find the .NET Compiler Platform SDK  in the Visual
Studio Installer :
The .NET Compiler Platform SDK is not automatically selected as part of the Visual
Studio extension development workload. Y ou must select it as an optional component.</li>
<li>Run Visual S tudio Installer</li>
<li>Select Modif y</li>
<li>Check the Visual S tudio ext ension dev elopment  workload.</li>
<li>Open the Visual S tudio ext ension dev elopment  node in the summary tree.</li>
<li>Check the box for .NET Compiler Platform SDK . You'll find it last under the
optional components.
Optionally, you'll also want the DGML edit or to display graphs in the visualizer:</li>
<li>Open the Individual components  node in the summary tree.</li>
<li>Check the box for DGML edit or</li>
<li>Run Visual S tudio Installer</li>
<li>Select Modif y</li>
<li>Select the Individual components  tab</li>
<li>Check the box for .NET Compiler Platform SDK . You'll find it at the top under the
Compiler s, build t ools, and runtimes  section.
Optionally, you'll also want the DGML edit or to display graphs in the visualizer:</li>
<li>Check the box for DGML edit or. You'll find it under the Code t ools section.Installation instructions - Visual Studio Installer
Install using the Visual Studio Installer - Workloads view
Install using the Visual Studio Installer - Individual
components tabUnderstand the .NET Compiler Platform
SDK mo del
Article •09/15/2021
Compilers process the code you write following structured rules that often differ from
the way humans read and understand code. A basic understanding of the model used
by compilers is essential to understanding the APIs you use when building R oslyn-based
tools.
The .NET Compiler Platform SDK exposes the C# and Visual Basic compilers' code
analysis to you as a consumer by providing an API layer that mirrors a traditional
compiler pipeline.
Each phase of this pipeline is a separate component. First, the parse phase tokenizes
and parses source text into syntax that follows the language grammar. Second, the
declaration phase analyzes source and imported metadata to form named symbols.
Next, the bind phase matches identifiers in the code to symbols. Finally, the emit phase
emits an assembly with all the information built up by the compiler.
Corresponding to each of those phases, the .NET Compiler Platform SDK exposes an
object model that allows access to the information at that phase. The parsing phase
exposes a syntax tree, the declaration phase exposes a hierarchical symbol table, the
binding phase exposes the result of the compiler's semantic analysis, and the emit phase
is an API that produces IL byte codes.Compiler pipeline functional areasEach compiler combines these components together as a single end-to-end whole.
These APIs are the same ones used by Visual S tudio. For instance, the code outlining
and formatting features use the syntax trees, the Object Br owser , and navigation
features use the symbol table, refactorings and Go to Definition  use the semantic
model, and Edit and Continue  uses all of these, including the Emit API.
The .NET compiler SDK consists of several layers of APIs: compiler APIs, diagnostic APIs,
scripting APIs, and workspaces APIs.
The compiler layer contains the object models that correspond to information exposed
at each phase of the compiler pipeline, both syntactic and semantic. The compiler layer
also contains an immutable snapshot of a single invocation of a compiler, including
assembly references, compiler options, and source code files. There are two distinct APIs
that represent the C# language and the Visual Basic language. The two APIs are similar
in shape but tailored for high-fidelity to each individual language. This layer has no
dependencies on Visual S tudio components.
As part of its analysis, the compiler may produce a set of diagnostics covering
everything from syntax, semantic, and definite assignment errors to various warnings
and informational diagnostics. The Compiler API layer exposes diagnostics through anAPI layers
Compiler APIs
Diagnostic APIsextensible API that allows user-defined analyzers to be plugged into the compilation
process. It allows user-defined diagnostics, such as those produced by tools like
StyleCop, to be produced alongside compiler-defined diagnostics. Producing
diagnostics in this way has the benefit of integrating naturally with tools such as
MSBuild and Visual S tudio, which depend on diagnostics for experiences such as halting
a build based on policy and showing live squiggles in the editor and suggesting code
fixes.
Hosting and scripting APIs are built on top of the compiler layer. Y ou can use the
scripting APIs to run code snippets and accumulate a runtime execution context. The C#
interactive REPL (R ead-Evaluate-Print Loop) uses these APIs. The REPL enables you to
use C# as a scripting language, running the code interactively as you write it.
The W orkspaces layer contains the W orkspace API, which is the starting point for doing
code analysis and refactoring over entire solutions. It assists you in organizing all the
information about the projects in a solution into a single object model, offering you
direct access to the compiler layer object models without needing to parse files,
configure options, or manage project-to-project dependencies.
In addition, the W orkspaces layer surfaces a set of APIs used when implementing code
analysis and refactoring tools that function within a host environment like the Visual
Studio IDE. Examples include the Find All R eferences, Formatting, and Code Generation
APIs.
This layer has no dependencies on Visual S tudio components.Scripting APIs
Workspaces APIs
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide ..NET feedb ack
The .NET documentation is open
source. Provide feedback here.
 Open a documentation issue
 Provide product feedbackWork with syntax
Article •09/15/2021
The syntax tree is a fundamental immutable data structure exposed by the compiler
APIs. These trees represent the lexical and syntactic structure of source code. They serve
two important purposes:
To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to
see and process the syntactic structure of source code in a user's project.
To enable tools - such as refactorings and an IDE - to create, modify, and rearrange
source code in a natural manner without having to use direct text edits. By creating
and manipulating trees, tools can easily create and rearrange source code.
Syntax trees are the primary structure used for compilation, code analysis, binding,
refactoring, IDE features, and code generation. No part of the source code is understood
without it first being identified and categorized into one of many well-known structural
language elements.
Syntax trees have three key attributes:
They hold all the source information in full fidelity. Full fidelity means that the
syntax tree contains every piece of information found in the source text, every
grammatical construct, every lexical token, and everything else in between,
including white space, comments, and preprocessor directives. For example, each
literal mentioned in the source is represented exactly as it was typed. S yntax trees
also capture errors in source code when the program is incomplete or malformed
by representing skipped or missing tokens.
They can produce the exact text that they were parsed from. From any syntax
node, it's possible to get the text representation of the subtree rooted at that
node. This ability means that syntax trees can be used as a way to construct and
edit source text. By creating a tree you have, by implication, created the equivalentSyntax trees
７ Note
RoslynQuot er is an open-source tool that shows the syntax factory API calls used
to construct a program's syntax tree. T o try it out live, see
http://r oslynquot er.azur ewebsit es.net .
text, and by making a new tree out of changes to an existing tree, you have
effectively edited the text.
They are immutable and thread-safe. After a tree is obtained, it's a snapshot of the
current state of the code and never changes. This allows multiple users to interact
with the same syntax tree at the same time in different threads without locking or
duplication. Because the trees are immutable and no modifications can be made
directly to a tree, factory methods help create and modify syntax trees by creating
additional snapshots of the tree. The trees are efficient in the way they reuse
underlying nodes, so a new version can be rebuilt fast and with little extra memory.
A syntax tree is literally a tree data structure, where non-terminal structural elements
parent other elements. Each syntax tree is made up of nodes, tokens, and trivia.
Syntax nodes are one of the primary elements of syntax trees. These nodes represent
syntactic constructs such as declarations, statements, clauses, and expressions. Each
category of syntax nodes is represented by a separate class derived from
Microsoft.CodeAnalysis.S yntaxNode . The set of node classes is not extensible.
All syntax nodes are non-terminal nodes in the syntax tree, which means they always
have other nodes and tokens as children. As a child of another node, each node has a
parent node that can be accessed through the SyntaxNode.P arent  property. Because
nodes and trees are immutable, the parent of a node never changes. The root of the
tree has a null parent.
Each node has a SyntaxNode.ChildNodes()  method, which returns a list of child nodes in
sequential order based on their position in the source text. This list does not contain
tokens. Each node also has methods to examine Descendants, such as
DescendantNodes , DescendantT okens , or DescendantT rivia - that represent a list of all
the nodes, tokens, or trivia that exist in the subtree rooted by that node.
In addition, each syntax node subclass exposes all the same children through strongly
typed properties. For example, a BinaryExpressionS yntax  node class has three additional
properties specific to binary operators: Left, OperatorT oken , and Right . The type of Left
and Right  is ExpressionS yntax , and the type of OperatorT oken  is SyntaxT oken .
Some syntax nodes have optional children. For example, an IfStatementS yntax  has an
optional ElseClauseS yntax . If the child is not present, the property returns null.Syntax nodes
Syntax tokensSyntax tokens are the terminals of the language grammar, representing the smallest
syntactic fragments of the code. They are never parents of other nodes or tokens. S yntax
tokens consist of keywords, identifiers, literals, and punctuation.
For efficiency purposes, the SyntaxT oken  type is a CLR value type. Therefore, unlike
syntax nodes, there is only one structure for all kinds of tokens with a mix of properties
that have meaning depending on the kind of token that is being represented.
For example, an integer literal token represents a numeric value. In addition to the raw
source text the token spans, the literal token has a Value property that tells you the
exact decoded integer value. This property is typed as Object  because it may be one of
many primitive types.
The ValueT ext property tells you the same information as the Value property; however
this property is always typed as String . An identifier in C# source text may include
Unicode escape characters, yet the syntax of the escape sequence itself is not
considered part of the identifier name. So although the raw text spanned by the token
does include the escape sequence, the ValueT ext property does not. Instead, it includes
the Unicode characters identified by the escape. For example, if the source text contains
an identifier written as \u03C0, then the ValueT ext property for this token will return π.
Syntax trivia represent the parts of the source text that are largely insignificant for
normal understanding of the code, such as white space, comments, and preprocessor
directives. Like syntax tokens, trivia are value types. The single
Microsoft.CodeAnalysis.S yntaxT rivia type is used to describe all kinds of trivia.
Because trivia are not part of the normal language syntax and can appear anywhere
between any two tokens, they are not included in the syntax tree as a child of a node.
Yet, because they are important when implementing a feature like refactoring and to
maintain full fidelity with the source text, they do exist as part of the syntax tree.
You can access trivia by inspecting a token's SyntaxT oken.LeadingT rivia or
SyntaxT oken.T railingT rivia collections. When source text is parsed, sequences of trivia are
associated with tokens. In general, a token owns any trivia after it on the same line up to
the next token. Any trivia after that line is associated with the following token. The first
token in the source file gets all the initial trivia, and the last sequence of trivia in the file
is tacked onto the end-of-file token, which otherwise has zero width.
Unlike syntax nodes and tokens, syntax trivia do not have parents. Y et, because they are
part of the tree and each is associated with a single token, you may access the token it isSyntax triviaassociated with using the SyntaxT rivia.T oken  property.
Each node, token, or trivia knows its position within the source text and the number of
characters it consists of. A text position is represented as a 32-bit integer, which is a
zero-based char index. A TextSpan  object is the beginning position and a count of
characters, both represented as integers. If TextSpan  has a zero length, it refers to a
location between two characters.
Each node has two TextSpan  properties: Span  and FullSpan .
The Span  property is the text span from the start of the first token in the node's subtree
to the end of the last token. This span does not include any leading or trailing trivia.
The FullSpan  property is the text span that includes the node's normal span, plus the
span of any leading or trailing trivia.
For example:
C#
The statement node inside the block has a span indicated by the single vertical bars (|). It
includes the characters throw new Exception(&quot;Not right.&quot;);. The full span is indicated
by the double vertical bars (||). It includes the same characters as the span and the
characters associated with the leading and trailing trivia.
Each node, token, or trivia has a SyntaxNode.RawKind  property, of type System.Int32 ,
that identifies the exact syntax element represented. This value can be cast to a
language-specific enumeration. Each language, C# or Visual Basic, has a single
SyntaxKind enumeration ( Microsoft.CodeAnalysis.CSharp.S yntaxKind  and
Microsoft.CodeAnalysis.VisualBasic.S yntaxKind , respectively) that lists all the possible
nodes, tokens, and trivia elements in the grammar. This conversion can be doneSpans
if (x &gt; 3)
{
||        // this is bad
|throw new Exception( &quot;Not right.&quot; );|  // better exception?||
}
Kindsautomatically by accessing the CSharpExtensions.Kind  or VisualBasicExtensions.Kind
extension methods.
The RawKind  property allows for easy disambiguation of syntax node types that share
the same node class. For tokens and trivia, this property is the only way to distinguish
one type of element from another.
For example, a single BinaryExpressionS yntax  class has Left, OperatorT oken , and Right  as
children. The Kind property distinguishes whether it is an AddExpression ,
SubtractExpression , or MultiplyExpression  kind of syntax node.
Even when the source text contains syntax errors, a full syntax tree that is round-
trippable to the source is exposed. When the parser encounters code that does not
conform to the defined syntax of the language, it uses one of two techniques to create a
syntax tree:
If the parser expects a particular kind of token but does not find it, it may insert a
missing token into the syntax tree in the location that the token was expected. A
missing token represents the actual token that was expected, but it has an empty
span, and its SyntaxNode.IsMissing  property returns true.
The parser may skip tokens until it finds one where it can continue parsing. In this
case, the skipped tokens are attached as a trivia node with the kind
SkippedT okensT rivia. Tip
It's recommended to check kinds using IsKind  (for C#) or IsKind  (for VB) extension
methods.
Errors
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For.NET feedb ack
The .NET documentation is open
source. Provide feedback here.
 Open a documentation issue
 Provide product feedbackmore information, see our
contributor guide .Work with semantics
Article •09/15/2021
Syntax trees  represent the lexical and syntactic structure of source code. Although this
information alone is enough to describe all the declarations and logic in the source, it is
not enough information to identify what is being referenced. A name may represent:
a type
a field
a method
a local variable
Although each of these is uniquely different, determining which one an identifier
actually refers to often requires a deep understanding of the language rules.
There are program elements represented in source code, and programs can also refer to
previously compiled libraries, packaged in assembly files. Although no source code, and
therefore no syntax nodes or trees, are available for assemblies, programs can still refer
to elements inside them.
For those tasks, you need the Semantic model .
In addition to a syntactic model of the source code, a semantic model encapsulates the
language rules, giving you an easy way to correctly match identifiers with the correct
program element being referenced.
A compilation is a representation of everything needed to compile a C# or Visual Basic
program, which includes all the assembly references, compiler options, and source files.
Because all this information is in one place, the elements contained in the source code
can be described in more detail. The compilation represents each declared type,
member, or variable as a symbol. The compilation contains a variety of methods that
help you find and relate the symbols that have either been declared in the source code
or imported as metadata from an assembly.
Similar to syntax trees, compilations are immutable. After you create a compilation, it
cannot be changed by you or anyone else you might be sharing it with. However, you
can create a new compilation from an existing compilation, specifying a change as you
do so. For example, you might create a compilation that is the same in every way as anCompilationexisting compilation, except it may include an additional source file or assembly
reference.
A symbol represents a distinct element declared by the source code or imported from
an assembly as metadata. Every namespace, type, method, property, field, event,
parameter, or local variable is represented by a symbol.
A variety of methods and properties on the Compilation  type help you find symbols. For
example, you can find a symbol for a declared type by its common metadata name. Y ou
can also access the entire symbol table as a tree of symbols rooted by the global
namespace.
Symbols also contain additional information that the compiler determines from the
source or metadata, such as other referenced symbols. Each kind of symbol is
represented by a separate interface derived from ISymbol , each with its own methods
and properties detailing the information the compiler has gathered. Many of these
properties directly reference other symbols. For example, the
IMethodS ymbol.R eturnT ype property tells you the actual type symbol that the method
returns.
Symbols present a common representation of namespaces, types, and members,
between source code and metadata. For example, a method that was declared in source
code and a method that was imported from metadata are both represented by an
IMethodS ymbol  with the same properties.
Symbols are similar in concept to the CLR type system as represented by the
System.R eflection  API, yet they are richer in that they model more than just types.
Namespaces, local variables, and labels are all symbols. In addition, symbols are a
representation of language concepts, not CLR concepts. There is a lot of overlap, but
there are many meaningful distinctions as well. For instance, an iterator method in C# or
Visual Basic is a single symbol. However, when the iterator method is translated to CLR
metadata, it is a type and multiple methods.
A semantic model represents all the semantic information for a single source file. Y ou
can use it to discover the following:
The symbols referenced at a specific location in source.
The resultant type of any expression.Symbols
Semantic modelAll diagnostics, which are errors and warnings.
How variables flow in and out of regions of source.
The answers to more speculative questions.Work with a workspace
Article •09/15/2021
The Worksp aces layer is the starting point for doing code analysis and refactoring over
entire solutions. Within this layer, the W orkspace API assists you in organizing all the
information about the projects in a solution into a single object model, offering you
direct access to compiler layer object models like source text, syntax trees, semantic
models, and compilations without needing to parse files, configure options, or manage
inter-project dependencies.
Host environments, like an IDE, provide a workspace for you corresponding to the open
solution. It is also possible to use this model outside of an IDE by simply loading a
solution file.
A workspace is an active representation of your solution as a collection of projects, each
with a collection of documents. A workspace is typically tied to a host environment that
is constantly changing as a user types or manipulates properties.
The Workspace  provides access to the current model of the solution. When a change in
the host environment occurs, the workspace fires corresponding events, and the
Workspace.CurrentSolution  property is updated. For example, when the user types in a
text editor corresponding to one of the source documents, the workspace uses an event
to signal that the overall model of the solution has changed and which document was
modified. Y ou can then react to those changes by analyzing the new model for
correctness, highlighting areas of significance, or making a suggestion for a code
change.
You can also create stand-alone workspaces that are disconnected from the host
environment or used in an application that has no host environment.
Although a workspace may change every time a key is pressed, you can work with the
model of the solution in isolation.
A solution is an immutable model of the projects and documents. This means that the
model can be shared without locking or duplication. After you obtain a solution instance
from the Workspace.CurrentSolution  property, that instance will never change. However,Workspace
Solutio ns, projects, and documentslike with syntax trees and compilations, you can modify solutions by constructing new
instances based on existing solutions and specific changes. T o get the workspace to
reflect your changes, you must explicitly apply the changed solution back to the
workspace.
A project is a part of the overall immutable solution model. It represents all the source
code documents, parse and compilation options, and both assembly and project-to-
project references. From a project, you can access the corresponding compilation
without needing to determine project dependencies or parse any source files.
A document is also a part of the overall immutable solution model. A document
represents a single source file from which you can access the text of the file, the syntax
tree, and the semantic model.
The following diagram is a representation of how the W orkspace relates to the host
environment, tools, and how edits are made.
Roslyn exposes a set of compiler APIs and W orkspaces APIs that provides rich
information about your source code and that has full fidelity with the C# and Visual
Basic languages. The .NET Compiler Platform SDK dramatically lowers the barrier to
entry for creating code-focused tools and applications. It creates many opportunities for
innovation in areas such as meta-programming, code generation and transformation,
interactive use of the C# and Visual Basic languages, and embedding of C# and Visual
Basic in domain-specific languages.SummaryExplore code with the Roslyn syntax
visualizer in Visual Studio
Article •10/11/2022
This article provides an overview of the S yntax Visualizer tool that ships as part of the
.NET Compiler Platform (&quot;R oslyn&quot;) SDK. The S yntax Visualizer is a tool window that helps
you inspect and explore syntax trees. It's an essential tool to understand the models for
code you want to analyze. It's also a debugging aid when you develop your own
applications using the .NET Compiler Platform (“R oslyn”) SDK. Open this tool as you
create your first analyzers. The visualizer helps you understand the models used by the
APIs. Y ou can also use tools like SharpLab  or LINQP ad  to inspect code and
understand syntax trees.
There are two different ways to find the .NET Compiler Platform SDK  in the Visual
Studio Installer :
The .NET Compiler Platform SDK is not automatically selected as part of the Visual
Studio extension development workload. Y ou must select it as an optional component.</li>
<li>Run Visual S tudio Installer</li>
<li>Select Modif y</li>
<li>Check the Visual S tudio ext ension dev elopment  workload.</li>
<li>Open the Visual S tudio ext ension dev elopment  node in the summary tree.</li>
<li>Check the box for .NET Compiler Platform SDK . You'll find it last under the
optional components.
Optionally, you'll also want the DGML edit or to display graphs in the visualizer:</li>
<li>Open the Individual components  node in the summary tree.</li>
<li>Check the box for DGML edit or</li>
<li>Run Visual S tudio Installer
Installation instructions - Visual Studio Installer
Install using the Visual Studio Installer - Workloads view
Install using the Visual Studio Installer - Individual
components tab2. Select Modif y</li>
<li>Select the Individual components  tab</li>
<li>Check the box for .NET Compiler Platform SDK . You'll find it at the top under the
Compiler s, build t ools, and runtimes  section.
Optionally, you'll also want the DGML edit or to display graphs in the visualizer:</li>
<li>Check the box for DGML edit or. You'll find it under the Code t ools section.
Familiarize yourself with the concepts used in the .NET Compiler Platform SDK by
reading the overview  article. It provides an introduction to syntax trees, nodes, tokens,
and trivia.
The Syntax Visualizer  enables inspection of the syntax tree for the C# or Visual Basic
code file in the current active editor window inside the Visual S tudio IDE. The visualizer
can be launched by clicking on View  &gt; Other Windows  &gt; Syntax Visualizer . You can
also use the Quick Launch  toolbar in the upper right corner. T ype &quot;syntax&quot;, and the
command to open the Syntax Visualizer  should appear.
This command opens the S yntax Visualizer as a floating tool window. If you don't have a
code editor window open, the display is blank, as shown in the following figure.Syntax VisualizerDock this tool window at a convenient location inside Visual S tudio, such as the left side.
The Visualizer shows information about the current code file.
Create a new project using the File &gt; New Pr oject  command. Y ou can create either a
Visual Basic or C# project. When Visual S tudio opens the main code file for this project,
the visualizer displays the syntax tree for it. Y ou can open any existing C# / Visual Basic
file in this Visual S tudio instance, and the visualizer displays that file's syntax tree. If you
have multiple code files open inside Visual S tudio, the visualizer displays the syntax tree
for the currently active code file, (the code file that has keyboard focus.)
C#As shown in the preceding images, the visualizer tool window displays the syntax tree at
the top and a property grid at the bottom. The property grid displays the properties of
the item that is currently selected in the tree, including the .NET Type and the Kind
(SyntaxKind) of the item.
Syntax trees comprise three types of items – nodes , tokens, and trivia. You can read more
about these types in the Work with syntax  article. Items of each type are represented
using a different color. Click on the ‘Legend’ button for an overview of the colors used.
Each item in the tree also displays its own span. The span is the indices (the starting and
ending position) of that node in the text file. In the preceding C# example, the selected
“UsingK eyword [0..5)” token has a Span that is five characters wide, [0..5). The &quot;[..)&quot;
notation means that the starting index is part of the span, but the ending index is not.
There are two ways to navigate the tree:
Expand or click on items in the tree. The visualizer automatically selects the text
corresponding to this item’s span in the code editor.
Click or select text in the code editor. In the preceding Visual Basic example, if you
select the line containing &quot;Module Module1&quot; in the code editor, the visualizer
automatically navigates to the corresponding ModuleS tatement node in the tree.
The visualizer highlights the item in the tree whose span best matches the span of the
text selected in the editor.The visualizer refreshes the tree to match modifications in the active code file. Add a call
to Console.WriteLine() inside Main(). As you type, the visualizer refreshes the tree.
Pause typing once you have typed Console.. The tree has some items colored in pink. At
this point, there are errors (also referred to as ‘Diagnostics’) in the typed code. These
errors are attached to nodes, tokens, and trivia in the syntax tree. The visualizer shows
you which items have errors attached to them highlighting the background in pink. Y ou
can inspect the errors on any item colored pink by hovering over the item. The visualizer
only displays syntactic errors (those errors related to the syntax of the typed code); it
doesn't display any semantic errors.
Right click on any item in the tree and click on View Dir ected Syntax Graph .
The visualizer displays a graphical representation of the subtree rooted at the
selected item. T ry these steps for the MethodDeclaration  node corresponding to
the Main() method in the C# example. The visualizer displays a syntax graph that
looks as follows:
The syntax graph viewer has an option to display a legend for its coloring scheme. Y ou
can also hover over individual items in the syntax graph with the mouse to view the
properties corresponding to that item.
You can view syntax graphs for different items in the tree repeatedly and the graphs will
always be displayed in the same window inside Visual S tudio. Y ou can dock this windowSyntax Graphs
C#at a convenient location inside Visual S tudio so that you don’t have to switch between
tabs to view a new syntax graph. The bottom, below code editor windows, is often
convenient.
Here is the docking layout to use with the visualizer tool window and the syntax graph
window:
Another option is to put the syntax graph window on a second monitor, in a dual
monitor setup.
The S yntax Visualizer enables rudimentary inspection of symbols and semantic
information. T ype double x = 1 + 1; inside Main() in the C# example. Then, select the
expression 1 + 1 in the code editor window. The visualizer highlights the
AddExpr ession  node in the visualizer. Right click on this AddExpr ession  and click on
View S ymbol (if any) . Notice that most of the menu items have the &quot;if any&quot; qualifier. The
Syntax Visualizer inspects properties of a Node, including properties that may not be
present for all nodes.
The property grid in the visualizer updates as shown in the following figure: The symbol
for the expression is a SynthesizedIntrinsicOperat orSymbol  with Kind = Method .Inspecting semanticsTry View T ypeS ymbol (if any)  for the same AddExpr ession  node. The property grid in
the visualizer updates as shown in the following figure, indicating that the type of the
selected expression is Int32.
Try View Conv erted TypeS ymbol (if any)  for the same AddExpr ession  node. The
property grid updates indicating that although the type of the expression is Int32, theconverted type of the expression is Double as shown in the following figure. This node
includes converted type symbol information because the Int32 expression occurs in a
context where it must be converted to a Double. This conversion satisfies the Double
type specified for the variable x on the left-hand side of the assignment operator.
Finally, try View Constant V alue (if any)  for the same AddExpr ession  node. The property
grid shows that the value of the expression is a compile time constant with value 2.The preceding example can also be replicated in Visual Basic. T ype Dim x As Double = 1</li>
</ol>
<ul>
<li>1 in a Visual Basic file. Select the expression 1 + 1 in the code editor window. The
visualizer highlights the corresponding AddExpr ession  node in the visualizer. R epeat the
preceding steps for this AddExpr ession  and you should see identical results.
Examine more code in Visual Basic. Update your main Visual Basic file with the following
code:
VB
This code introduces an alias named C that maps to the type System.Console at the top
of the file and uses this alias inside Main(). Select the use of this alias, the C in
C.WriteLine(), inside the Main() method. The visualizer selects the corresponding
IdentifierName  node in the visualizer. Right-click this node and click on View S ymbol (if
any). The property grid indicates that this identifier is bound to the type System.Console
as shown in the following figure:Imports C = System.Console<br />
Module Program<br />
Sub Main(args As String()) 
C.WriteLine()<br />
End Sub 
End Module Try View AliasS ymbol (if any)  for the same IdentifierName  node. The property grid
indicates the identifier is an alias with name C that is bound to the System.Console
target. In other words, the property grid provides information regarding the
AliasS ymbol  corresponding to the identifier C.
Inspect the symbol corresponding to any declared type, method, property. Select the
corresponding node in the visualizer and click on View S ymbol (if any) . Select themethod Sub Main(), including the body of the method. Click on View S ymbol (if any)
for the corresponding SubBlock  node in the visualizer. The property grid shows the
MethodS ymbol  for this SubBlock  has name Main with return type Void.
The above Visual Basic examples can be easily replicated in C#. T ype using C =
System.Console; in place of Imports C = System.Console for the alias. The preceding
steps in C# yield identical results in the visualizer window.
Semantic inspection operations are only available on nodes. They are not available on
tokens or trivia. Not all nodes have interesting semantic information to inspect. When a
node doesn't have interesting semantic information, clicking on View * S ymbol (if any)
shows a blank property grid.
You can read more about APIs for performing semantic analysis in the Work with
semantics  overview document.
You can close the visualizer window when you are not using it to examine source code.
The syntax visualizer updates its display as you navigate through code, editing and
changing the source. It can get distracting when you are not using it.Closing the syntax visualizerSource Gen erators
Article •06/25/2023
This article provides an overview of Source Generators that ships as part of the .NET
Compiler Platform (&quot;R oslyn&quot;) SDK. Source Generators let C# developers inspect user
code as it is being compiled. The generator can create new C# source files on the fly
that are added to the user's compilation. In this way, you have code that runs during
compilation. It inspects your program to produce additional source files that are
compiled together with the rest of your code.
A Source Generator is a new kind of component that C# developers can write that lets
you do two major things:</li>
</ul>
<ol>
<li>Retrieve a compilation object  that represents all user code that is being compiled.
This object can be inspected, and you can write code that works with the syntax
and semantic models for the code being compiled, just like with analyzers today.</li>
<li>Generate C# source files that can be added to a compilation object during
compilation. In other words, you can provide additional source code as input to a
compilation while the code is being compiled.
When combined, these two things are what make Source Generators so useful. Y ou can
inspect user code with all of the rich metadata that the compiler builds up during
compilation. Y our generator then emits C# code back into the same compilation that is
based on the data you've analyzed. If you're familiar with R oslyn Analyzers, you can
think of Source Generators as analyzers that can emit C# source code.
Source generators run as a phase of compilation visualized below:
A Source Generator is a .NET S tandard 2.0 assembly that is loaded by the compiler along
with any analyzers. It's usable in environments where .NET S tandard components can be
loaded and run.
There are three general approaches to inspecting user code and generating information
or code based on that analysis used by technologies today:
Runtime reflection.
Juggling MSBuild tasks.
Intermediate Language (IL) weaving (not discussed in this article).
Source Generators can be an improvement over each approach.
Runtime reflection is a powerful technology that was added to .NET a long time ago.
There are countless scenarios for using it. A common scenario is to perform some
analysis of user code when an app starts up and use that data to generate things.
For example, ASP.NET Core uses reflection when your web service first runs to discover
constructs you've defined so that it can &quot;wire up&quot; things like controllers and razor pages.
Although this enables you to write straightforward code with powerful abstractions, it
comes with a performance penalty at run time: when your web service or app first starts
up, it can’t accept any requests until all the runtime reflection code that discovers
information about your code is finished running. Although this performance penalty
isn't enormous, it's somewhat of a fixed cost that you can’t improve yourself in your own
app.
With a Source Generator, the controller discovery phase of startup could instead happen
at compile time. A generator can analyze your source code and emit the code it needs
to &quot;wire up&quot; your app. Using source generators could result in some faster startup times,
since an action happening at run time today could get pushed into compile time.
Source Generators can improve performance in ways that aren't limited to reflection at
run time to discover types as well. Some scenarios involve calling the MSBuild C# task） Impor tant
Currently only .NET S tandard 2.0 assemblies can be used as Source Generators.
Common scenarios
Runtime reflection
Juggling MSBuild tasks(called CSC) multiple times so they can inspect data from a compilation. As you might
imagine, calling the compiler more than once affects the total time it takes to build your
app. W e're investigating how Source Generators can be used to obviate the need for
juggling MSBuild tasks like this, since Source generators don't just offer some
performance benefits, but also allows tools to operate at the right level of abstraction.
Another capability Source Generators can offer is obviating the use of some &quot;stringly
typed&quot; APIs, such as how ASP.NET Core routing between controllers and razor pages
work. With a Source Generator, routing can be strongly typed with the necessary strings
being generated as a compile-time detail. This would reduce the number of times a
mistyped string literal leads to a request not hitting the correct controller.
In this guide, you'll explore the creation of a source generator using the
ISourceGenerator  API.</li>
<li>Create a .NET console application. This example uses .NET 6.</li>
<li>Replace the Program class with the following code. The following code doesn't use
top level statements. The classic form is required because this first source
generator writes a partial method in that Program class:
C#</li>
<li>Next, we'll create a source generator project that will implement the partial void
HelloFrom method counterpart.Get started with source generators
namespace  ConsoleApp ;
partial class Program
{
static void Main(string[] args)
{
HelloFrom( &quot;Generated Code&quot; );
}
static partial void HelloFrom (string name);
}
７ Note
You can run this sample as-is, but nothing will happen yet.4. Create a .NET standard library project that targets the netstandard2.0 target
framework moniker (TFM). Add the NuGet packages
Microsoft.CodeAnalysis.Analyzer s and Microsoft.CodeAnalysis.CSharp :
XML</li>
<li>Create a new C# file named HelloSour ceGener ator.cs that specifies your own Source
Generator like so:
C#<Project Sdk="Microsoft.NET.Sdk" >
<PropertyGroup >
<TargetFramework >netstandard2.0 </TargetFramework >
</PropertyGroup >
<ItemGroup >
<PackageReference  Include="Microsoft.CodeAnalysis.CSharp"  
Version="4.6.0" PrivateAssets ="all" />
<PackageReference  Include="Microsoft.CodeAnalysis.Analyzers"  
Version="3.3.4" PrivateAssets ="all" />
</ItemGroup >
</Project>
 Tip
The source generator project needs to target the netstandard2.0 TFM,
otherwise it will not work.
using Microsoft.CodeAnalysis;
namespace  SourceGenerator
{
[Generator ]
public class HelloSourceGenerator  : ISourceGenerator
{
public void Execute(GeneratorExecutionContext context )
{
// Code generation goes here
}
public void Initialize (GeneratorInitializationContext context )
{
// No initialization required for this one
}A source generator needs to both implement the
Microsoft.CodeAnalysis.ISourceGenerator  interface, and have the
Microsoft.CodeAnalysis.GeneratorAttribute . Not all source generators require
initialization, and that is the case with this example implementation—where
ISourceGenerator.Initialize  is empty.</li>
<li>Replace the contents of the ISourceGenerator.Execute  method, with the following
implementation:
C#    }
}
using Microsoft.CodeAnalysis;
namespace  SourceGenerator
{
[Generator ]
public class HelloSourceGenerator  : ISourceGenerator
{
public void Execute(GeneratorExecutionContext context )
{
// Find the main method
var mainMethod =<br />
context.Compilation.GetEntryPoint(context.CancellationToken);
// Build up the source code
string source = $@&quot;// <auto-generated/>
using System;
namespace {mainMethod.ContainingNamespace.ToDisplayString()}
{{
public static partial class {mainMethod.ContainingType.Name}
{{
static partial void HelloFrom(string name) =&gt;
Console.WriteLine($&quot;&quot;Generator says: Hi from '{{name}}'&quot;&quot;);
}}
}}
&quot;;
var typeName = mainMethod.ContainingType.Name;
// Add the source code to the compilation
context.AddSource( $&quot;{typeName} .g.cs&quot;, source);
}
public void Initialize (GeneratorInitializationContext context )
{
// No initialization required for this one
}From the context object we can access the compilations' entry point, or Main
method. The mainMethod instance is an IMethodS ymbol , and it represents a
method or method-like symbol (including constructor, destructor, operator, or
property/event accessor). The Microsoft.CodeAnalysis.Compilation.GetEntryP oint
method returns the IMethodS ymbol  for the program's entry point. Other methods
enable you to find any method symbol in a project. From this object, we can
reason about the containing namespace (if one is present) and the type. The
source in this example is an interpolated string that templates the source code to
be generated, where the interpolated holes are filled with the containing
namespace and type information. The source is added to the context with a hint
name. For this example, the generator creates a new generated source file that
contains an implementation of the partial method in the console application. Y ou
can write source generators to add any source you'd like.</li>
<li>We now have a functioning generator, but need to connect it to our console
application. Edit the original console application project and add the following,
replacing the project path with the one from the .NET S tandard project you created
above:
XML
This new reference isn't a traditional project reference, and has to be manually
edited to include the OutputItemType and ReferenceOutputAssembly attributes. For    }
}
 Tip
The hintName parameter from the Generat orExecutionCont ext.AddSour ce
method can be any unique name. It's common to provide an explicit C# file
extension such as &quot;.g.cs&quot; or &quot;.generated.cs&quot; for the name. The file name
helps identify the file as being source generated.</li>
</ol>
<!-- Add this as a new ItemGroup, replacing paths and names  
appropriately -->
<ItemGroup >
    <ProjectReference  Include="..\PathTo\SourceGenerator.csproj"
                      OutputItemType ="Analyzer"
                      ReferenceOutputAssembly ="false" />
</ItemGroup >more information on the OutputItemType and ReferenceOutputAssembly attributes
of ProjectReference, see Common MSBuild project items: ProjectR eference .
8. Now, when you run the console application, you should see that the generated
code gets run and prints to the screen. The console application itself doesn't
implement the HelloFrom method, instead it's source generated during
compilation from the Source Generator project. The following text is an example
output from the application:
Console
9. If you're using Visual S tudio, you can see the source generated files. From the
Solution Explor er window, expand the Dependencies  > Analyzer s >
Sour ceGenerat or > Sour ceGenerat or.HelloSour ceGenerat or, and double-click the
Program.g.cs  file.
When you open this generated file, Visual S tudio will indicate that the file is auto-
generated and that it can't be edited.Generator says: Hi from 'Generated Code'
７ Note
You might need to restart Visual S tudio to see IntelliSense and get rid of
errors as the tooling experience is actively being improved.
10. You can also set build properties to save the generated file and control where the
generated files are stored. In the console application's project file, add the
<EmitCompilerGeneratedFiles> element to a <PropertyGroup>, and set its value to
true. Build your project again. Now, the generated files are created under
obj/Debug/net6.0/gener ated/Sour ceGener ator/Sour ceGener ator.HelloSour ceGener at
or. The components of the path map to the build configuration, target framework,
source generator project name, and fully qualified type name of the generator. Y ou
can choose a more convenient output folder by adding the
<CompilerGeneratedFilesOutputPath> element to the application's project file.
The Source Generators Cookbook  goes over some of these examples with some
recommended approaches to solving them. Additionally, we have a set of samples
available on GitHub  that you can try on your own.
You can learn more about Source Generators in these articles:
Source Generators design document
Source Generators cookbook

Next steps
Choose diagnostic IDs
Article •11/03/2023
A diagnostic ID is the string associated with a given diagnostic, such as a compiler error
or a diagnostic that is produced by an analyzer.
The IDs are surfaced from various APIs, such as:
DiagnosticDescriptor.Id
ObsoleteAttribute.DiagnosticId
ExperimentalAttribute.DiagnosticId
Diagnostic IDs are also used as identifiers in source, for example, from #pragma warning
disable  or .editorconfig  files.
Diagnostic IDs should be unique
Diagnostic IDs must be legal identifiers in C#
Diagnostic IDs should be less than 15 characters long
Diagnostic IDs should be of the form <PREFIX><number>
The prefix is specific to your project
The number represents the specific diagnostic
Don't limit your prefix to two-characters (such as CSXXXand CAXXXX). Instead, use a
longer prefix to avoid conflicts. For example, the System.* diagnostics use SYSLIB as
their prefix.Considerations
７ Note
It's a source breaking change to change diagnostic IDs, as existing suppressions
would be ignored if the ID changed.
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review.NET feedb ack
The .NET documentation is open
source. Provide feedback here.
 Open a documentation issueissues and pull requests. For
more information, see our
contributor guide . Provide product feedbackGet started with syntax analysis
Article •09/15/2021
In this tutorial, you'll explore the Syntax API . The S yntax API provides access to the data
structures that describe a C# or Visual Basic program. These data structures have
enough detail that they can fully represent any program of any size. These structures
can describe complete programs that compile and run correctly. They can also describe
incomplete programs, as you write them, in the editor.
To enable this rich expression, the data structures and APIs that make up the S yntax API
are necessarily complex. Let's start with what the data structure looks like for the typical
"Hello W orld" program:
C#
Look at the text of the previous program. Y ou recognize familiar elements. The entire
text represents a single source file, or a compilation unit . The first three lines of that
source file are using dir ectiv es. The remaining source is contained in a namesp ace
declaration . The namespace declaration contains a child class declaration . The class
declaration contains one method declaration .
The S yntax API creates a tree structure with the root representing the compilation unit.
Nodes in the tree represent the using directives, namespace declaration and all the
other elements of the program. The tree structure continues down to the lowest levels:
the string "Hello W orld!" is a string lit eral t oken that is a descendent of an argument .
The S yntax API provides access to the structure of the program. Y ou can query for
specific code practices, walk the entire tree to understand the code, and create new
trees by modifying the existing tree.using System;  
using System.Collections.Generic;
using System.Linq;  
namespace  HelloWorld  
{ 
    class Program 
    { 
        static void Main(string[] args) 
        {  
            Console.WriteLine( "Hello World!" ); 
        }  
    } 
} That brief description provides an overview of the kind of information accessible using
the S yntax API. The S yntax API is nothing more than a formal API that describes the
familiar code constructs you know from C#. The full capabilities include information
about how the code is formatted including line breaks, white space, and indenting.
Using this information, you can fully represent the code as written and read by human
programmers or the compiler. Using this structure enables you to interact with the
source code on a deeply meaningful level. It's no longer text strings, but data that
represents the structure of a C# program.
To get started, you'll need to install the .NET Compiler Platform SDK :
There are two different ways to find the .NET Compiler Platform SDK  in the Visual
Studio Installer :
The .NET Compiler Platform SDK is not automatically selected as part of the Visual
Studio extension development workload. Y ou must select it as an optional component.
1. Run Visual S tudio Installer
2. Select Modif y
3. Check the Visual S tudio ext ension dev elopment  workload.
4. Open the Visual S tudio ext ension dev elopment  node in the summary tree.
5. Check the box for .NET Compiler Platform SDK . You'll find it last under the
optional components.
Optionally, you'll also want the DGML edit or to display graphs in the visualizer:
1. Open the Individual components  node in the summary tree.
2. Check the box for DGML edit or
1. Run Visual S tudio Installer
2. Select Modif y
3. Select the Individual components  tab
4. Check the box for .NET Compiler Platform SDK . You'll find it at the top under the
Compiler s, build t ools, and runtimes  section.Installation instructions - Visual Studio Installer
Install using the Visual Studio Installer - Workloads view
Install using the Visual Studio Installer - Individual
components tabOptionally, you'll also want the DGML edit or to display graphs in the visualizer:
1. Check the box for DGML edit or. You'll find it under the Code t ools section.
You use the S yntax API for any analysis of the structure of C# code. The Syntax API
exposes the parsers, the syntax trees, and utilities for analyzing and constructing syntax
trees. It's how you search code for specific syntax elements or read the code for a
program.
A syntax tree is a data structure used by the C# and Visual Basic compilers to
understand C# and Visual Basic programs. S yntax trees are produced by the same parser
that runs when a project is built or a developer hits F5. The syntax trees have full-fidelity
with the language; every bit of information in a code file is represented in the tree.
Writing a syntax tree to text reproduces the exact original text that was parsed. The
syntax trees are also immutable ; once created a syntax tree can never be changed.
Consumers of the trees can analyze the trees on multiple threads, without locks or other
concurrency measures, knowing the data never changes. Y ou can use APIs to create new
trees that are the result of modifying an existing tree.
The four primary building blocks of syntax trees are:
The Microsoft.CodeAnalysis.S yntaxT ree class, an instance of which represents an
entire parse tree. SyntaxT ree is an abstract class that has language-specific
derivatives. Y ou use the parse methods of the
Microsoft.CodeAnalysis.CSharp.CSharpS yntaxT ree (or
Microsoft.CodeAnalysis.VisualBasic.VisualBasicS yntaxT ree) class to parse text in C#
(or Visual Basic).
The Microsoft.CodeAnalysis.S yntaxNode  class, instances of which represent
syntactic constructs such as declarations, statements, clauses, and expressions.
The Microsoft.CodeAnalysis.S yntaxT oken  structure, which represents an individual
keyword, identifier, operator, or punctuation.
And lastly the Microsoft.CodeAnalysis.S yntaxT rivia structure, which represents
syntactically insignificant bits of information such as the white space between
tokens, preprocessing directives, and comments.
Trivia, tokens, and nodes are composed hierarchically to form a tree that completely
represents everything in a fragment of Visual Basic or C# code. Y ou can see this
structure using the Syntax Visualizer  window. In Visual S tudio, choose View  > Other
Windows  > Syntax Visualizer . For example, the preceding C# source file examined
using the Syntax Visualizer  looks like the following figure:Understanding syntax treesSyntaxNode : Blue | SyntaxT oken: Green | SyntaxT rivia: Red 
By navigating this tree structure, you can find any statement, expression, token, or bit of
white space in a code file.
While you can find anything in a code file using the S yntax APIs, most scenarios involve
examining small snippets of code, or searching for particular statements or fragments.
The two examples that follow show typical uses to browse the structure of code, or
search for single statements.
You can examine the nodes in a syntax tree in two ways. Y ou can traverse the tree to
examine each node, or you can query for specific elements or nodes.Traversing treesYou can see the finished code for this sample in our GitHub repository .
Create a new C# Stand-Alone Code Analysis T ool project:
In Visual S tudio, choose File > New  > Project  to display the New Project dialog.
Under Visual C#  > Extensibility , choose Stand-Alone Code Analysis T ool.
Name your project " SyntaxT reeManualT raversal" and click OK.
You're going to analyze the basic "Hello W orld!" program shown earlier. Add the text for
the Hello W orld program as a constant in your Program class:
C#
Next, add the following code to build the syntax tr ee for the code text in the
programText constant. Add the following line to your Main method:Manual traversal
７ Note
The S yntax T ree types use inheritance to describe the different syntax elements that
are valid at different locations in the program. Using these APIs often means
casting properties or collection members to specific derived types. In the following
examples, the assignment and the casts are separate statements, using explicitly
typed variables. Y ou can read the code to see the return types of the API and the
runtime type of the objects returned. In practice, it's more common to use implicitly
typed variables and rely on API names to describe the type of objects being
examined.
        const string programText =  
@"using System;  
using System.Collections;  
using System.Linq;  
using System.Text;  
namespace HelloWorld  
{ 
    class Program  
    { 
        static void Main(string[] args)  
        {  
            Console.WriteLine(""Hello, World!"");  
        }  
    } 
}"; C#
Those two lines create the tree and retrieve the root node of that tree. Y ou can now
examine the nodes in the tree. Add these lines to your Main method to display some of
the properties of the root node in the tree:
C#
Run the application to see what your code has discovered about the root node in this
tree.
Typically, you'd traverse the tree to learn about the code. In this example, you're
analyzing code you know to explore the APIs. Add the following code to examine the
first member of the root node:
C#
That member is a Microsoft.CodeAnalysis.CSharp.S yntax.NamespaceDeclarationS yntax . It
represents everything in the scope of the namespace HelloWorld declaration. Add the
following code to examine what nodes are declared inside the HelloWorld namespace:
C#
Run the program to see what you've learned.
Now that you know the declaration is a
Microsoft.CodeAnalysis.CSharp.S yntax.ClassDeclarationS yntax , declare a new variable ofSyntaxTree tree = CSharpSyntaxTree.ParseText(programText);  
CompilationUnitSyntax root = tree.GetCompilationUnitRoot();  
WriteLine( $"The tree is a {root.Kind()}  node."); 
WriteLine( $"The tree has {root.Members.Count}  elements in it." ); 
WriteLine( $"The tree has {root.Usings.Count}  using statements. They are:" ); 
foreach (UsingDirectiveSyntax element in root.Usings)  
    WriteLine( $"\t{element.Name} "); 
MemberDeclarationSyntax firstMember = root.Members[ 0]; 
WriteLine( $"The first member is a {firstMember.Kind()} ."); 
var helloWorldDeclaration = (NamespaceDeclarationSyntax)firstMember;  
WriteLine( $"There are {helloWorldDeclaration.Members.Count}  members declared  
in this namespace." ); 
WriteLine( $"The first member is a  
{helloWorldDeclaration.Members[ 0].Kind()} ."); that type to examine the class declaration. This class only contains one member: the
Main method. Add the following code to find the Main method, and cast it to a
Microsoft.CodeAnalysis.CSharp.S yntax.MethodDeclarationS yntax .
C#
The method declaration node contains all the syntactic information about the method.
Let's display the return type of the Main method, the number and types of the
arguments, and the body text of the method. Add the following code:
C#
Run the program to see all the information you've discovered about this program:
textvar programDeclaration =  
(ClassDeclarationSyntax)helloWorldDeclaration.Members[ 0]; 
WriteLine( $"There are {programDeclaration.Members.Count}  members declared in  
the {programDeclaration.Identifier}  class." ); 
WriteLine( $"The first member is a {programDeclaration.Members[ 0].Kind()} ."); 
var mainDeclaration =  
(MethodDeclarationSyntax)programDeclaration.Members[ 0]; 
WriteLine( $"The return type of the {mainDeclaration.Identifier}  method is  
{mainDeclaration.ReturnType} ."); 
WriteLine( $"The method has {mainDeclaration.ParameterList.Parameters.Count}  
parameters." ); 
foreach (ParameterSyntax item in mainDeclaration.ParameterList.Parameters)  
    WriteLine( $"The type of the {item.Identifier}  parameter is  
{item.Type} ."); 
WriteLine( $"The body text of the {mainDeclaration.Identifier}  method 
follows:" ); 
WriteLine(mainDeclaration.Body?.ToFullString());  
var argsParameter = mainDeclaration.ParameterList.Parameters[ 0]; 
The tree is a CompilationUnit node.  
The tree has 1 elements in it.  
The tree has 4 using statements. They are:  
        System  
        System.Collections  
        System.Linq  
        System.Text  
The first member is a NamespaceDeclaration.  
There are 1 members declared in this namespace.  
The first member is a ClassDeclaration.  
There are 1 members declared in the Program class.  
The first member is a MethodDeclaration.  In addition to traversing trees, you can also explore the syntax tree using the query
methods defined on Microsoft.CodeAnalysis.S yntaxNode . These methods should be
immediately familiar to anyone familiar with XP ath. Y ou can use these methods with
LINQ to quickly find things in a tree. The SyntaxNode  has query methods such as
DescendantNodes , AncestorsAndSelf  and ChildNodes .
You can use these query methods to find the argument to the Main method as an
alternative to navigating the tree. Add the following code to the bottom of your Main
method:
C#
The first statement uses a LINQ expression and the DescendantNodes  method to locate
the same parameter as in the previous example.
Run the program, and you can see that the LINQ expression found the same parameter
as manually navigating the tree.
The sample uses WriteLine statements to display information about the syntax trees as
they are traversed. Y ou can also learn much more by running the finished program
under the debugger. Y ou can examine more of the properties and methods that are part
of the syntax tree created for the hello world program.The return type of the Main method is void.  
The method has 1 parameters.  
The type of the args parameter is string[].  
The body text of the Main method follows:  
        {  
            Console.WriteLine("Hello, World!");  
        }  
Query methods
var firstParameters = from methodDeclaration in root.DescendantNodes()  
                                        .OfType<MethodDeclarationSyntax>()  
                      where methodDeclaration.Identifier.ValueText == "Main" 
                      select 
methodDeclaration.ParameterList.Parameters.First();  
var argsParameter2 = firstParameters.Single();  
WriteLine(argsParameter == argsParameter2);  
Syntax walkersOften you want to find all nodes of a specific type in a syntax tree, for example, every
property declaration in a file. By extending the
Microsoft.CodeAnalysis.CSharp.CSharpS yntaxW alker  class and overriding the
VisitPropertyDeclaration(PropertyDeclarationS yntax)  method, you process every
property declaration in a syntax tree without knowing its structure beforehand.
CSharpS yntaxW alker  is a specific kind of CSharpS yntaxVisitor  that recursively visits a
node and each of its children.
This example implements a CSharpS yntaxW alker  that examines a syntax tree. It collects
using directives it finds that aren't importing a System namespace.
Create a new C# Stand-Alone Code Analysis T ool project; name it " SyntaxW alker."
You can see the finished code for this sample in our GitHub repository . The sample on
GitHub contains both projects described in this tutorial.
As in the previous sample, you can define a string constant to hold the text of the
program you're going to analyze:
C#
        const string programText =  
@"using System;  
using System.Collections.Generic;
using System.Linq;  
using System.Text;  
using Microsoft.CodeAnalysis;  
using Microsoft.CodeAnalysis.CSharp;  
namespace TopLevel  
{ 
    using Microsoft;  
    using System.ComponentModel;  
    namespace Child1  
    { 
        using Microsoft.Win32;  
        using System.Runtime.InteropServices;  
        class Foo { }  
    } 
    namespace Child2  
    { 
        using System.CodeDom;  
        using Microsoft.CSharp;  
        class Bar { }  
    } 
}"; This source text contains using directives scattered across four different locations: the
file-level, in the top-level namespace, and in the two nested namespaces. This example
highlights a core scenario for using the CSharpS yntaxW alker  class to query code. It
would be cumbersome to visit every node in the root syntax tree to find using
declarations. Instead, you create a derived class and override the method that gets
called only when the current node in the tree is a using directive. Y our visitor does not
do any work on any other node types. This single method examines each of the using
statements and builds a collection of the namespaces that aren't in the System
namespace. Y ou build a CSharpS yntaxW alker  that examines all the using statements,
but only the using statements.
Now that you've defined the program text, you need to create a SyntaxTree and get the
root of that tree:
C#
Next, create a new class. In Visual S tudio, choose Project  > Add New It em. In the Add
New It em dialog type UsingC ollect or.cs as the filename.
You implement the using visitor functionality in the UsingCollector class. S tart by
making the UsingCollector class derive from CSharpS yntaxW alker .
C#
You need storage to hold the namespace nodes that you're collecting. Declare a public
read-only property in the UsingCollector class; you use this variable to store the
UsingDirectiveS yntax  nodes you find:
C#
The base class, CSharpS yntaxW alker  implements the logic to visit each node in the
syntax tree. The derived class overrides the methods called for the specific nodes you're
interested in. In this case, you're interested in any using directive. That means you mustSyntaxTree tree = CSharpSyntaxTree.ParseText(programText);  
CompilationUnitSyntax root = tree.GetCompilationUnitRoot();  
class UsingCollector  : CSharpSyntaxWalker  
public ICollection<UsingDirectiveSyntax> Usings { get; } = new 
List<UsingDirectiveSyntax>();  override the VisitUsingDirective(UsingDirectiveS yntax)  method. The one argument to
this method is a Microsoft.CodeAnalysis.CSharp.S yntax.UsingDirectiveS yntax  object.
That's an important advantage to using the visitors: they call the overridden methods
with arguments already cast to the specific node type. The
Microsoft.CodeAnalysis.CSharp.S yntax.UsingDirectiveS yntax  class has a Name  property
that stores the name of the namespace being imported. It is a
Microsoft.CodeAnalysis.CSharp.S yntax.NameS yntax . Add the following code in the
VisitUsingDirective(UsingDirectiveS yntax)  override:
C#
As with the earlier example, you've added a variety of WriteLine statements to aid in
understanding of this method. Y ou can see when it's called, and what arguments are
passed to it each time.
Finally, you need to add two lines of code to create the UsingCollector and have it visit
the root node, collecting all the using statements. Then, add a foreach loop to display
all the using statements your collector found:
C#
Compile and run the program. Y ou should see the following output:
Consolepublic override  void VisitUsingDirective (UsingDirectiveSyntax node ) 
{ 
    WriteLine( $"\tVisitUsingDirective called with {node.Name} ."); 
    if (node.Name.ToString() != "System"  && 
        !node.Name.ToString().StartsWith( "System." )) 
    { 
        WriteLine( $"\t\tSuccess. Adding {node.Name} ."); 
        this.Usings.Add(node);  
    } 
} 
var collector = new UsingCollector();  
collector.Visit(root);  
foreach (var directive in collector.Usings)  
{ 
    WriteLine(directive.Name);  
} 
        VisitUsingDirective called with System.  
        VisitUsingDirective called with System.Collections.Generic.  
        VisitUsingDirective called with System.Linq.  Congratulations! Y ou've used the Syntax API  to locate specific kinds of C# statements
and declarations in C# source code.        VisitUsingDirective called with System.Text.  
        VisitUsingDirective called with Microsoft.CodeAnalysis.  
                Success. Adding Microsoft.CodeAnalysis.  
        VisitUsingDirective called with Microsoft.CodeAnalysis.CSharp.  
                Success. Adding Microsoft.CodeAnalysis.CSharp.  
        VisitUsingDirective called with Microsoft.  
                Success. Adding Microsoft.  
        VisitUsingDirective called with System.ComponentModel.  
        VisitUsingDirective called with Microsoft.Win32.  
                Success. Adding Microsoft.Win32.  
        VisitUsingDirective called with System.Runtime.InteropServices.  
        VisitUsingDirective called with System.CodeDom.  
        VisitUsingDirective called with Microsoft.CSharp.  
                Success. Adding Microsoft.CSharp.  
Microsoft.CodeAnalysis  
Microsoft.CodeAnalysis.CSharp  
Microsoft  
Microsoft.Win32  
Microsoft.CSharp  
Press any key to continue . . .  Get started with semantic analysis
Article •09/15/2021
This tutorial assumes you're familiar with the S yntax API. The get started with syntax
analysis  article provides sufficient introduction.
In this tutorial, you explore the Symbol  and Binding APIs . These APIs provide
information about the semantic meaning  of a program. They enable you to ask and
answer questions about the types represented by any symbol in your program.
You'll need to install the .NET Compiler Platform SDK :
There are two different ways to find the .NET Compiler Platform SDK  in the Visual
Studio Installer :
The .NET Compiler Platform SDK is not automatically selected as part of the Visual
Studio extension development workload. Y ou must select it as an optional component.
1. Run Visual S tudio Installer
2. Select Modif y
3. Check the Visual S tudio ext ension dev elopment  workload.
4. Open the Visual S tudio ext ension dev elopment  node in the summary tree.
5. Check the box for .NET Compiler Platform SDK . You'll find it last under the
optional components.
Optionally, you'll also want the DGML edit or to display graphs in the visualizer:
1. Open the Individual components  node in the summary tree.
2. Check the box for DGML edit or
1. Run Visual S tudio Installer
2. Select Modif y
3. Select the Individual components  tabInstallation instructions - Visual Studio Installer
Install using the Visual Studio Installer - Workloads view
Install using the Visual Studio Installer - Individual
components tab4. Check the box for .NET Compiler Platform SDK . You'll find it at the top under the
Compiler s, build t ools, and runtimes  section.
Optionally, you'll also want the DGML edit or to display graphs in the visualizer:
1. Check the box for DGML edit or. You'll find it under the Code t ools section.
As you work more with the .NET Compiler SDK, you become familiar with the
distinctions between S yntax API and the Semantic API. The Syntax API  allows you to
look at the structur e of a program. However, often you want richer information about
the semantics or meaning  of a program. While a loose code file or snippet of Visual
Basic or C# code can be syntactically analyzed in isolation, it's not meaningful to ask
questions such as "what's the type of this variable" in a vacuum. The meaning of a type
name may be dependent on assembly references, namespace imports, or other code
files. Those questions are answered using the Semantic API , specifically the
Microsoft.CodeAnalysis.Compilation  class.
An instance of Compilation  is analogous to a single project as seen by the compiler and
represents everything needed to compile a Visual Basic or C# program. The compilation
includes the set of source files to be compiled, assembly references, and compiler
options. Y ou can reason about the meaning of the code using all the other information
in this context. A Compilation  allows you to find Symbols  - entities such as types,
namespaces, members, and variables which names and other expressions refer to. The
process of associating names and expressions with Symbols  is called Binding .
Like Microsoft.CodeAnalysis.S yntaxT ree, Compilation  is an abstract class with language-
specific derivatives. When creating an instance of Compilation, you must invoke a
factory method on the Microsoft.CodeAnalysis.CSharp.CSharpCompilation  (or
Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation ) class.
In this tutorial, you look at the "Hello W orld" program again. This time, you query the
symbols in the program to understand what types those symbols represent. Y ou query
for the types in a namespace, and learn to find the methods available on a type.
You can see the finished code for this sample in our GitHub repository .Understanding Compilations and Symbols
Querying symbols
７ NoteCreate a new C# Stand-Alone Code Analysis T ool project:
In Visual S tudio, choose File > New  > Project  to display the New Project dialog.
Under Visual C#  > Extensibility , choose Stand-Alone Code Analysis T ool.
Name your project " SemanticQuickS tart" and click OK.
You're going to analyze the basic "Hello W orld!" program shown earlier. Add the text for
the Hello W orld program as a constant in your Program class:
C#
Next, add the following code to build the syntax tree for the code text in the
programText constant. Add the following line to your Main method:
C#The S yntax T ree types use inheritance to describe the different syntax elements that
are valid at different locations in the program. Using these APIs often means
casting properties or collection members to specific derived types. In the following
examples, the assignment and the casts are separate statements, using explicitly
typed variables. Y ou can read the code to see the return types of the API and the
runtime type of the objects returned. In practice, it's more common to use implicitly
typed variables and rely on API names to describe the type of objects being
examined.
        const string programText =  
@"using System;  
using System.Collections.Generic;
using System.Text;  
namespace HelloWorld  
{ 
    class Program  
    { 
        static void Main(string[] args)  
        {  
            Console.WriteLine(""Hello, World!"");  
        }  
    } 
}"; 
SyntaxTree tree = CSharpSyntaxTree.ParseText(programText);  
CompilationUnitSyntax root = tree.GetCompilationUnitRoot();  Next, build a CSharpCompilation  from the tree you already created. The "Hello W orld"
sample relies on the String  and Console  types. Y ou need to reference the assembly that
declares those two types in your compilation. Add the following line to your Main
method to create a compilation of your syntax tree, including the reference to the
appropriate assembly:
C#
The CSharpCompilation.AddR eferences  method adds references to the compilation. The
MetadataR eference.CreateFromFile  method loads an assembly as a reference.
Once you have a Compilation  you can ask it for a SemanticModel  for any SyntaxT ree
contained in that Compilation . You can think of the semantic model as the source for all
the information you would normally get from intellisense. A SemanticModel  can answer
questions like "What names are in scope at this location?", "What members are
accessible from this method?", "What variables are used in this block of text?", and
"What does this name/expression refer to?" Add this statement to create the semantic
model:
C#
The Compilation  creates the SemanticModel  from the SyntaxT ree. After creating the
model, you can query it to find the first using directive, and retrieve the symbol
information for the System namespace. Add these two lines to your Main method to
create the semantic model and retrieve the symbol for the first using statement:
C#var compilation = CSharpCompilation.Create( "HelloWorld" ) 
    .AddReferences(MetadataReference.CreateFromFile(  
        typeof(string).Assembly.Location))  
    .AddSyntaxTrees(tree);  
Querying the semantic model
SemanticModel model = compilation.GetSemanticModel(tree);  
Binding a name
// Use the syntax tree to find "using System;"  
UsingDirectiveSyntax usingSystem = root.Usings[ 0]; 
NameSyntax systemName = usingSystem.Name;  The preceding code shows how to bind the name in the first using directive to retrieve
a Microsoft.CodeAnalysis.S ymbolInfo  for the System namespace. The preceding code
also illustrates that you use the syntax model  to find the structure of the code; you use
the semantic model  to understand its meaning. The syntax model  finds the string
System in the using statement. The semantic model  has all the information about the
types defined in the System namespace.
From the SymbolInfo  object you can obtain the Microsoft.CodeAnalysis.IS ymbol  using
the SymbolInfo.S ymbol  property. This property returns the symbol this expression refers
to. For expressions that don't refer to anything (such as numeric literals) this property is
null. When the SymbolInfo.S ymbol  is not null, the ISymbol.Kind  denotes the type of the
symbol. In this example, the ISymbol.Kind  property is a SymbolKind.Namespace . Add the
following code to your Main method. It retrieves the symbol for the System namespace
and then displays all the child namespaces declared in the System namespace:
C#
Run the program and you should see the following output:
Output// Use the semantic model for symbol information:  
SymbolInfo nameInfo = model.GetSymbolInfo(systemName);  
var systemSymbol = (INamespaceSymbol?)nameInfo.Symbol;  
if (systemSymbol?.GetNamespaceMembers() is not null) 
{ 
    foreach (INamespaceSymbol ns in systemSymbol?.GetNamespaceMembers()!)  
    { 
        Console.WriteLine(ns);  
    } 
} 
System.Collections  
System.Configuration  
System.Deployment  
System.Diagnostics  
System.Globalization  
System.IO  
System.Numerics  
System.Reflection  
System.Resources  
System.Runtime  
System.Security  
System.StubHelpers  
System.Text  The preceding code shows how to find a symbol by binding to a name. There are other
expressions in a C# program that can be bound that aren't names. T o demonstrate this
capability, let's access the binding to a simple string literal.
The "Hello W orld" program contains a
Microsoft.CodeAnalysis.CSharp.S yntax.LiteralExpressionS yntax , the "Hello, W orld!" string
displayed to the console.
You find the "Hello, W orld!" string by locating the single string literal in the program.
Then, once you've located the syntax node, get the type info for that node from the
semantic model. Add the following code to your Main method:
C#
The Microsoft.CodeAnalysis.T ypeInfo  struct includes a TypeInfo.T ype property that
enables access to the semantic information about the type of the literal. In this example,
that's the string type. Add a declaration that assigns this property to a local variable:
C#System.Threading  
Press any key to continue . . .  
７ Note
The output does not include every namespace that is a child namespace of the
System namespace. It displays every namespace that is present in this compilation,
which only references the assembly where System.String is declared. Any
namespaces declared in other assemblies are not known to this compilation
Binding an expression
// Use the syntax model to find the literal string:  
LiteralExpressionSyntax helloWorldString = root.DescendantNodes()  
.OfType<LiteralExpressionSyntax>()  
.Single();  
// Use the semantic model for type information:  
TypeInfo literalInfo = model.GetTypeInfo(helloWorldString);  
var stringTypeSymbol = (INamedTypeSymbol?)literalInfo.Type;  To finish this tutorial, let's build a LINQ query that creates a sequence of all the public
methods declared on the string type that return a string. This query gets complex, so
let's build it line by line, then reconstruct it as a single query. The source for this query is
the sequence of all members declared on the string type:
C#
That source sequence contains all members, including properties and fields, so filter it
using the ImmutableArray<T>.OfT ype method to find elements that are
Microsoft.CodeAnalysis.IMethodS ymbol  objects:
C#
Next, add another filter to return only those methods that are public and return a
string:
C#
Select only the name property, and only distinct names by removing any overloads:
C#
You can also build the full query using the LINQ query syntax, and then display all the
method names in the console:
C#var allMembers = stringTypeSymbol?.GetMembers();  
var methods = allMembers?.OfType<IMethodSymbol>();  
var publicStringReturningMethods = methods?  
    .Where(m => SymbolEqualityComparer.Default.Equals(m.ReturnType,  
stringTypeSymbol) &&  
    m.DeclaredAccessibility == Accessibility.Public);  
var distinctMethods = publicStringReturningMethods?.Select(m =>  
m.Name).Distinct();  
foreach (string name in (from method in stringTypeSymbol?  
                         .GetMembers( ).OfType<IMethodSymbol>( ) 
                         where 
SymbolEqualityComparer.Default. Equals(method.ReturnType, stringTypeSymbol ) 
&& 
                         method.DeclaredAccessibility  == Build and run the program. Y ou should see the following output:
Output
You've used the Semantic API to find and display information about the symbols that
are part of this program.Accessibility.Public  
                         select method.Name).Distinct())  
{ 
    Console.WriteLine(name);  
} 
Join 
Substring  
Trim 
TrimStart  
TrimEnd 
Normalize  
PadLeft 
PadRight  
ToLower 
ToLowerInvariant  
ToUpper 
ToUpperInvariant  
ToString  
Insert 
Replace 
Remove 
Format 
Copy 
Concat 
Intern 
IsInterned  
Press any key to continue . . .  Get started with syntax transformation
Article •09/15/2021
This tutorial builds on concepts and techniques explored in the Get started with syntax
analysis  and Get started with semantic analysis  quickstarts. If you haven't already, you
should complete those quickstarts before beginning this one.
In this quickstart, you explore techniques for creating and transforming syntax trees. In
combination with the techniques you learned in previous quickstarts, you create your
first command-line refactoring!
There are two different ways to find the .NET Compiler Platform SDK  in the Visual
Studio Installer :
The .NET Compiler Platform SDK is not automatically selected as part of the Visual
Studio extension development workload. Y ou must select it as an optional component.
1. Run Visual S tudio Installer
2. Select Modif y
3. Check the Visual S tudio ext ension dev elopment  workload.
4. Open the Visual S tudio ext ension dev elopment  node in the summary tree.
5. Check the box for .NET Compiler Platform SDK . You'll find it last under the
optional components.
Optionally, you'll also want the DGML edit or to display graphs in the visualizer:
1. Open the Individual components  node in the summary tree.
2. Check the box for DGML edit or
1. Run Visual S tudio Installer
2. Select Modif y
3. Select the Individual components  tabInstallation instructions - Visual Studio Installer
Install using the Visual Studio Installer - Workloads view
Install using the Visual Studio Installer - Individual
components tab4. Check the box for .NET Compiler Platform SDK . You'll find it at the top under the
Compiler s, build t ools, and runtimes  section.
Optionally, you'll also want the DGML edit or to display graphs in the visualizer:
1. Check the box for DGML edit or. You'll find it under the Code t ools section.
Immutability  is a fundamental tenet of the .NET compiler platform. Immutable data
structures can't be changed after they're created. Immutable data structures can be
safely shared and analyzed by multiple consumers simultaneously. There's no danger
that one consumer affects another in unpredictable ways. Y our analyzer doesn't need
locks or other concurrency measures. This rule applies to syntax trees, compilations,
symbols, semantic models, and every other data structure you encounter. Instead of
modifying existing structures, APIs create new objects based on specified differences to
the old ones. Y ou apply this concept to syntax trees to create new trees using
transformations.
You choose one of two strategies for syntax transformations. Factory methods  are best
used when you're searching for specific nodes to replace, or specific locations where you
want to insert new code. Rewrit ers are best when you want to scan an entire project for
code patterns that you want to replace.
The first syntax transformation demonstrates the factory methods. Y ou're going to
replace a using System.Collections; statement with a using
System.Collections.Generic; statement. This example demonstrates how you create
Microsoft.CodeAnalysis.CSharp.CSharpS yntaxNode  objects using the
Microsoft.CodeAnalysis.CSharp.S yntaxF actory  factory methods. For each kind of node ,
token, or trivia , there's a factory method that creates an instance of that type. Y ou
create syntax trees by composing nodes hierarchically in a bottom-up fashion. Then,
you'll transform the existing program by replacing existing nodes with the new tree
you've created.
Start Visual S tudio, and create a new C# Stand-Alone Code Analysis T ool project. In
Visual S tudio, choose File > New  > Project  to display the New Project dialog. Under
Visual C#  > Extensibility  choose a Stand-Alone Code Analysis T ool. This quickstart hasImmutability and the .NET compiler platform
Create and transform trees
Create nodes with factory methodstwo example projects, so name the solution SyntaxT ransformationQuickS tart, and name
the project ConstructionCS . Click OK.
This project uses the Microsoft.CodeAnalysis.CSharp.S yntaxF actory  class methods to
construct a Microsoft.CodeAnalysis.CSharp.S yntax.NameS yntax  representing the
System.Collections.Generic namespace.
Add the following using directive to the top of the Program.cs.
C#
You'll create name syntax nodes  to build the tree that represents the using
System.Collections.Generic; statement. NameS yntax  is the base class for four types of
names that appear in C#. Y ou compose these four types of names together to create
any name that can appear in the C# language:
Microsoft.CodeAnalysis.CSharp.S yntax.NameS yntax , which represents simple single
identifier names like System and Microsoft.
Microsoft.CodeAnalysis.CSharp.S yntax.GenericNameS yntax , which represents a
generic type or method name such as List<int>.
Microsoft.CodeAnalysis.CSharp.S yntax.QualifiedNameS yntax , which represents a
qualified name of the form <left-name>.<right-identifier-or-generic-name> such
as System.IO.
Microsoft.CodeAnalysis.CSharp.S yntax.AliasQualifiedNameS yntax , which represents
a name using an assembly extern alias such as LibraryV2::Foo.
You use the IdentifierName(S tring)  method to create a NameS yntax  node. Add the
following code in your Main method in Program.cs:
C#
The preceding code creates an IdentifierNameS yntax  object and assigns it to the
variable name. Many of the R oslyn APIs return base classes to make it easier to work with
related types. The variable name, an NameS yntax , can be reused as you build the
QualifiedNameS yntax . Don't use type inference as you build the sample. Y ou'll automate
that step in this project.using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static System.Console;
NameSyntax name = IdentifierName( "System" );
WriteLine( $"\tCreated the identifier {name}");You've created the name. Now, it's time to build more nodes into the tree by building a
QualifiedNameS yntax . The new tree uses name as the left of the name, and a new
IdentifierNameS yntax  for the Collections namespace as the right side of the
QualifiedNameS yntax . Add the following code to program.cs:
C#
Run the code again, and see the results. Y ou're building a tree of nodes that represents
code. Y ou'll continue this pattern to build the QualifiedNameS yntax  for the namespace
System.Collections.Generic. Add the following code to Program.cs:
C#
Run the program again to see that you've built the tree for the code to add.
You've built a small syntax tree that contains one statement. The APIs to create new
nodes are the right choice to create single statements or other small code blocks.
However, to build larger blocks of code, you should use methods that replace nodes or
insert nodes into an existing tree. R emember that syntax trees are immutable. The
Syntax API  doesn't provide any mechanism for modifying an existing syntax tree after
construction. Instead, it provides methods that produce new trees based on changes to
existing ones. With* methods are defined in concrete classes that derive from
SyntaxNode  or in extension methods declared in the SyntaxNodeExtensions  class. These
methods create a new node by applying changes to an existing node's child properties.
Additionally, the ReplaceNode  extension method can be used to replace a descendent
node in a subtree. This method also updates the parent to point to the newly created
child and repeats this process up the entire tree - a process known as re-spinning  the
tree.
The next step is to create a tree that represents an entire (small) program and then
modify it. Add the following code to the beginning of the Program class:
C#name = QualifiedName(name, IdentifierName( "Collections" ));
WriteLine(name.ToString());
name = QualifiedName(name, IdentifierName( "Generic" ));
WriteLine(name.ToString());
Create a modified treeNext, add the following code to the bottom of the Main method to parse the text and
create a tree:
C#
This example uses the WithName(NameS yntax)  method to replace the name in a
UsingDirectiveS yntax  node with the one constructed in the preceding code.
Create a new UsingDirectiveS yntax  node using the WithName(NameS yntax)  method to
update the System.Collections name with the name you created in the preceding code.
Add the following code to the bottom of the Main method:
C#        private const string sampleCode =
@"using System;
using System.Collections;
using System.Linq;
using System.Text;
namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(""Hello, World!"");
        }
    }
}";
７ Note
The example code uses the System.Collections namespace and not the
System.Collections.Generic namespace.
SyntaxTree tree = CSharpSyntaxTree.ParseText(sampleCode);
var root = (CompilationUnitSyntax)tree.GetRoot();
var oldUsing = root.Usings[ 1];
var newUsing = oldUsing.WithName(name);
WriteLine(root.ToString());Run the program and look carefully at the output. The newUsing hasn't been placed in
the root tree. The original tree hasn't been changed.
Add the following code using the ReplaceNode  extension method to create a new tree.
The new tree is the result of replacing the existing import with the updated newUsing
node. Y ou assign this new tree to the existing root variable:
C#
Run the program again. This time the tree now correctly imports the
System.Collections.Generic namespace.
The With* and ReplaceNode  methods provide convenient means to transform
individual branches of a syntax tree. The
Microsoft.CodeAnalysis.CSharp.CSharpS yntaxR ewriter  class performs multiple
transformations on a syntax tree. The
Microsoft.CodeAnalysis.CSharp.CSharpS yntaxR ewriter  class is a subclass of
Microsoft.CodeAnalysis.CSharp.CSharpS yntaxVisitor<TR esult> . The
CSharpS yntaxR ewriter  applies a transformation to a specific type of SyntaxNode . You
can apply transformations to multiple types of SyntaxNode  objects wherever they
appear in a syntax tree. The second project in this quickstart creates a command-line
refactoring that removes explicit types in local variable declarations anywhere that type
inference could be used.
Create a new C# Stand-Alone Code Analysis T ool project. In Visual S tudio, right-click
the SyntaxTransformationQuickStart solution node. Choose Add > New Pr oject  to
display the New Pr oject dialog . Under Visual C#  > Extensibility , choose Stand-Alone
Code Analysis T ool. Name your project TransformationCS and click OK.
The first step is to create a class that derives from CSharpS yntaxR ewriter  to perform your
transformations. Add a new class file to the project. In Visual S tudio, choose Project  >
Add Class... . In the Add New It em dialog type TypeInferenceRewriter.cs as the
filename.
Add the following using directives to the TypeInferenceRewriter.cs file:
C#root = root.ReplaceNode(oldUsing, newUsing);
WriteLine(root.ToString());
Transform trees using SyntaxRewritersNext, make the TypeInferenceRewriter class extend the CSharpS yntaxR ewriter  class:
C#
Add the following code to declare a private read-only field to hold a SemanticModel
and initialize it in the constructor. Y ou will need this field later on to determine where
type inference can be used:
C#
Override the VisitLocalDeclarationS tatement(LocalDeclarationS tatementS yntax)  method:
C#using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
public class TypeInferenceRewriter  : CSharpSyntaxRewriter
private readonly  SemanticModel SemanticModel;
public TypeInferenceRewriter (SemanticModel semanticModel ) => SemanticModel =  
semanticModel;
public override  SyntaxNode 
VisitLocalDeclarationStatement (LocalDeclarationStatementSyntax node )
{
}
７ Note
Many of the R oslyn APIs declare return types that are base classes of the actual
runtime types returned. In many scenarios, one kind of node may be replaced by
another kind of node entirely - or even removed. In this example, the
VisitLocalDeclarationS tatement(LocalDeclarationS tatementS yntax)  method
returns a SyntaxNode , instead of the derived type of
LocalDeclarationS tatementS yntax . This rewriter returns a new
LocalDeclarationS tatementS yntax  node based on the existing one.This quickstart handles local variable declarations. Y ou could extend it to other
declarations such as foreach loops, for loops, LINQ expressions, and lambda
expressions. Furthermore this rewriter will only transform declarations of the simplest
form:
C#
If you want to explore on your own, consider extending the finished sample for these
types of variable declarations:
C#
Add the following code to the body of the VisitLocalDeclarationStatement method to
skip rewriting these forms of declarations:
C#
The method indicates that no rewriting takes place by returning the node parameter
unmodified. If neither of those if expressions are true, the node represents a possible
declaration with initialization. Add these statements to extract the type name specified
in the declaration and bind it using the SemanticModel  field to obtain a type symbol:
C#Type variable = expression;
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
if (node.Declaration.Variables.Count > 1)
{
    return node;
}
if (node.Declaration.Variables[ 0].Initializer == null)
{
    return node;
}
var declarator = node.Declaration.Variables.First();
var variableTypeName = node.Declaration.Type;
var variableType = (ITypeSymbol)SemanticModelNow, add this statement to bind the initializer expression:
C#
Finally, add the following if statement to replace the existing type name with the var
keyword if the type of the initializer expression matches the type specified:
C#
The conditional is required because the declaration may cast the initializer expression to
a base class or interface. If that's desired, the types on the left and right-hand side of the
assignment don't match. R emoving the explicit type in these cases would change the
semantics of a program. var is specified as an identifier rather than a keyword because
var is a contextual keyword. The leading and trailing trivia (white space) are transferred
from the old type name to the var keyword to maintain vertical white space and
indentation. It's simpler to use ReplaceNode rather than With* to transform the
LocalDeclarationS tatementS yntax  because the type name is actually the grandchild of
the declaration statement.
You've finished the TypeInferenceRewriter. Now return to your Program.cs file to finish
the example. Create a test Compilation  and obtain the SemanticModel  from it. Use that
SemanticModel  to try your TypeInferenceRewriter. You'll do this step last. In the
meantime declare a placeholder variable representing your test compilation:
C#    .GetSymbolInfo(variableTypeName)
    .Symbol;
var initializerInfo =  
SemanticModel.GetTypeInfo(declarator.Initializer.Value);
if (SymbolEqualityComparer.Default.Equals(variableType,  
initializerInfo.Type))
{
    TypeSyntax varTypeName = SyntaxFactory.IdentifierName( "var")
        .WithLeadingTrivia(variableTypeName.GetLeadingTrivia())
        .WithTrailingTrivia(variableTypeName.GetTrailingTrivia());
    return node.ReplaceNode(variableTypeName, varTypeName);
}
else
{
    return node;
}After pausing a moment, you should see an error squiggle appear reporting that no
CreateTestCompilation method exists. Press Ctrl+P eriod  to open the light-bulb and
then press Enter to invoke the Generat e Method S tub command. This command will
generate a method stub for the CreateTestCompilation method in the Program class.
You'll come back to fill in this method later:
Write the following code to iterate over each SyntaxT ree in the test Compilation . For
each one, initialize a new TypeInferenceRewriter with the SemanticModel  for that tree:
C#
Inside the foreach statement you created, add the following code to perform the
transformation on each source tree. This code conditionally writes out the newCompilation test = CreateTestCompilation();
foreach (SyntaxTree sourceTree in test.SyntaxTrees)
{
    SemanticModel model = test.GetSemanticModel(sourceTree);
    TypeInferenceRewriter rewriter = new TypeInferenceRewriter(model);
    SyntaxNode newSource = rewriter.Visit(sourceTree.GetRoot());
    if (newSource != sourceTree.GetRoot())
    {
        File.WriteAllText(sourceTree.FilePath, newSource.ToFullString());
    }
}transformed tree if any edits were made. Y our rewriter should only modify a tree if it
encounters one or more local variable declarations that could be simplified using type
inference:
C#
You should see squiggles under the File.WriteAllText code. Select the light bulb, and
add the necessary using System.IO; statement.
You're almost done! There's one step left: creating a test Compilation . Since you haven't
been using type inference at all during this quickstart, it would have made a perfect test
case. Unfortunately, creating a Compilation from a C# project file is beyond the scope of
this walkthrough. But fortunately, if you've been following instructions carefully, there's
hope. R eplace the contents of the CreateTestCompilation method with the following
code. It creates a test compilation that coincidentally matches the project described in
this quickstart:
C#SyntaxNode newSource = rewriter.Visit(sourceTree.GetRoot());
if (newSource != sourceTree.GetRoot())
{
    File.WriteAllText(sourceTree.FilePath, newSource.ToFullString());
}
String programPath = @"..\..\..\Program.cs" ;
String programText = File.ReadAllText(programPath);
SyntaxTree programTree =
               CSharpSyntaxTree.ParseText(programText)
                               .WithFilePath(programPath);
String rewriterPath = @"..\..\..\TypeInferenceRewriter.cs" ;
String rewriterText = File.ReadAllText(rewriterPath);
SyntaxTree rewriterTree =
               CSharpSyntaxTree.ParseText(rewriterText)
                               .WithFilePath(rewriterPath);
SyntaxTree[] sourceTrees = { programTree, rewriterTree };
MetadataReference mscorlib =
        MetadataReference.CreateFromFile( typeof(object).Assembly.Location);
MetadataReference codeAnalysis =
<p>MetadataReference.CreateFromFile( typeof(SyntaxTree).Assembly.Location);
MetadataReference csharpCodeAnalysis =</p>
<p>MetadataReference.CreateFromFile( typeof(CSharpSyntaxTree).Assembly.Location)
;Cross your fingers and run the project. In Visual S tudio, choose Debug  &gt; Start
Debugging . You should be prompted by Visual S tudio that the files in your project have
changed. Click &quot; Yes to All &quot; to reload the modified files. Examine them to observe your
awesomeness. Note how much cleaner the code looks without all those explicit and
redundant type specifiers.
Congratulations! Y ou've used the Compiler APIs  to write your own refactoring that
searches all files in a C# project for certain syntactic patterns, analyzes the semantics of
source code that matches those patterns, and transforms it. Y ou're now officially a
refactoring author!MetadataReference[] references = { mscorlib, codeAnalysis,<br />
csharpCodeAnalysis };
return CSharpCompilation.Create( &quot;TransformationCS&quot; ,
sourceTrees,
references,
new CSharpCompilationOptions(OutputKind.ConsoleApplication));Tutorial: Write your first analyzer and
code fix
Article •02/04/2022
The .NET Compiler Platform SDK provides the tools you need to create custom
diagnostics (analyzers), code fixes, code refactoring, and diagnostic suppressors that
target C# or Visual Basic code. An analyzer  contains code that recognizes violations of
your rule. Y our code fix  contains the code that fixes the violation. The rules you
implement can be anything from code structure to coding style to naming conventions
and more. The .NET Compiler Platform provides the framework for running analysis as
developers are writing code, and all the Visual S tudio UI features for fixing code:
showing squiggles in the editor, populating the Visual S tudio Error List, creating the
&quot;light bulb&quot; suggestions and showing the rich preview of the suggested fixes.
In this tutorial, you'll explore the creation of an analyzer  and an accompanying code fix
using the R oslyn APIs. An analyzer is a way to perform source code analysis and report a
problem to the user. Optionally, a code fix can be associated with the analyzer to
represent a modification to the user's source code. This tutorial creates an analyzer that
finds local variable declarations that could be declared using the const modifier but are
not. The accompanying code fix modifies those declarations to add the const modifier.
Visual S tudio 2019  version 16.8 or later
You'll need to install the .NET Compiler Platform SDK  via the Visual S tudio Installer:
There are two different ways to find the .NET Compiler Platform SDK  in the Visual
Studio Installer :
The .NET Compiler Platform SDK is not automatically selected as part of the Visual
Studio extension development workload. Y ou must select it as an optional component.</p>
<ol>
<li>Run Visual S tudio Installer</li>
<li>Select Modif yPrerequisites
Installation instructions - Visual Studio Installer
Install using the Visual Studio Installer - Workloads view3. Check the Visual S tudio ext ension dev elopment  workload.</li>
<li>Open the Visual S tudio ext ension dev elopment  node in the summary tree.</li>
<li>Check the box for .NET Compiler Platform SDK . You'll find it last under the
optional components.
Optionally, you'll also want the DGML edit or to display graphs in the visualizer:</li>
<li>Open the Individual components  node in the summary tree.</li>
<li>Check the box for DGML edit or</li>
<li>Run Visual S tudio Installer</li>
<li>Select Modif y</li>
<li>Select the Individual components  tab</li>
<li>Check the box for .NET Compiler Platform SDK . You'll find it at the top under the
Compiler s, build t ools, and runtimes  section.
Optionally, you'll also want the DGML edit or to display graphs in the visualizer:</li>
<li>Check the box for DGML edit or. You'll find it under the Code t ools section.
There are several steps to creating and validating your analyzer:</li>
<li>Create the solution.</li>
<li>Register the analyzer name and description.</li>
<li>Report analyzer warnings and recommendations.</li>
<li>Implement the code fix to accept recommendations.</li>
<li>Improve the analysis through unit tests.
In Visual S tudio, choose File &gt; New &gt; Pr oject...  to display the New Project dialog.
Under Visual C# &gt; Ext ensibility , choose Analyzer with code fix (.NE T Standar d).
Name your project &quot; MakeConst &quot; and click OK.Install using the Visual Studio Installer - Individual
components tab
Create the solutio n
７ Note
You may get a compilation error ( MSB4062: The &quot;C ompareBuildT askVersion&quot; t ask
could not be lo aded&quot; ). To fix this, update the NuGet packages in the solution withThe analyzer with code fix template creates five projects:
MakeConst , which contains the analyzer.
MakeConst.CodeFix es, which contains the code fix.
MakeConst.P ackage , which is used to produce NuGet package for the analyzer
and code fix.
MakeConst.T est, which is a unit test project.
MakeConst.V six, which is the default startup project that starts a second instance
of Visual S tudio that has loaded your new analyzer. Press F5 to start the VSIX
project.
In the second Visual S tudio instance that you just started, create a new C# Console
Application project (any target framework will work -- analyzers work at the sourceNuGet P ackage Manager or use Update-Package in the P ackage Manager Console
window.
Explore the analyzer template
７ Note
Analyzers should target .NET S tandard 2.0 because they can run in .NET Core
environment (command line builds) and .NET Framework environment (Visual
Studio).
 Tip
When you run your analyzer, you start a second copy of Visual S tudio. This second
copy uses a different registry hive to store settings. That enables you to
differentiate the visual settings in the two copies of Visual S tudio. Y ou can pick a
different theme for the experimental run of Visual S tudio. In addition, don't roam
your settings or login to your Visual S tudio account using the experimental run of
Visual S tudio. That keeps the settings different.
The hive includes not only the analyzer under development, but also any previous
analyzers opened. T o reset R oslyn hive, you need to manually delete it from
%LocalAppDat a%\Micr osoft\VisualS tudio . The folder name of R oslyn hive will end in
Roslyn, for example, 16.0_9ae182f9Roslyn. Note that you may need to clean the
solution and rebuild it after deleting the hive.level.) Hover over the token with a wavy underline, and the warning text provided by an
analyzer appears.
The template creates an analyzer that reports a warning on each type declaration where
the type name contains lowercase letters, as shown in the following figure:
The template also provides a code fix that changes any type name containing lower case
characters to all upper case. Y ou can click on the light bulb displayed with the warning
to see the suggested changes. Accepting the suggested changes updates the type name
and all references to that type in the solution. Now that you've seen the initial analyzer
in action, close the second Visual S tudio instance and return to your analyzer project.
You don't have to start a second copy of Visual S tudio and create new code to test every
change in your analyzer. The template also creates a unit test project for you. That
project contains two tests. TestMethod1 shows the typical format of a test that analyzes
code without triggering a diagnostic. TestMethod2 shows the format of a test that
triggers a diagnostic, and then applies a suggested code fix. As you build your analyzer
and code fix, you'll write tests for different code structures to verify your work. Unit tests
for analyzers are much quicker than testing them interactively with Visual S tudio.
In this tutorial, you write an analyzer that reports to the user any local variable
declarations that can be converted to local constants. For example, consider the
following code:
C# Tip
Analyzer unit tests are a great tool when you know what code constructs should
and shouldn't trigger your analyzer. Loading your analyzer in another copy of
Visual S tudio is a great tool to explore and find constructs you may not have
thought about yet.In the code above, x is assigned a constant value and is never modified. It can be
declared using the const modifier:
C#
The analysis to determine whether a variable can be made constant is involved,
requiring syntactic analysis, constant analysis of the initializer expression and dataflow
analysis to ensure that the variable is never written to. The .NET Compiler Platform
provides APIs that make it easier to perform this analysis.
The template creates the initial DiagnosticAnalyzer class, in the MakeConstAnalyzer .cs
file. This initial analyzer shows two important properties of every analyzer.
Every diagnostic analyzer must provide a [DiagnosticAnalyzer] attribute that
describes the language it operates on.
Every diagnostic analyzer must derive (directly or indirectly) from the
DiagnosticAnalyzer  class.
The template also shows the basic features that are part of any analyzer:</li>
<li>Register actions. The actions represent code changes that should trigger your
analyzer to examine code for violations. When Visual S tudio detects code edits that
match a registered action, it calls your analyzer's registered method.</li>
<li>Create diagnostics. When your analyzer detects a violation, it creates a diagnostic
object that Visual S tudio uses to notify the user of the violation.
You register actions in your override of DiagnosticAnalyzer.Initialize(AnalysisContext)
method. In this tutorial, you'll visit syntax nodes  looking for local declarations, and see
which of those have constant values. If a declaration could be constant, your analyzer
will create and report a diagnostic.
The first step is to update the registration constants and Initialize method so these
constants indicate your &quot;Make Const&quot; analyzer. Most of the string constants are defined
in the string resource file. Y ou should follow that practice for easier localization. Openint x = 0; 
Console.WriteLine(x);<br />
const int x = 0; 
Console.WriteLine(x);<br />
Create analyzer registrationsthe Resources.resx file for the MakeConst  analyzer project. This displays the resource
editor. Update the string resources as follows:
Change AnalyzerDescription to &quot;Variables that are not modified should be made
constants. &quot;.
Change AnalyzerMessageFormat to &quot;Variable '{0}' can be made constant &quot;.
Change AnalyzerTitle to &quot;Variable can be made constant &quot;.
When you have finished, the resource editor should appear as shown in the following
figure:
The remaining changes are in the analyzer file. Open MakeConstAnalyzer .cs in Visual
Studio. Change the registered action from one that acts on symbols to one that acts on
syntax. In the MakeConstAnalyzerAnalyzer.Initialize method, find the line that registers
the action on symbols:
C#
Replace it with the following line:
C#
After that change, you can delete the AnalyzeSymbol method. This analyzer examines
SyntaxKind.LocalDeclarationS tatement , not SymbolKind.NamedT ype statements. Notice
that AnalyzeNode has red squiggles under it. The code you just added references an
AnalyzeNode method that hasn't been declared. Declare that method using the following
code:
C#context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);<br />
context.RegisterSyntaxNodeAction(AnalyzeNode,<br />
SyntaxKind.LocalDeclarationStatement);<br />
private void AnalyzeNode (SyntaxNodeAnalysisContext context ) 
{ 
} Change the Category to &quot;Usage &quot; in MakeConstAnalyzer .cs as shown in the following
code:
C#
It's time to write the first version of the AnalyzeNode method. It should look for a single
local declaration that could be const but is not, like the following code:
C#
The first step is to find local declarations. Add the following code to AnalyzeNode in
MakeConstAnalyzer .cs:
C#
This cast always succeeds because your analyzer registered for changes to local
declarations, and only local declarations. No other node type triggers a call to your
AnalyzeNode method. Next, check the declaration for any const modifiers. If you find
them, return immediately. The following code looks for any const modifiers on the local
declaration:
C#
Finally, you need to check that the variable could be const. That means making sure it is
never assigned after it is initialized.private const string Category = &quot;Usage&quot;; 
Find local declarations that could be const
int x = 0; 
Console.WriteLine(x);<br />
var localDeclaration = (LocalDeclarationStatementSyntax)context.Node;<br />
// make sure the declaration isn't already const:<br />
if (localDeclaration.Modifiers.Any(SyntaxKind.ConstKeyword))<br />
{ 
return; 
} You'll perform some semantic analysis using the SyntaxNodeAnalysisContext . You use
the context argument to determine whether the local variable declaration can be made
const. A Microsoft.CodeAnalysis.SemanticModel  represents all of semantic information
in a single source file. Y ou can learn more in the article that covers semantic models .
You'll use the Microsoft.CodeAnalysis.SemanticModel  to perform data flow analysis on
the local declaration statement. Then, you use the results of this data flow analysis to
ensure that the local variable isn't written with a new value anywhere else. Call the
GetDeclaredS ymbol  extension method to retrieve the ILocalS ymbol  for the variable and
check that it isn't contained with the DataFlowAnalysis.WrittenOutside  collection of the
data flow analysis. Add the following code to the end of the AnalyzeNode method:
C#
The code just added ensures that the variable isn't modified, and can therefore be made
const. It's time to raise the diagnostic. Add the following code as the last line in
AnalyzeNode:
C#
You can check your progress by pressing F5 to run your analyzer. Y ou can load the
console application you created earlier and then add the following test code:
C#// Perform data flow analysis on the local declaration.<br />
DataFlowAnalysis dataFlowAnalysis =<br />
context.SemanticModel.AnalyzeDataFlow(localDeclaration);<br />
// Retrieve the local symbol for each variable in the local declaration<br />
// and ensure that it is not written outside of the data flow analysis<br />
region. 
VariableDeclaratorSyntax variable =<br />
localDeclaration.Declaration.Variables.Single();<br />
ISymbol variableSymbol = context.SemanticModel.GetDeclaredSymbol(variable,<br />
context.CancellationToken);<br />
if (dataFlowAnalysis.WrittenOutside.Contains(variableSymbol))<br />
{ 
return; 
} 
context.ReportDiagnostic(Diagnostic.Create(Rule, context.Node.GetLocation(),<br />
localDeclaration.Declaration.Variables.First().Identifier.ValueText));<br />
int x = 0; 
Console.WriteLine(x);  The light bulb should appear, and your analyzer should report a diagnostic. However,
depending on your version of Visual S tudio, you'll either see:
The light bulb, which still uses the template generated code fix, will tell you it can
be made upper case.
A banner message at the top of the editor saying the 'MakeConstCodeFixProvider'
encountered an error and has been disabled.'. This is because the code fix provider
hasn't yet been changed and still expects to find TypeDeclarationSyntax elements
instead of LocalDeclarationStatementSyntax elements.
The next section explains how to write the code fix.
An analyzer can provide one or more code fixes. A code fix defines an edit that
addresses the reported issue. For the analyzer that you created, you can provide a code
fix that inserts the const keyword:
diff
The user chooses it from the light bulb UI in the editor and Visual S tudio changes the
code.
Open CodeFixR esources.resx file and change CodeFixTitle to &quot;Make constant &quot;.
Open the MakeConstC odeFixPr ovider.cs file added by the template. This code fix is
already wired up to the Diagnostic ID produced by your diagnostic analyzer, but it
doesn't yet implement the right code transform.
Next, delete the MakeUppercaseAsync method. It no longer applies.
All code fix providers derive from CodeFixProvider . They all override
CodeFixProvider.R egisterCodeFixesAsync(CodeFixContext)  to report available code fixes.
In RegisterCodeFixesAsync, change the ancestor node type you're searching for to a
LocalDeclarationS tatementS yntax  to match the diagnostic:
C#Write the code fix</li>
</ol>
<ul>
<li>int x = 0;</li>
</ul>
<ul>
<li>const int x = 0;<br />
Console.WriteLine(x);<br />
var declaration =<br />
root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType&lt;LocalDNext, change the last line to register a code fix. Y our fix will create a new document that
results from adding the const modifier to an existing declaration:
C#
You'll notice red squiggles in the code you just added on the symbol MakeConstAsync.
Add a declaration for MakeConstAsync like the following code:
C#
Your new MakeConstAsync method will transform the Document  representing the user's
source file into a new Document  that now contains a const declaration.
You create a new const keyword token to insert at the front of the declaration
statement. Be careful to first remove any leading trivia from the first token of the
declaration statement and attach it to the const token. Add the following code to the
MakeConstAsync method:
C#eclarationStatementSyntax&gt;().First();<br />
// Register a code action that will invoke the fix.<br />
context.RegisterCodeFix(<br />
CodeAction.Create(<br />
title: CodeFixResources.CodeFixTitle,<br />
createChangedDocument: c =&gt; MakeConstAsync(context.Document,<br />
declaration, c),<br />
equivalenceKey: nameof(CodeFixResources.CodeFixTitle)),<br />
diagnostic);<br />
private static async Task<Document> MakeConstAsync (Document document,<br />
LocalDeclarationStatementSyntax localDeclaration,<br />
CancellationToken cancellationToken ) 
{ 
} 
// Remove the leading trivia from the local declaration.<br />
SyntaxToken firstToken = localDeclaration.GetFirstToken();<br />
SyntaxTriviaList leadingTrivia = firstToken.LeadingTrivia;<br />
LocalDeclarationStatementSyntax trimmedLocal =<br />
localDeclaration.ReplaceToken(<br />
firstToken, firstToken.WithLeadingTrivia(SyntaxTriviaList.Empty));<br />
// Create a const token with the leading trivia.<br />
SyntaxToken constToken = SyntaxFactory.Token(leadingTrivia,  Next, add the const token to the declaration using the following code:
C#
Next, format the new declaration to match C# formatting rules. Formatting your
changes to match existing code creates a better experience. Add the following
statement immediately after the existing code:
C#
A new namespace is required for this code. Add the following using directive to the top
of the file:
C#
The final step is to make your edit. There are three steps to this process:</li>
</ul>
<ol>
<li>Get a handle to the existing document.</li>
<li>Create a new document by replacing the existing declaration with the new
declaration.</li>
<li>Return the new document.
Add the following code to the end of the MakeConstAsync method:
C#SyntaxKind.ConstKeyword,<br />
SyntaxFactory.TriviaList(SyntaxFactory.ElasticMarker));<br />
// Insert the const token into the modifiers list, creating a new modifiers<br />
list. 
SyntaxTokenList newModifiers = trimmedLocal.Modifiers.Insert( 0, constToken);<br />
// Produce the new local declaration.<br />
LocalDeclarationStatementSyntax newLocal = trimmedLocal<br />
.WithModifiers(newModifiers)<br />
.WithDeclaration(localDeclaration.Declaration);<br />
// Add an annotation to format the new local declaration.<br />
LocalDeclarationStatementSyntax formattedLocal =<br />
newLocal.WithAdditionalAnnotations(Formatter.Annotation);<br />
using Microsoft.CodeAnalysis.Formatting;<br />
// Replace the old local declaration with the new local declaration.<br />
SyntaxNode oldRoot = await 
document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait( false); Your code fix is ready to try. Press F5 to run the analyzer project in a second instance of
Visual S tudio. In the second Visual S tudio instance, create a new C# Console Application
project and add a few local variable declarations initialized with constant values to the
Main method. Y ou'll see that they are reported as warnings as below.
You've made a lot of progress. There are squiggles under the declarations that can be
made const. But there is still work to do. This works fine if you add const to the
declarations starting with i, then j and finally k. But, if you add the const modifier in
a different order, starting with k, your analyzer creates errors: k can't be declared
const, unless i and j are both already const. You've got to do more analysis to ensure
you handle the different ways variables can be declared and initialized.
Your analyzer and code fix work on a simple case of a single declaration that can be
made const. There are numerous possible declaration statements where this
implementation makes mistakes. Y ou'll address these cases by working with the unit test
library written by the template. It's much faster than repeatedly opening a second copy
of Visual S tudio.
Open the MakeConstUnitT ests.cs  file in the unit test project. The template created two
tests that follow the two common patterns for an analyzer and code fix unit test.
TestMethod1 shows the pattern for a test that ensures the analyzer doesn't report a
diagnostic when it shouldn't. TestMethod2 shows the pattern for reporting a diagnostic
and running the code fix.
The template uses Microsoft.CodeAnalysis.T esting  packages for unit testing.SyntaxNode newRoot = oldRoot.ReplaceNode(localDeclaration, formattedLocal);<br />
// Return document with transformed tree.<br />
return document.WithSyntaxRoot(newRoot);<br />
Build unit tests
 Tip
The testing library supports a special markup syntax, including the following:Replace the template tests in the MakeConstUnitTest class with the following test
method:
C#
Run this test to make sure it passes. In Visual S tudio, open the Test Explor er by selecting
Test &gt; Windows  &gt; Test Explor er. Then select Run All .
As a general rule, analyzers should exit as quickly as possible, doing minimal work.
Visual S tudio calls registered analyzers as the user edits code. R esponsiveness is a key[|text|]: indicates that a diagnostic is reported for text. By default, this
form may only be used for testing analyzers with exactly one
DiagnosticDescriptor provided by DiagnosticAnalyzer.SupportedDiagnostics.
{|ExpectedDiagnosticId:text|}: indicates that a diagnostic with Id
ExpectedDiagnosticId is reported for text.
[ TestMethod ] 
public async Task LocalIntCouldBeConstant_Diagnostic () 
{<br />
await VerifyCS.VerifyCodeFixAsync( @&quot; 
using System;<br />
class Program<br />
{ 
static void Main()<br />
{ 
[|int i = 0;|]<br />
Console.WriteLine(i);<br />
} 
} 
&quot;, @&quot; 
using System;<br />
class Program<br />
{ 
static void Main()<br />
{ 
const int i = 0;<br />
Console.WriteLine(i);<br />
} 
} 
&quot;); 
}<br />
Create tests for valid declarationsrequirement. There are several test cases for code that should not raise your diagnostic.
Your analyzer already handles one of those tests, the case where a variable is assigned
after being initialized. Add the following test method to represent that case:
C#
This test passes as well. Next, add test methods for conditions you haven't handled yet:
Declarations that are already const, because they are already const:
C#
Declarations that have no initializer, because there is no value to use:
C#        [ TestMethod ] 
public async Task VariableIsAssigned_NoDiagnostic () 
{<br />
await VerifyCS.VerifyAnalyzerAsync( @&quot; 
using System;<br />
class Program<br />
{ 
static void Main()<br />
{ 
int i = 0;<br />
Console.WriteLine(i++);<br />
} 
} 
&quot;); 
}<br />
[ TestMethod ] 
public async Task VariableIsAlreadyConst_NoDiagnostic () 
{<br />
await VerifyCS.VerifyAnalyzerAsync( @&quot; 
using System;<br />
class Program<br />
{ 
static void Main()<br />
{ 
const int i = 0;<br />
Console.WriteLine(i);<br />
} 
} 
&quot;); 
}  Declarations where the initializer is not a constant, because they can't be compile-
time constants:
C#
It can be even more complicated because C# allows multiple declarations as one
statement. Consider the following test case string constant:
C#        [ TestMethod ] 
public async Task NoInitializer_NoDiagnostic () 
{<br />
await VerifyCS.VerifyAnalyzerAsync( @&quot; 
using System;<br />
class Program<br />
{ 
static void Main()<br />
{ 
int i;<br />
i = 0;<br />
Console.WriteLine(i);<br />
} 
} 
&quot;); 
}<br />
[ TestMethod ] 
public async Task InitializerIsNotConstant_NoDiagnostic () 
{<br />
await VerifyCS.VerifyAnalyzerAsync( @&quot; 
using System;<br />
class Program<br />
{ 
static void Main()<br />
{ 
int i = DateTime.Now.DayOfYear;<br />
Console.WriteLine(i);<br />
} 
} 
&quot;); 
}<br />
[ TestMethod ] 
public async Task MultipleInitializers_NoDiagnostic () 
{<br />
await VerifyCS.VerifyAnalyzerAsync( @&quot; 
using System;  The variable i can be made constant, but the variable j cannot. Therefore, this
statement cannot be made a const declaration.
Run your tests again, and you'll see these new test cases fail.
You need some enhancements to your analyzer's AnalyzeNode method to filter out code
that matches these conditions. They are all related conditions, so similar changes will fix
all these conditions. Make the following changes to AnalyzeNode:
Your semantic analysis examined a single variable declaration. This code needs to
be in a foreach loop that examines all the variables declared in the same
statement.
Each declared variable needs to have an initializer.
Each declared variable's initializer must be a compile-time constant.
In your AnalyzeNode method, replace the original semantic analysis:
C#class Program<br />
{ 
static void Main()<br />
{ 
int i = 0, j = DateTime.Now.DayOfYear;<br />
Console.WriteLine(i);<br />
Console.WriteLine(j);<br />
} 
} 
&quot;); 
}<br />
Update your analyzer to ignore correct
declarations
// Perform data flow analysis on the local declaration.<br />
DataFlowAnalysis dataFlowAnalysis =<br />
context.SemanticModel.AnalyzeDataFlow(localDeclaration);<br />
// Retrieve the local symbol for each variable in the local declaration<br />
// and ensure that it is not written outside of the data flow analysis<br />
region. 
VariableDeclaratorSyntax variable =<br />
localDeclaration.Declaration.Variables.Single();<br />
ISymbol variableSymbol = context.SemanticModel.GetDeclaredSymbol(variable,<br />
context.CancellationToken);<br />
if (dataFlowAnalysis.WrittenOutside.Contains(variableSymbol))  with the following code snippet:
C#
The first foreach loop examines each variable declaration using syntactic analysis. The
first check guarantees that the variable has an initializer. The second check guarantees
that the initializer is a constant. The second loop has the original semantic analysis. The{ 
return; 
} 
// Ensure that all variables in the local declaration have initializers that<br />
// are assigned with constant values.<br />
foreach (VariableDeclaratorSyntax variable in 
localDeclaration.Declaration.Variables)<br />
{ 
EqualsValueClauseSyntax initializer = variable.Initializer;<br />
if (initializer == null) 
{ 
return; 
} 
Optional&lt; object&gt; constantValue =<br />
context.SemanticModel.GetConstantValue(initializer.Value,<br />
context.CancellationToken);<br />
if (!constantValue.HasValue)<br />
{ 
return; 
} 
} 
// Perform data flow analysis on the local declaration.<br />
DataFlowAnalysis dataFlowAnalysis =<br />
context.SemanticModel.AnalyzeDataFlow(localDeclaration);<br />
foreach (VariableDeclaratorSyntax variable in 
localDeclaration.Declaration.Variables)<br />
{ 
// Retrieve the local symbol for each variable in the local declaration<br />
// and ensure that it is not written outside of the data flow analysis<br />
region. 
ISymbol variableSymbol =<br />
context.SemanticModel.GetDeclaredSymbol(variable,<br />
context.CancellationToken);<br />
if (dataFlowAnalysis.WrittenOutside.Contains(variableSymbol))<br />
{ 
return; 
} 
} semantic checks are in a separate loop because it has a greater impact on performance.
Run your tests again, and you should see them all pass.
You're almost done. There are a few more conditions for your analyzer to handle. Visual
Studio calls analyzers while the user is writing code. It's often the case that your analyzer
will be called for code that doesn't compile. The diagnostic analyzer's AnalyzeNode
method does not check to see if the constant value is convertible to the variable type.
So, the current implementation will happily convert an incorrect declaration such as int
i = &quot;abc&quot; to a local constant. Add a test method for this case:
C#
In addition, reference types are not handled properly. The only constant value allowed
for a reference type is null, except in the case of System.S tring , which allows string
literals. In other words, const string s = &quot;abc&quot; is legal, but const object s = &quot;abc&quot; is
not. This code snippet verifies that condition:
C#Add the final polish
[ TestMethod ] 
public async Task DeclarationIsInvalid_NoDiagnostic () 
{<br />
await VerifyCS.VerifyAnalyzerAsync( @&quot; 
using System;<br />
class Program<br />
{ 
static void Main()<br />
{ 
int x = {|CS0029:&quot;&quot;abc&quot;&quot;|};<br />
} 
} 
&quot;); 
}<br />
[ TestMethod ] 
public async Task DeclarationIsNotString_NoDiagnostic () 
{<br />
await VerifyCS.VerifyAnalyzerAsync( @&quot; 
using System;<br />
class Program<br />
{ 
static void Main()<br />
{ To be thorough, you need to add another test to make sure that you can create a
constant declaration for a string. The following snippet defines both the code that raises
the diagnostic, and the code after the fix has been applied:
C#
Finally, if a variable is declared with the var keyword, the code fix does the wrong thing
and generates a const var declaration, which is not supported by the C# language. T o
fix this bug, the code fix must replace the var keyword with the inferred type's name:
C#        object s = &quot;&quot;abc&quot;&quot;;<br />
} 
} 
&quot;); 
}<br />
[ TestMethod ] 
public async Task StringCouldBeConstant_Diagnostic () 
{<br />
await VerifyCS.VerifyCodeFixAsync( @&quot; 
using System;<br />
class Program<br />
{ 
static void Main()<br />
{ 
[|string s = &quot;&quot;abc&quot;&quot;;|]<br />
} 
} 
&quot;, @&quot; 
using System;<br />
class Program<br />
{ 
static void Main()<br />
{ 
const string s = &quot;&quot;abc&quot;&quot;;
} 
} 
&quot;); 
}<br />
[ TestMethod ] 
public async Task VarIntDeclarationCouldBeConstant_Diagnostic () 
{<br />
await VerifyCS.VerifyCodeFixAsync( @&quot; 
using System;  Fortunately, all of the above bugs can be addressed using the same techniques that you
just learned.
To fix the first bug, first open MakeConstAnalyzer .cs and locate the foreach loop where
each of the local declaration's initializers are checked to ensure that they're assigned
with constant values. Immediately befor e the first foreach loop, callclass Program<br />
{ 
static void Main()<br />
{ 
[|var item = 4;|]<br />
} 
} 
&quot;, @&quot; 
using System;<br />
class Program<br />
{ 
static void Main()<br />
{ 
const int item = 4;<br />
} 
} 
&quot;); 
}<br />
[ TestMethod ] 
public async Task VarStringDeclarationCouldBeConstant_Diagnostic () 
{<br />
await VerifyCS.VerifyCodeFixAsync( @&quot; 
using System;<br />
class Program<br />
{ 
static void Main()<br />
{ 
[|var item = &quot;&quot;abc&quot;&quot;;|]<br />
} 
} 
&quot;, @&quot; 
using System;<br />
class Program<br />
{ 
static void Main()<br />
{ 
const string item = &quot;&quot;abc&quot;&quot;;<br />
} 
} 
&quot;); 
}  context.SemanticModel.GetTypeInfo() to retrieve detailed information about the
declared type of the local declaration:
C#
Then, inside your foreach loop, check each initializer to make sure it's convertible to the
variable type. Add the following check after ensuring that the initializer is a constant:
C#
The next change builds upon the last one. Before the closing curly brace of the first
foreach loop, add the following code to check the type of the local declaration when the
constant is a string or null.
C#TypeSyntax variableTypeName = localDeclaration.Declaration.Type;<br />
ITypeSymbol variableType =<br />
context.SemanticModel.GetTypeInfo(variableTypeName,<br />
context.CancellationToken).ConvertedType;<br />
// Ensure that the initializer value can be converted to the type of the<br />
// local declaration without a user-defined conversion.<br />
Conversion conversion =<br />
context.SemanticModel.ClassifyConversion(initializer.Value, variableType);<br />
if (!conversion.Exists || conversion.IsUserDefined)<br />
{ 
return; 
} 
// Special cases:<br />
//  * If the constant value is a string, the type of the local declaration<br />
//    must be System.String.<br />
//  * If the constant value is null, the type of the local declaration must<br />
//    be a reference type.<br />
if (constantValue.Value is string) 
{ 
if (variableType.SpecialType != SpecialType.System_String)<br />
{ 
return; 
} 
} 
else if (variableType.IsReferenceType &amp;&amp; constantValue.Value != null) 
{ 
return; 
} You must write a bit more code in your code fix provider to replace the var keyword
with the correct type name. R eturn to MakeConstC odeFixPr ovider.cs. The code you'll add
does the following steps:
Check if the declaration is a var declaration, and if it is:
Create a new type for the inferred type.
Make sure the type declaration is not an alias. If so, it is legal to declare const var.
Make sure that var isn't a type name in this program. (If so, const var is legal).
Simplify the full type name
That sounds like a lot of code. It's not. R eplace the line that declares and initializes
newLocal with the following code. It goes immediately after the initialization of
newModifiers:
C#
// If the type of the declaration is 'var', create a new type name<br />
// for the inferred type.<br />
VariableDeclarationSyntax variableDeclaration =<br />
localDeclaration.Declaration;<br />
TypeSyntax variableTypeName = variableDeclaration.Type;<br />
if (variableTypeName.IsVar)<br />
{ 
SemanticModel semanticModel = await 
document.GetSemanticModelAsync(cancellationToken).ConfigureAwait( false); 
// Special case: Ensure that 'var' isn't actually an alias to another<br />
type 
// (e.g. using var = System.String).<br />
IAliasSymbol aliasInfo = semanticModel.GetAliasInfo(variableTypeName,<br />
cancellationToken);<br />
if (aliasInfo == null) 
{ 
// Retrieve the type inferred for var.<br />
ITypeSymbol type = semanticModel.GetTypeInfo(variableTypeName,<br />
cancellationToken).ConvertedType;
// Special case: Ensure that 'var' isn't actually a type named<br />
'var'. </li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C-sharp-docs/part2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../C-sharp-docs/part4.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C-sharp-docs/part2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../C-sharp-docs/part4.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
