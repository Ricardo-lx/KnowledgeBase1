<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Csharp7 - KnowledgeBase</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Scrapy/Scrapy.html"><strong aria-hidden="true">1.</strong> Scrapy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Scrapy/Scrapy1.html"><strong aria-hidden="true">1.1.</strong> Scrapy1</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy2.html"><strong aria-hidden="true">1.2.</strong> Scrapy2</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy3.html"><strong aria-hidden="true">1.3.</strong> Scrapy3</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy4.html"><strong aria-hidden="true">1.4.</strong> Scrapy4</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy5.html"><strong aria-hidden="true">1.5.</strong> Scrapy5</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy6.html"><strong aria-hidden="true">1.6.</strong> Scrapy6</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy7.html"><strong aria-hidden="true">1.7.</strong> Scrapy7</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy8.html"><strong aria-hidden="true">1.8.</strong> Scrapy8</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy9.html"><strong aria-hidden="true">1.9.</strong> Scrapy9</a></li><li class="chapter-item expanded "><a href="../Scrapy/Scrapy10.html"><strong aria-hidden="true">1.10.</strong> Scrapy10</a></li></ol></li><li class="chapter-item expanded "><a href="../ThinkPython/ThinkPython.html"><strong aria-hidden="true">2.</strong> ThinkPython</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ThinkPython/part_1.html"><strong aria-hidden="true">2.1.</strong> ThinkPython1</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_2.html"><strong aria-hidden="true">2.2.</strong> ThinkPython2</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_3.html"><strong aria-hidden="true">2.3.</strong> ThinkPython3</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_4.html"><strong aria-hidden="true">2.4.</strong> ThinkPython4</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_5.html"><strong aria-hidden="true">2.5.</strong> ThinkPython5</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_6.html"><strong aria-hidden="true">2.6.</strong> ThinkPython6</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_7.html"><strong aria-hidden="true">2.7.</strong> ThinkPython7</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_8.html"><strong aria-hidden="true">2.8.</strong> ThinkPython8</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_9.html"><strong aria-hidden="true">2.9.</strong> ThinkPython9</a></li><li class="chapter-item expanded "><a href="../ThinkPython/part_10.html"><strong aria-hidden="true">2.10.</strong> ThinkPython10</a></li></ol></li><li class="chapter-item expanded "><a href="../C-sharp-docs/C-sharp-docs.html"><strong aria-hidden="true">3.</strong> C-sharp-docs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../C-sharp-docs/part1.html"><strong aria-hidden="true">3.1.</strong> Csharp1</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part2.html"><strong aria-hidden="true">3.2.</strong> Csharp2</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part3.html"><strong aria-hidden="true">3.3.</strong> Csharp3</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part4.html"><strong aria-hidden="true">3.4.</strong> Csharp4</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part5.html"><strong aria-hidden="true">3.5.</strong> Csharp5</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part6.html"><strong aria-hidden="true">3.6.</strong> Csharp6</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part7.html" class="active"><strong aria-hidden="true">3.7.</strong> Csharp7</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part8.html"><strong aria-hidden="true">3.8.</strong> Csharp8</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part9.html"><strong aria-hidden="true">3.9.</strong> Csharp9</a></li><li class="chapter-item expanded "><a href="../C-sharp-docs/part10.html"><strong aria-hidden="true">3.10.</strong> Csharp10</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">KnowledgeBase</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Two conditional compilation symbols are considered the same if they are identical after
the following transformations are applied, in order:
Each Unicode_Es cape_Sequenc e is transformed into its corresponding Unicode
character.
Any Formatting_Char acters are removed.
A conditional compilation symbol has two possible states: defined or undef ined. At the
beginning of the lexical processing of a compilation unit, a conditional compilation
symbol is undefined unless it has been explicitly defined by an external mechanism
(such as a command-line compiler option). When a #define directive is processed, the
conditional compilation symbol named in that directive becomes defined in that
compilation unit. The symbol remains defined until a #undef directive for that same
symbol is processed, or until the end of the compilation unit is reached. An implication
of this is that #define and #undef directives in one compilation unit have no effect on
other compilation units in the same program.
When referenced in a pre-processing expression ( §6.5.3 ), a defined conditional
compilation symbol has the Boolean value true, and an undefined conditional
compilation symbol has the Boolean value false. There is no requirement that
conditional compilation symbols be explicitly declared before they are referenced in
pre-processing expressions. Instead, undeclared symbols are simply undefined and thus
have the value false.
The namespace for conditional compilation symbols is distinct and separate from all
other named entities in a C# program. Conditional compilation symbols can only be
referenced in #define and #undef directives and in pre-processing expressions.fragment  PP_Conditional_Symbol
// Must not be equal to tokens TRUE or FALSE. See note below.
: Basic_Identifier
;Pre-processing expressions can occur in #if and #elif directives. The operators  !, ==,
!=, &amp;&amp;, and || are permitted in pre-processing expressions, and parentheses may be
used for grouping.
ANTLR
When referenced in a pre-processing expression, a defined conditional compilation
symbol has the Boolean value true, and an undefined conditional compilation symbol
has the Boolean value false.
Evaluation of a pre-processing expression always yields a Boolean value. The rules of
evaluation for a pre-processing expression are the same as those for a constant
expression ( §12.23 ), except that the only user-defined entities that can be referenced are
conditional compilation symbols.6.5.3 Pre-processing expressions
fragment  PP_Expression
: PP_Whitespace? PP_Or_Expression PP_Whitespace?
;</p>
<p>fragment  PP_Or_Expression
: PP_And_Expression (PP_Whitespace? '||' PP_Whitespace?<br />
PP_And_Expression)*
;</p>
<p>fragment  PP_And_Expression
: PP_Equality_Expression (PP_Whitespace? '&amp;&amp;' PP_Whitespace?
PP_Equality_Expression)*
;
fragment  PP_Equality_Expression
: PP_Unary_Expression (PP_Whitespace? ( '==' | '!=') PP_Whitespace?
PP_Unary_Expression)*
;</p>
<p>fragment  PP_Unary_Expression
: PP_Primary_Expression
| '!' PP_Whitespace? PP_Unary_Expression
;</p>
<p>fragment  PP_Primary_Expression
: TRUE
| FALSE
| PP_Conditional_Symbol
| '(' PP_Whitespace? PP_Expression PP_Whitespace? ')'
;The definition directives are used to define or undefine conditional compilation symbols.
ANTLR
The processing of a #define directive causes the given conditional compilation symbol
to become defined, starting with the source line that follows the directive. Likewise, the
processing of a #undef directive causes the given conditional compilation symbol to
become undefined, starting with the source line that follows the directive.
Any #define and #undef directives in a compilation unit shall occur before the first
token (§6.4) in the compilation unit; otherwise a compile-time error occurs. In intuitive
terms, #define and #undef directives shall precede any “real code” in the compilation
unit.
Example : The example:
C#
is valid because the #define directives precede the first token (the namespace
keyword) in the compilation unit.
end ex ample
Example : The following example results in a compile-time error because a #define
follows real code:
C#6.5.4 Definition directives
fragment  PP_Declaration
: 'define'  PP_Whitespace PP_Conditional_Symbol
| 'undef' PP_Whitespace PP_Conditional_Symbol
;
#define Enterprise
#if Professional || Enterprise
#define Advanced
#endif
namespace  Megacorp.Data
{
#if Advanced
class PivotTable  {...}
#endif
}end ex ample
A #define may define a conditional compilation symbol that is already defined, without
there being any intervening #undef for that symbol.
Example : The example below defines a conditional compilation symbol A and then
defines it again.
C#
For compilers that allow conditional compilation symbols to be defined as
compilation options, an alternative way for such redefinition to occur is to define the
symbol as a compiler option as well as in the source.
end ex ample
A #undef may “undefine” a conditional compilation symbol that is not defined.
Example : The example below defines a conditional compilation symbol  A and then
undefines it twice; although the second #undef has no effect, it is still valid.
C#
end ex ample#define A
namespace  N
{
#define B
#if B
class Class1 {}
#endif
}
#define A
#define A
#define A
#undef A
#undef A
6.5.5 Conditional compilation directivesThe conditional compilation directives are used to conditionally include or exclude
portions of a compilation unit.
ANTLR
Conditional compilation directives shall be written in groups consisting of, in order, a
#if directive, zero or more #elif directives, zero or one #else directive, and a #endif
directive. Between the directives are conditional s ections  of source code. Each section is
controlled by the immediately preceding directive. A conditional section may itself
contain nested conditional compilation directives provided these directives form
complete groups.
At most one of the contained conditional sections is selected for normal lexical
processing:
The PP_Expr ession s of the #if and #elif directives are evaluated in order until
one yields true. If an expression yields true, the conditional section following the
corresponding directive is selected.
If all PP_Expr ession s yield false, and if a #else directive is present, the conditional
section following the #else directive is selected.
Otherwise, no conditional section is selected.
The selected conditional section, if any, is processed as a normal input_s ection : the
source code contained in the section shall adhere to the lexical grammar; tokens arefragment  PP_Conditional
: PP_If_Section
| PP_Elif_Section
| PP_Else_Section
| PP_Endif
;
fragment  PP_If_Section
: 'if' PP_Whitespace PP_Expression
;</p>
<p>fragment  PP_Elif_Section
: 'elif' PP_Whitespace PP_Expression
;</p>
<p>fragment  PP_Else_Section
: 'else'
;</p>
<p>fragment  PP_Endif
: 'endif'
;generated from the source code in the section; and pre-processing directives in the
section have the prescribed effects.
Any remaining conditional sections are skipped and no tokens, except those for pre-
processing directives, are generated from the source code. Therefore skipped source
code, except pre-processing directives, may be lexically incorrect. Skipped pre-
processing directives shall be lexically correct but are not otherwise processed. Within a
conditional section that is being skipped any nested conditional sections (contained in
nested #if...#endif constructs) are also skipped.
Note: The above grammar does not capture the allowance that the conditional
sections between the pre-processing directives may be malformed lexically.
Therefore the grammar is not ANTLR-ready as it only supports lexically correct
input. end not e
Example : The following example illustrates how conditional compilation directives
can nest:
C#
Except for pre-processing directives, skipped source code is not subject to lexical
analysis. For example, the following is valid despite the unterminated comment in
the #else section:
C##define Debug // Debugging on
#undef Trace // Tracing off
class PurchaseTransaction
{
void Commit()
{
#if Debug
CheckConsistency();
#if Trace
WriteToLog( this.ToString());
#endif
#endif
CommitHelper();
}
...
}
#define Debug // Debugging on
class PurchaseTransaction
{Note, however, that pre-processing directives are required to be lexically correct
even in skipped sections of source code.
Pre-processing directives are not processed when they appear inside multi-line
input elements. For example, the program:
C#
results in the output:
Console
In peculiar cases, the set of pre-processing directives that is processed might
depend on the evaluation of the pp_expr ession . The example:
C#    void Commit()
{
#if Debug
CheckConsistency();
#else
/* Do something else
#endif
}
...
}
class Hello
{
static void Main()
{
System.Console.WriteLine( @&quot;hello,
#if Debug
world
#else
Nebraska
#endif
&quot;);
}
}
hello,
#if Debug
world
#else
Nebraska
#endifalways produces the same token stream ( class Q { }), regardless of whether or
not X is defined. If X is defined, the only processed directives are #if and #endif,
due to the multi-line comment. If X is undefined, then three directives ( #if, #else,
#endif) are part of the directive set.
end ex ample
The diagnostic directives are used to generate explicitly error and warning messages
that are reported in the same way as other compile-time errors and warnings.
ANTLR
Example : The example
C#
produces a compile-time error (“A build can’t be both debug and retail”) if the
conditional compilation symbols Debug and Retail are both defined. Note that a
PP_Mess age can contain arbitrary text; specifically, it need not contain well-formed
tokens, as shown by the single quote in the word can't.
end ex ample#if X
/*
#else
/* <em>/ class Q { }
#endif
6.5.6 Diagnostic directives
fragment  PP_Diagnostic
: 'error' PP_Message?
| 'warning'  PP_Message?
;
fragment  PP_Message
: PP_Whitespace Input_Character</em>
;
#if Debug &amp;&amp; Retail
#error A build can't be both debug and retail
#endif
class Test {...}The region directives are used to mark explicitly regions of source code.
ANTLR
No semantic meaning is attached to a region; regions are intended for use by the
programmer or by automated tools to mark a section of source code. There shall be one
#endregion directive matching every #region directive. The message specified in a
#region or #endregion directive likewise has no semantic meaning; it merely serves to
identify the region. Matching #region and #endregion directives may have different
PP_Mess ages.
The lexical processing of a region:
C#
corresponds exactly to the lexical processing of a conditional compilation directive of
the form:
C#
Note: This means that a region can include one or more #if/.../#endif, or be
contained with a conditional section within a #if/.../#endif; but a region cannot6.5.7 Region directives
fragment  PP_Region
: PP_Start_Region
| PP_End_Region
;
fragment  PP_Start_Region
: 'region'  PP_Message?
;
fragment  PP_End_Region
: 'endregion'  PP_Message?
;
#region
...
#endregion
#if true
...
#endifoverlap with an just part of an #if/.../#endif, or start &amp; end in different conditional
sections. end not e
Line directives may be used to alter the line numbers and compilation unit names that
are reported by the compiler in output such as warnings and errors. These values are
also used by caller-info attributes ( §22.5.5 ).
Note: Line directives are most commonly used in meta-programming tools that
generate C# source code from some other text input. end not e
ANTLR
When no #line directives are present, the compiler reports true line numbers and
compilation unit names in its output. When processing a #line directive that includes a
PP_Line_Indicat or that is not default, the compiler treats the line after the directive as
having the given line number (and compilation unit name, if specified).
The maximum value allowed for Decimal_Digit+ is implementation-defined.
A #line default directive undoes the effect of all preceding #line directives. The
compiler reports true line information for subsequent lines, precisely as if no #line
directives had been processed.6.5.8 Line directives
fragment  PP_Line
: 'line' PP_Whitespace PP_Line_Indicator
;
fragment  PP_Line_Indicator
: Decimal_Digit+ PP_Whitespace PP_Compilation_Unit_Name
| Decimal_Digit+
| DEFAULT
| 'hidden'
;</p>
<p>fragment  PP_Compilation_Unit_Name
: '&quot;' PP_Compilation_Unit_Name_Character+ '&quot;'
;</p>
<p>fragment  PP_Compilation_Unit_Name_Character
// Any Input_Character except &quot;
: ~('\u000D'  | '\u000A'    | '\u0085'  | '\u2028'  | '\u2029'  | '#')
;A #line hidden directive has no effect on the compilation unit and line numbers
reported in error messages, or produced by use of CallerLineNumberAttribute
(§22.5.5.2 ). It is intended to affect source-level debugging tools so that, when
debugging, all lines between a #line hidden directive and the subsequent #line
directive (that is not #line hidden) have no line number information, and are skipped
entirely when stepping through code.
Note: Although a PP_C ompilation_Unit_Name  might contain text that looks like an
escape sequence, such text is not an escape sequence; in this context a ‘ \’ character
simply designates an ordinary backslash character. end not e
The #pragma preprocessing directive is used to specify contextual information to a
compiler.
Note: For example, a compiler might provide #pragma directives that
Enable or disable particular warning messages when compiling subsequent
code.
Specify which optimizations to apply to subsequent code.
Specify information to be used by a debugger.
end not e
ANTLR
The Input_Char acters in the PP_Pr agma_T ext are interpreted by the compiler in an
implementation-defined manner. The information supplied in a #pragma directive shall
not change program semantics. A #pragma directive shall only change compiler behavior
that is outside the scope of this language specification. If the compiler cannot interpret
the Input_Char acters, the compiler can produce a warning; however, it shall not produce
a compile-time error.6.5.9 Pragma directives
fragment  PP_Pragma
: 'pragma'  PP_Pragma_Text?
;
fragment  PP_Pragma_Text
: PP_Whitespace Input_Character*
;Note: PP_Pr agma_T ext can contain arbitrary text; specifically, it need not contain
well-formed tokens. end not e
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide .C# Standar d documentation
feedb ack
C# Standard documentation is an
open source project. Select a link to
provide feedback:
 Open a documentation issue
 Provide product feedback7 Basic concepts
Article •04/07/2023
A program may be compiled either as a class libr ary to be used as part of other
applications, or as an application  that may be started directly. The mechanism for
determining this mode of compilation is implementation-specific and external to this
specification.
A program compiled as an application shall contain at least one method qualifying as an
entry point by satisfying the following requirements:
It shall have the name Main.
It shall be static.
It shall not be generic.
It shall be declared in a non-generic type. If the type declaring the method is a
nested type, none of its enclosing types may be generic.
It may have the async modifier provided the method’s return type is
System.Threading.Tasks.Task or System.Threading.Tasks.Task<int>.
The return type shall be void, int, System.Threading.Tasks.Task, or
System.Threading.Tasks.Task<int>.
It shall not be a partial method ( §15.6.9 ) without an implementation.
The formal parameter list shall either be empty, or have a single value parameter of
type string[].
Note: Methods with the async modifier must have exactly one of the two return
types specified above in order to qualify as an entry point. An async void method,
or an async method returning a different awaitable type such as ValueTask or
ValueTask<int> does not qualify as an entry point. end not e
If more than one method qualifying as an entry point is declared within a program, an
external mechanism may be used to specify which method is deemed to be the actual
entry point for the application. If a qualifying method having a return type of int or
void is found, any qualifying method having a return type of
System.Threading.Tasks.Task or System.Threading.Tasks.Task<int> is not considered an
entry point method. It is a compile-time error for a program to be compiled as an
application without exactly one entry point. A program compiled as a class library may7.1 Application startupcontain methods that would qualify as application entry points, but the resulting library
has no entry point.
Ordinarily, the declared accessibility ( §7.5.2 ) of a method is determined by the access
modifiers ( §15.3.6 ) specified in its declaration, and similarly the declared accessibility of a
type is determined by the access modifiers specified in its declaration. In order for a
given method of a given type to be callable, both the type and the member shall be
accessible. However, the application entry point is a special case. Specifically, the
execution environment can access the application’s entry point regardless of its declared
accessibility and regardless of the declared accessibility of its enclosing type
declarations.
When the entry point method has a return type of System.Threading.Tasks.Task or
System.Threading.Tasks.Task<int>, the compiler synthesizes a synchronous entry-point
method that calls the corresponding Main method. The synthesized method has
parameters and return types based on the Main method:
The formal parameter list of the synthesized method is the same as the formal
parameter list of the Main method
If the return type of the Main method is System.Threading.Tasks.Task, the return
type of the synthesized method is void
If the return type of the Main method is System.Threading.Tasks.Task<int>, the
return type of the synthesized method is int
Execution of the synthesized method proceeds as follows:
The synthesized method calls the Main method, passing its string[] parameter
value as an argument if the Main method has such a parameter.
If the Main method throws an exception, the exception is propagated by the
synthesized method.
Otherwise, the synthesized entry point waits for the returned task to complete,
calling GetAwaiter().GetResult() on the task, using either the parameterless
instance method or the extension method described by §C.3. If the task fails,
GetResult() will throw an exception, and this exception is propagated by the
synthesized method.
For a Main method with a return type of System.Threading.Tasks.Task<int>, if the
task completes successfully, the int value returned by GetResult() is returned
from the synthesized method.
The effectiv e entr y point  of an application is the entry point declared within the
program, or the synthesized method if one is required as described above. The returntype of the effective entry point is therefore always void or int.
When an application is run, a new application domain  is created. Several different
instantiations of an application may exist on the same machine at the same time, and
each has its own application domain. An application domain enables application
isolation by acting as a container for application state. An application domain acts as a
container and boundary for the types defined in the application and the class libraries it
uses. T ypes loaded into one application domain are distinct from the same types loaded
into another application domain, and instances of objects are not directly shared
between application domains. For instance, each application domain has its own copy of
static variables for these types, and a static constructor for a type is run at most once
per application domain. Implementations are free to provide implementation-specific
policy or mechanisms for the creation and destruction of application domains.
Application startup occurs when the execution environment calls the application’s
effective entry point. If the effective entry point declares a parameter, then during
application startup, the implementation shall ensure that the initial value of that
parameter is a non-null reference to a string array. This array shall consist of non-null
references to strings, called application p aramet ers, which are given implementation-
defined values by the host environment prior to application startup. The intent is to
supply to the application information determined prior to application startup from
elsewhere in the hosted environment.
Note: On systems supporting a command line, application parameters correspond to
what are generally known as command-line arguments. end not e
If the effective entry point’s return type is int, the return value from the method
invocation by the execution environment is used in application termination ( §7.2).
Other than the situations listed above, entry point methods behave like those that are
not entry points in every respect. In particular, if the entry point is invoked at any other
point during the application’s lifetime, such as by regular method invocation, there is no
special handling of the method: if there is a parameter, it may have an initial value of
null, or a non- null value referring to an array that contains null references. Likewise,
the return value of the entry point has no special significance other than in the
invocation from the execution environment.
Application t ermination  returns control to the execution environment.7.2 Application terminationIf the return type of the application’s effective entry point method is int and execution
completes without resulting in an exception, the value of the int returned serves as the
application’s termination st atus c ode. The purpose of this code is to allow
communication of success or failure to the execution environment. If the return type of
the effective entry point method is void and execution completes without resulting in
an exception, the termination status code is  0.
If the effective entry point method terminates due to an exception ( §21.4 ), the exit code
is implementation-specific. Additionally, the implementation may provide alternative
APIs for specifying the exit code.
Whether or not finalizers ( §15.13 ) are run as part of application termination is
implementation-specific.
Note: The .NET Framework implementation makes every reasonable effort to call
finalizers ( §15.13 ) for all of its objects that have not yet been garbage collected,
unless such cleanup has been suppressed (by a call to the library method
GC.SuppressFinalize, for example). end not e
Declarations in a C# program define the constituent elements of the program.
C# programs are organized using namespaces. These are introduced using namespace
declarations ( §14), which can contain type declarations and nested namespace
declarations. T ype declarations ( §14.7 ) are used to define classes ( §15), structs ( §16),
interfaces ( §18), enums ( §19), and delegates ( §20). The kinds of members permitted in a
type declaration depend on the form of the type declaration. For instance, class
declarations can contain declarations for constants ( §15.4 ), fields ( §15.5 ), methods
(§15.6 ), properties ( §15.7 ), events ( §15.8 ), indexers ( §15.9 ), operators ( §15.10 ), instance
constructors ( §15.11 ), static constructors ( §15.12 ), finalizers ( §15.13 ), and nested types
(§15.3.9 ).
A declaration defines a name in the declar ation sp ace to which the declaration belongs.
It is a compile-time error to have two or more declarations that introduce members with
the same name in a declaration space, except in the following cases:
Two or more namespace declarations with the same name are allowed in the same
declaration space. Such namespace declarations are aggregated to form a single
logical namespace and share a single declaration space.
Declarations in separate programs but in the same namespace declaration space
are allowed to share the same name.7.3 DeclarationsNote: However, these declarations could introduce ambiguities if included in
the same application. end not e
Two or more methods with the same name but distinct signatures are allowed in
the same declaration space ( §7.6).
Two or more type declarations with the same name but distinct numbers of type
parameters are allowed in the same declaration space ( §7.8.2 ).
Two or more type declarations with the partial modifier in the same declaration
space may share the same name, same number of type parameters and same
classification (class, struct or interface). In this case, the type declarations
contribute to a single type and are themselves aggregated to form a single
declaration space ( §15.2.7 ).
A namespace declaration and a type declaration in the same declaration space can
share the same name as long as the type declaration has at least one type
parameter ( §7.8.2 ).
There are several different types of declaration spaces, as described in the following.
Within all compilation units of a program, namesp ace_member_declar ation s with
no enclosing namesp ace_declar ation  are members of a single combined
declaration space called the global declar ation sp ace.
Within all compilation units of a program, namesp ace_member_declar ation s within
namesp ace_declar ation s that have the same fully qualified namespace name are
members of a single combined declaration space.
Each compilation_unit  and namesp ace_body  has an alias declar ation sp ace. Each
extern_alias_dir ective and using_alias_dir ective of the compilation_unit  or
namesp ace_body  contributes a member to the alias declaration space ( §14.5.2 ).
Each non-partial class, struct, or interface declaration creates a new declaration
space. Each partial class, struct, or interface declaration contributes to a declaration
space shared by all matching parts in the same program ( §16.2.4 ). Names are
introduced into this declaration space through class_member_declar ation s,
struct_member_declar ation s, interface_member_declar ation s, or type_p aramet ers.
Except for overloaded instance constructor declarations and static constructor
declarations, a class or struct cannot contain a member declaration with the same
name as the class or struct. A class, struct, or interface permits the declaration of
overloaded methods and indexers. Furthermore, a class or struct permits the
declaration of overloaded instance constructors and operators. For example, a
class, struct, or interface may contain multiple method declarations with the same
name, provided these method declarations differ in their signature ( §7.6). Note that
base classes do not contribute to the declaration space of a class, and base
interfaces do not contribute to the declaration space of an interface. Thus, aderived class or interface is allowed to declare a member with the same name as
an inherited member. Such a member is said to hide the inherited member.
Each delegate declaration creates a new declaration space. Names are introduced
into this declaration space through formal parameters ( fixed_paramet ers and
paramet er_arr ays) and type_p aramet ers.
Each enumeration declaration creates a new declaration space. Names are
introduced into this declaration space through enum_member_declar ations .
Each method declaration, property declaration, property accessor declaration,
indexer declaration, indexer accessor declaration, operator declaration, instance
constructor declaration, anonymous function, and local function creates a new
declaration space called a local v ariable declar ation sp ace. Names are introduced
into this declaration space through formal parameters ( fixed_paramet ers and
paramet er_arr ays) and type_p aramet ers. The set accessor for a property or an
indexer introduces the name value as a formal parameter.
Additional local variable declaration spaces may occur within member declarations,
anonymous functions and local functions. Names are introduced into these
declaration spaces through patterns, declar ation_expr ession s,
declar ation_st atement s and exception_speci fiers. Local variable declaration spaces
may be nested, but it is an error for a local variable declaration space and a nested
local variable declaration space to contain elements with the same name. Thus,
within a nested declaration space it is not possible to declare a local variable, local
function or constant with the same name as a parameter, type parameter, local
variable, local function or constant in an enclosing declaration space. It is possible
for two declaration spaces to contain elements with the same name as long as
neither declaration space contains the other. Local declaration spaces are created
by the following constructs:
Each variable_initializer  in a field and property declaration introduces its own
local variable declaration space, that is not nested within any other local variable
declaration space.
The body of a function member, anonymous function, or local function, if any,
creates a local variable declaration space that is considered to be nested within
the function’s local variable declaration space.
Each constr uctor_initializer  creates a local variable declaration space nested
within the instance constructor declaration. The local variable declaration space
for the constructor body is in turn nested within this local variable declaration
space.
Each block , switch_block , speci fic_cat ch_claus e, iteration_st atement  and
using_st atement  creates a nested local variable declaration space.
Each embedded_st atement  that is not directly part of a statement_list  creates a
nested local variable declaration space.Each switch_section  creates a nested local variable declaration space. However,
variables declared directly within the statement_list  of the switch_section  (but not
within a nested local variable declaration space inside the statement_list ) are
added directly to the local variable declaration space of the enclosing
switch_block , instead of that of the switch_section .
The syntactic translation of a query_expr ession  (§12.20.3 ) may introduce one or
more lambda expressions. As anonymous functions, each of these creates a
local variable declaration space as described above.
Each block  or switch_block  creates a separate declaration space for labels. Names
are introduced into this declaration space through labeled_st atement s, and the
names are referenced through goto_statement s. The label declar ation sp ace of a
block includes any nested blocks. Thus, within a nested block it is not possible to
declare a label with the same name as a label in an enclosing block.
Note: The fact that variables declared directly within a switch_section  are added to
the local variable declaration space of the switch_block  instead of the switch_section
can lead to surprising code. In the example below, the local variable y is in scope
within the switch section for the default case, despite the declaration appearing in
the switch section for case 0.
C#
end not e
The textual order in which names are declared is generally of no significance. In
particular, textual order is not significant for the declaration and use of namespaces,
constants, methods, properties, events, indexers, operators, instance constructors,
finalizers, static constructors, and types. Declaration order is significant in the following
ways:
Declaration order for field declarations determines the order in which their
initializers (if any) are executed ( §15.5.6.2 , §15.5.6.3 ).int x = 1;
switch (x)
{
case 0:
int y;
break;
default:
y = 10;
Console.WriteLine(x + y);
break;
}Local variables shall be defined before they are used ( §7.7).
Declaration order for enum member declarations ( §19.4 ) is significant when
constant_expr ession  values are omitted.
Example : The declaration space of a namespace is “open ended”, and two
namespace declarations with the same fully qualified name contribute to the same
declaration space. For example
C#
The two namespace declarations above contribute to the same declaration space, in
this case declaring two classes with the fully qualified names
Megacorp.Data.Customer and Megacorp.Data.Order. Because the two declarations
contribute to the same declaration space, it would have caused a compile-time error
if each contained a declaration of a class with the same name.
end ex ample
Note: As specified above, the declaration space of a block includes any nested
blocks. Thus, in the following example, the  F and G methods result in a compile-
time error because the name  i is declared in the outer block and cannot be
redeclared in the inner block. However, the  H and I methods are valid since the
two i’s are declared in separate non-nested blocks.
C#namespace  Megacorp.Data
{
class Customer
{
...
}
}
namespace  Megacorp.Data
{
class Order
{
...
}
}
class A
{
void F()
{end not e
Namespaces and types have member s.        int i = 0;
if (true)
{
int i = 1;
}
}
void G()
{
if (true)
{
int i = 0;
}
int i = 1;
}
void H()
{
if (true)
{
int i = 0;
}
if (true)
{
int i = 1;
}
}
void I()
{
for (int i = 0; i &lt; 10; i++)
{
H();
}
for (int i = 0; i &lt; 10; i++)
{
H();
}
}
}
7.4 Members
7.4.1 GeneralNote: The members of an entity are generally available through the use of a
qualified name that starts with a reference to the entity, followed by a “ .” token,
followed by the name of the member. end not e
Members of a type are either declared in the type declaration or inher ited from the base
class of the type. When a type inherits from a base class, all members of the base class,
except instance constructors, finalizers, and static constructors become members of the
derived type. The declared accessibility of a base class member does not control
whether the member is inherited—inheritance extends to any member that isn’t an
instance constructor, static constructor, or finalizer.
Note: However, an inherited member might not be accessible in a derived type, for
example because of its declared accessibility ( §7.5.2 ). end not e
Namespaces and types that have no enclosing namespace are members of the global
namesp ace. This corresponds directly to the names declared in the global declaration
space.
Namespaces and types declared within a namespace are members of that namespace.
This corresponds directly to the names declared in the declaration space of the
namespace.
Namespaces have no access restrictions. It is not possible to declare private, protected,
or internal namespaces, and namespace names are always publicly accessible.
The members of a struct are the members declared in the struct and the members
inherited from the struct’s direct base class System.ValueType and the indirect base class
object.
The members of a simple type correspond directly to the members of the struct type
aliased by the simple type ( §8.3.5 ).
The members of an enumeration are the constants declared in the enumeration and the
members inherited from the enumeration’s direct base class System.Enum and the
indirect base classes System.ValueType and object.7.4.2 Namespace members
7.4.3 Struct members
7.4.4 Enumeration membersThe members of a class are the members declared in the class and the members
inherited from the base class (except for class object which has no base class). The
members inherited from the base class include the constants, fields, methods,
properties, events, indexers, operators, and types of the base class, but not the instance
constructors, finalizers, and static constructors of the base class. Base class members are
inherited without regard to their accessibility.
A class declaration may contain declarations of constants, fields, methods, properties,
events, indexers, operators, instance constructors, finalizers, static constructors, and
types.
The members of object (§8.2.3 ) and string (§8.2.5 ) correspond directly to the members
of the class types they alias.
The members of an interface are the members declared in the interface and in all base
interfaces of the interface.
Note: The members in class object are not, strictly speaking, members of any
interface ( §18.4 ). However, the members in class object are available via member
lookup in any interface type ( §12.5 ). end not e
The members of an array are the members inherited from class System.Array.
A delegate inherits members from class System.Delegate. Additionally, it contains a
method named Invoke with the same return type and formal parameter list specified in
its declaration ( §20.2 ). An invocation of this method shall behave identically to a
delegate invocation ( §20.6 ) on the same delegate instance.
An implementation may provide additional members, either through inheritance or
directly in the delegate itself.7.4.5 Class members
7.4.6 Interface members
7.4.7 Array members
7.4.8 Delegate members
7.5 Member accessDeclarations of members allow control over member access. The accessibility of a
member is established by the declared accessibility ( §7.5.2 ) of the member combined
with the accessibility of the immediately containing type, if any.
When access to a particular member is allowed, the member is said to be accessible .
Conversely, when access to a particular member is disallowed, the member is said to be
inaccessible . Access to a member is permitted when the textual location in which the
access takes place is included in the accessibility domain ( §7.5.3 ) of the member.
The declar ed ac cessibility  of a member can be one of the following:
Public, which is selected by including a public modifier in the member declaration.
The intuitive meaning of public is “access not limited”.
Protected, which is selected by including a protected modifier in the member
declaration. The intuitive meaning of protected is “access limited to the containing
class or types derived from the containing class”.
Internal, which is selected by including an internal modifier in the member
declaration. The intuitive meaning of internal is “access limited to this assembly”.
Protected internal, which is selected by including both a protected and an
internal modifier in the member declaration. The intuitive meaning of protected
internal is “accessible within this assembly as well as types derived from the
containing class”.
Private protected, which is selected by including both a private and a protected
modifier in the member declaration. The intuitive meaning of private protected is
“accessible within this assembly by the containing class and types derived from the
containing class.”
Private, which is selected by including a private modifier in the member
declaration. The intuitive meaning of private is “access limited to the containing
type”.
Depending on the context in which a member declaration takes place, only certain types
of declared accessibility are permitted. Furthermore, when a member declaration does
not include any access modifiers, the context in which the declaration takes place
determines the default declared accessibility.
Namespaces implicitly have public declared accessibility. No access modifiers are
allowed on namespace declarations.7.5.1 General
7.5.2 Declared accessibilityTypes declared directly in compilation units or namespaces (as opposed to within
other types) can have public or internal declared accessibility and default to
internal declared accessibility.
Class members can have any of the permitted kinds of declared accessibility and
default to private declared accessibility.
Note: A type declared as a member of a class can have any of the permitted
kinds of declared accessibility, whereas a type declared as a member of a
namespace can have only public or internal declared accessibility. end not e
Struct members can have public, internal, or private declared accessibility and
default to private declared accessibility because structs are implicitly sealed.
Struct members introduced in a struct (that is, not inherited by that struct) cannot
have protected, protected internal, or private protected declared accessibility.
Note: A type declared as a member of a struct can have public, internal, or
private declared accessibility, whereas a type declared as a member of a
namespace can have only public or internal declared accessibility. end not e
Interface members implicitly have public declared accessibility. No access
modifiers are allowed on interface member declarations.
Enumeration members implicitly have public declared accessibility. No access
modifiers are allowed on enumeration member declarations.
The accessibility domain  of a member consists of the (possibly disjoint) sections of
program text in which access to the member is permitted. For purposes of defining the
accessibility domain of a member, a member is said to be top-lev el if it is not declared
within a type, and a member is said to be nested if it is declared within another type.
Furthermore, the program t ext of a program is defined as all text contained in all
compilation units of the program, and the program text of a type is defined as all text
contained in the type_declar ation s of that type (including, possibly, types that are nested
within the type).
The accessibility domain of a predefined type (such as object, int, or double) is
unlimited.
The accessibility domain of a top-level unbound type  T (§8.4.4 ) that is declared in a
program  P is defined as follows:7.5.3 Accessibility domainsIf the declared accessibility of  T is public, the accessibility domain of  T is the
program text of  P and any program that references  P.
If the declared accessibility of  T is internal, the accessibility domain of  T is the
program text of  P.
Note: From these definitions, it follows that the accessibility domain of a top-level
unbound type is always at least the program text of the program in which that type
is declared. end not e
The accessibility domain for a constructed type T&lt;A₁, ..., Aₑ&gt; is the intersection of the
accessibility domain of the unbound generic type  T and the accessibility domains of the
type arguments A₁, ..., Aₑ.
The accessibility domain of a nested member  M declared in a type  T within a
program  P, is defined as follows (noting that M itself might possibly be a type):
If the declared accessibility of  M is public, the accessibility domain of  M is the
accessibility domain of  T.
If the declared accessibility of  M is protected internal, let D be the union of the
program text of  P and the program text of any type derived from  T, which is
declared outside  P. The accessibility domain of  M is the intersection of the
accessibility domain of  T with D.
If the declared accessibility of M is private protected, let D be the intersection of
the program text of P and the program text of T and any type derived from T.
The accessibility domain of M is the intersection of the accessibility domain of T
with D.
If the declared accessibility of  M is protected, let D be the union of the program
text of Tand the program text of any type derived from  T. The accessibility
domain of  M is the intersection of the accessibility domain of  T with D.
If the declared accessibility of  M is internal, the accessibility domain of  M is the
intersection of the accessibility domain of  T with the program text of  P.
If the declared accessibility of  M is private, the accessibility domain of  M is the
program text of  T.
Note: From these definitions it follows that the accessibility domain of a nested
member is always at least the program text of the type in which the member is
declared. Furthermore, it follows that the accessibility domain of a member is never
more inclusive than the accessibility domain of the type in which the member is
declared. end not eNote: In intuitive terms, when a type or member  M is accessed, the following steps
are evaluated to ensure that the access is permitted:
First, if M is declared within a type (as opposed to a compilation unit or a
namespace), a compile-time error occurs if that type is not accessible.
Then, if  M is public, the access is permitted.
Otherwise, if  M is protected internal, the access is permitted if it occurs
within the program in which  M is declared, or if it occurs within a class derived
from the class in which  M is declared and takes place through the derived class
type ( §7.5.4 ).
Otherwise, if M is protected, the access is permitted if it occurs within the class
in which M is declared, or if it occurs within a class derived from the class in
which M is declared and takes place through the derived class type ( §7.5.4 ).
Otherwise, if M is internal, the access is permitted if it occurs within the
program in which M is declared.
Otherwise, if M is private, the access is permitted if it occurs within the type in
which M is declared.
Otherwise, the type or member is inaccessible, and a compile-time error
occurs. end not e
Example : In the following code
C#
public class A
{
public static int X;
internal  static int Y;
private static int Z;
}
internal  class B
{
public static int X;
internal  static int Y;
private static int Z;
public class C
{
public static int X;
internal  static int Y;
private static int Z;
}
private class D
{the classes and members have the following accessibility domains:
The accessibility domain of A and A.X is unlimited.
The accessibility domain of A.Y, B, B.X, B.Y, B.C, B.C.X, and B.C.Y is the
program text of the containing program.
The accessibility domain of A.Z is the program text of  A.
The accessibility domain of B.Z and B.D is the program text of  B, including
the program text of B.C and B.D.
The accessibility domain of B.C.Z is the program text of B.C.
The accessibility domain of B.D.X and B.D.Y is the program text of  B,
including the program text of B.C and B.D.
The accessibility domain of B.D.Z is the program text of B.D. As the example
illustrates, the accessibility domain of a member is never larger than that of a
containing type. For example, even though all X members have public
declared accessibility, all but A.X have accessibility domains that are
constrained by a containing type.
end ex ample
As described in §7.4, all members of a base class, except for instance constructors,
finalizers, and static constructors, are inherited by derived types. This includes even
private members of a base class. However, the accessibility domain of a private member
includes only the program text of the type in which the member is declared.
Example : In the following code
C#        public static int X;
internal  static int Y;
private static int Z;
}
}
class A
{
int x;
static void F(B b)
{
b.x = 1;         // Ok
}
}
class B : Athe B class inherits the private member x from the A class. Because the member is
private, it is only accessible within the class_body  of A. Thus, the access to b.x
succeeds in the A.F method, but fails in the B.F method.
end ex ample
When a protected or private protected instance member is accessed outside the
program text of the class in which it is declared, and when a protected internal
instance member is accessed outside the program text of the program in which it is
declared, the access shall take place within a class declaration that derives from the class
in which it is declared. Furthermore, the access is required to take place through  an
instance of that derived class type or a class type constructed from it. This restriction
prevents one derived class from accessing protected members of other derived classes,
even when the members are inherited from the same base class.
Let B be a base class that declares a protected instance member  M, and let  D be a class
that derives from  B. Within the class_body  of D, access to  M can take one of the
following forms:
An unqualified type_name  or primary_expr ession  of the form  M.
A primary_expr ession  of the form E.M, provided the type of  E is T or a class
derived from  T, where  T is the class D, or a class type constructed from  D.
A primary_expr ession  of the form base.M.
A primary_expr ession  of the form base[argument_list ].
In addition to these forms of access, a derived class can access a protected instance
constructor of a base class in a constr uctor_initializer  (§15.11.2 ).
Example : In the following code
C#{
static void F(B b)
{
b.x = 1;         // Error, x not accessible
}
}
7.5.4 Protected access
public class A
{
protected  int x;within A, it is possible to access  x through instances of both  A and B, since in
either case the access takes place through  an instance of  A or a class derived
from A. However, within  B, it is not possible to access  x through an instance of  A,
since A does not derive from  B.
end ex ample
Example :
C#
Here, the three assignments to  x are permitted because they all take place through
instances of class types constructed from the generic type.    static void F(A a, B b )
{
a.x = 1; // Ok
b.x = 1; // Ok
}
}
public class B : A
{
static void F(A a, B b )
{
a.x = 1; // Error, must access through instance of B
b.x = 1; // Ok
}
}
class C<T>
{
protected  T x;
}
class D<T> : C<T>
{
static void F()
{
D<T> dt = new D<T>();
D<int> di = new D<int>();
D<string> ds = new D<string>();
dt.x = default(T);
di.x = 123;
ds.x = &quot;test&quot;;
}
}end ex ample
Note: The accessibility domain ( §7.5.3 ) of a protected member declared in a generic
class includes the program text of all class declarations derived from any type
constructed from that generic class. In the example:
C#
the reference to protected member  C<int>.x in D is valid even though the class  D
derives from C<string>. end not e
Several constructs in the C# language require a type to be at least as accessible as a
member or another type. A type  T is said to be at least as accessible as a member or
type M if the accessibility domain of  T is a superset of the accessibility domain of  M. In
other words, T is at least as accessible as  M if T is accessible in all contexts in which M is
accessible.
The following accessibility constraints exist:
The direct base class of a class type shall be at least as accessible as the class type
itself.
The explicit base interfaces of an interface type shall be at least as accessible as the
interface type itself.
The return type and parameter types of a delegate type shall be at least as
accessible as the delegate type itself.
The type of a constant shall be at least as accessible as the constant itself.
The type of a field shall be at least as accessible as the field itself.
The return type and parameter types of a method shall be at least as accessible as
the method itself.class C<T>
{
protected  static T x;
}
class D : C<string>
{
static void Main()
{
C<int>.x = 5;
}
}
7.5.5 Accessibility constraintsThe type of a property shall be at least as accessible as the property itself.
The type of an event shall be at least as accessible as the event itself.
The type and parameter types of an indexer shall be at least as accessible as the
indexer itself.
The return type and parameter types of an operator shall be at least as accessible
as the operator itself.
The parameter types of an instance constructor shall be at least as accessible as
the instance constructor itself.
An interface or class type constraint on a type parameter shall be at least as
accessible as the member which declares the constraint.
Example : In the following code
C#
the B class results in a compile-time error because A is not at least as accessible as
B.
end ex ample
Example : Likewise, in the following code
C#
the H method in  B results in a compile-time error because the return type  A is not
at least as accessible as the method.
end ex ampleclass A {...}
public class B: A {...}
class A {...}
public class B
{
A F() {...}
internal  A G() {...}
public A H() {...}
}
7.6 Signatures and overloadingMethods, instance constructors, indexers, and operators are characterized by their
signatur es:
The signature of a method consists of the name of the method, the number of
type parameters, and the type and parameter-passing mode of each of its formal
parameters, considered in the order left to right. For these purposes, any type
parameter of the method that occurs in the type of a formal parameter is identified
not by its name, but by its ordinal position in the type parameter list of the
method. The signature of a method specifically does not include the return type,
parameter names, type parameter names, type parameter constraints, the params
or this parameter modifiers, nor whether parameters are required or optional.
The signature of an instance constructor consists of the type and parameter-
passing mode of each of its formal parameters, considered in the order left to
right. The signature of an instance constructor specifically does not include the
params modifier that may be specified for the right-most parameter, nor whether
parameters are required or optional.
The signature of an indexer consists of the type of each of its formal parameters,
considered in the order left to right. The signature of an indexer specifically does
not include the element type, nor does it include the params modifier that may be
specified for the right-most parameter, nor whether parameters are required or
optional.
The signature of an operator consists of the name of the operator and the type of
each of its formal parameters, considered in the order left to right. The signature of
an operator specifically does not include the result type.
The signature of a conversion operator consists of the source type and the target
type. The implicit or explicit classification of a conversion operator is not part of
the signature.
Two signatures of the same member kind (method, instance constructor, indexer or
operator) are considered to be the same signatur es if they have the same name,
number of type parameters, number of parameters, and parameter-passing
modes, and an identity conversion exists between the types of their corresponding
parameters ( §10.2.2 ).
Signatures are the enabling mechanism for overloading  of members in classes, structs,
and interfaces:
Overloading of methods permits a class, struct, or interface to declare multiple
methods with the same name, provided their signatures are unique within that
class, struct, or interface.
Overloading of instance constructors permits a class or struct to declare multiple
instance constructors, provided their signatures are unique within that class orstruct.
Overloading of indexers permits a class, struct, or interface to declare multiple
indexers, provided their signatures are unique within that class, struct, or interface.
Overloading of operators permits a class or struct to declare multiple operators
with the same name, provided their signatures are unique within that class or
struct.
Although in, out, and ref parameter modifiers are considered part of a signature,
members declared in a single type cannot differ in signature solely by in, out, and ref.
A compile-time error occurs if two members are declared in the same type with
signatures that would be the same if all parameters in both methods with out or in
modifiers were changed to ref modifiers. For other purposes of signature matching
(e.g., hiding or overriding), in, out, and ref are considered part of the signature and
do not match each other.
Note: This restriction is to allow C# programs to be easily translated to run on the
Common Language Infrastructure (CLI), which does not provide a way to define
methods that differ solely in in, out, and ref. end not e
The types object and dynamic are not distinguished when comparing signatures.
Therefore members declared in a single type whose signatures differ only by replacing
object with dynamic are not allowed.
Example : The following example shows a set of overloaded method declarations
along with their signatures.
C#
interface  ITest
{
void F();                   // F()
void F(int x);              // F(int)
void F(ref int x);          // F(ref int)
void F(out int x);          // F(out int) error
void F(object o);           // F(object)
void F(dynamic d);          // error.
void F(int x, int y);       // F(int, int)
int F(string s);            // F(string)
int F(int x);               // F(int) error
void F(string[] a);         // F(string[])
void F(params string[] a);  // F(string[]) error
void F<S>(S s);             // F&lt;0&gt;(0)
void F<T>(T t);             // F&lt;0&gt;(0) error
void F&lt;S,T&gt;(S s);           // F&lt;0,1&gt;(0)Note that any in, out, and ref parameter modifiers ( §15.6.2 ) are part of a
signature. Thus, F(int), F(in int), F(out int) , and F(ref int) are all unique
signatures. However, F(in int), F(out int) , and F(ref int) cannot be declared
within the same interface because their signatures differ solely by in, out, and ref.
Also, note that the return type and the params modifier are not part of a signature,
so it is not possible to overload solely based on return type or on the inclusion or
exclusion of the params modifier. As such, the declarations of the methods  F(int)
and F(params string[]) identified above, result in a compile-time error. end
example
The scope of a name is the region of program text within which it is possible to refer to
the entity declared by the name without qualification of the name. Scopes can be
nested, and an inner scope may redeclare the meaning of a name from an outer scope.
(This does not, however, remove the restriction imposed by §7.3 that within a nested
block it is not possible to declare a local variable or local constant with the same name
as a local variable or local constant in an enclosing block.) The name from the outer
scope is then said to be hidden  in the region of program text covered by the inner
scope, and access to the outer name is only possible by qualifying the name.
The scope of a namespace member declared by a namesp ace_member_declar ation
(§14.6 ) with no enclosing namesp ace_declar ation  is the entire program text.
The scope of a namespace member declared by a namesp ace_member_declar ation
within a namesp ace_declar ation  whose fully qualified name is  N, is the
namesp ace_body  of every namesp ace_declar ation  whose fully qualified name is  N
or starts with  N, followed by a period.
The scope of a name defined by an extern_alias_dir ective (§14.4 ) extends over the
using_dir ectives, global_attr ibutes and namesp ace_member_declar ation s of its
immediately containing compilation_unit  or namesp ace_body . An
extern_alias_dir ective does not contribute any new members to the underlying
declaration space. In other words, an extern_alias_dir ective is not transitive, but,
rather, affects only the compilation_unit  or namesp ace_body  in which it occurs.    void F&lt;T,S&gt;(S s);           // F&lt;0,1&gt;(1) ok
}
7.7 Scopes
7.7.1 GeneralThe scope of a name defined or imported by a using_dir ective (§14.5 ) extends over
the global_attr ibutes and namesp ace_member_declar ation s of the compilation_unit
or namesp ace_body  in which the using_dir ective occurs. A using_dir ective may make
zero or more namespace or type names available within a particular
compilation_unit  or namesp ace_body , but does not contribute any new members to
the underlying declaration space. In other words, a using_dir ective is not transitive
but rather affects only the compilation_unit  or namesp ace_body  in which it occurs.
The scope of a type parameter declared by a type_p aramet er_list  on a
class_declar ation  (§15.2 ) is the class_b ase, type_p aramet er_constr aints_claus es, and
class_body  of that class_declar ation .
Note: Unlike members of a class, this scope does not extend to derived classes.
end not e
The scope of a type parameter declared by a type_p aramet er_list  on a
struct_declar ation  (§16.2 ) is the struct_int erfaces,
type_p aramet er_constr aints_claus es, and struct_body  of that struct_declar ation .
The scope of a type parameter declared by a type_p aramet er_list  on an
interface_declar ation  (§18.2 ) is the interface_base,
type_p aramet er_constr aints_claus es, and interface_body  of that
interface_declar ation .
The scope of a type parameter declared by a type_p aramet er_list  on a
delegat e_declar ation  (§20.2 ) is the return_type , formal_p aramet er_list , and
type_p aramet er_constr aints_claus es of that delegat e_declar ation .
The scope of a type parameter declared by a type_p aramet er_list  on a
method_declar ation  (§15.6.1 ) is the method_declar ation .
The scope of a member declared by a class_member_declar ation  (§15.3.1 ) is the
class_body  in which the declaration occurs. In addition, the scope of a class
member extends to the class_body  of those derived classes that are included in the
accessibility domain ( §7.5.3 ) of the member.
The scope of a member declared by a struct_member_declar ation  (§16.3 ) is the
struct_body  in which the declaration occurs.
The scope of a member declared by an enum_member_declar ation  (§19.4 ) is the
enum_body  in which the declaration occurs.The scope of a parameter declared in a method_declar ation  (§15.6 ) is the
method_body  or ref_method_body  of that method_declar ation .
The scope of a parameter declared in an index er_declar ation  (§15.9 ) is the
index er_body  of that index er_declar ation .
The scope of a parameter declared in an operator_declar ation  (§15.10 ) is the
operator_body  of that operator_declar ation .
The scope of a parameter declared in a constr uctor_declar ation  (§15.11 ) is the
constr uctor_initializer  and block  of that constr uctor_declar ation .
The scope of a parameter declared in a lambda_expr ession  (§12.19 ) is the
lambda_expr ession_body  of that lambda_expr ession .
The scope of a parameter declared in an anon ymous_method_expr ession  (§12.19 ) is
the block  of that anon ymous_method_expr ession .
The scope of a label declared in a labeled_st atement  (§13.5 ) is the block  in which
the declaration occurs.
The scope of a local variable declared in a local_v ariable_declar ation  (§13.6.2 ) is the
block  in which the declaration occurs.
The scope of a local variable declared in a switch_block  of a switch statement
(§13.8.3 ) is the switch_block .
The scope of a local variable declared in a for_initializer  of a for statement
(§13.9.4 ) is the for_initializer , for_condition , for_it erator, and embedded_st atement  of
the for statement.
The scope of a local constant declared in a local_c onstant_declar ation  (§13.6.3 ) is
the block  in which the declaration occurs. It is a compile-time error to refer to a
local constant in a textual position that precedes its constant_declar ator.
The scope of a variable declared as part of a foreach_st atement , using_st atement ,
lock_st atement  or query_expr ession  is determined by the expansion of the given
construct.
Within the scope of a namespace, class, struct, or enumeration member it is possible to
refer to the member in a textual position that precedes the declaration of the member.
Example :
C#Here, it is valid for  F to refer to  i before it is declared.
end ex ample
Within the scope of a local variable, it is a compile-time error to refer to the local
variable in a textual position that precedes its declarator.
Example :
C#
In the F method above, the first assignment to  i specifically does not refer to the
field declared in the outer scope. Rather, it refers to the local variable and it results
in a compile-time error because it textually precedes the declaration of the variable.
In the G method, the use of  j in the initializer for the declaration of  j is validclass A
{
void F()
{
i = 1;
}
int i = 0;
}
class A
{
int i = 0;
void F()
{
i = 1;                // Error, use precedes declaration
int i;
i = 2;
}
void G()
{
int j = (j = 1);     // Valid
}
void H()
{
int a = 1, b = ++a; // Valid
}
}because the use does not precede the declarator. In the H method, a subsequent
declarator correctly refers to a local variable declared in an earlier declarator within
the same local_v ariable_declar ation .
end ex ample
Note: The scoping rules for local variables and local constants are designed to
guarantee that the meaning of a name used in an expression context is always the
same within a block. If the scope of a local variable were to extend only from its
declaration to the end of the block, then in the example above, the first assignment
would assign to the instance variable and the second assignment would assign to
the local variable, possibly leading to compile-time errors if the statements of the
block were later to be rearranged.)
The meaning of a name within a block may differ based on the context in which the
name is used. In the example
C#
the name  A is used in an expression context to refer to the local variable  A and in a
type context to refer to the class  A.
end not e
The scope of an entity typically encompasses more program text than the declaration
space of the entity. In particular, the scope of an entity may include declarations thatclass A {}
class Test
{
static void Main()
{
string A = &quot;hello, world&quot; ;
string s = A;                      // expression context
Type t = typeof(A);                // type context
Console.WriteLine(s);              // writes &quot;hello, world&quot;
Console.WriteLine(t);              // writes &quot;A&quot;
}
}
7.7.2 Name hiding
7.7.2.1 Generalintroduce new declaration spaces containing entities of the same name. Such
declarations cause the original entity to become hidden . Conversely, an entity is said to
be visible  when it is not hidden.
Name hiding occurs when scopes overlap through nesting and when scopes overlap
through inheritance. The characteristics of the two types of hiding are described in the
following subclauses.
Name hiding through nesting can occur as a result of nesting namespaces or types
within namespaces, as a result of nesting types within classes or structs, and as a result
of parameter, local variable, and local constant declarations.
Example : In the following code
C#
within the F method, the instance variable  i is hidden by the local variable  i, but
within the G method, i still refers to the instance variable.
end ex ample
When a name in an inner scope hides a name in an outer scope, it hides all overloaded
occurrences of that name.
Example : In the following code
C#7.7.2.2 Hiding through nesting
class A
{
int i = 0;
void F()
{
int i = 1;
}
void G()
{
i = 1;
}
}
class Outer
{the call F(1) invokes the F declared in Inner because all outer occurrences of  F
are hidden by the inner declaration. For the same reason, the call F(&quot;Hello&quot;) results
in a compile-time error.
end ex ample
Name hiding through inheritance occurs when classes or structs redeclare names that
were inherited from base classes. This type of name hiding takes one of the following
forms:
A constant, field, property, event, or type introduced in a class or struct hides all
base class members with the same name.
A method introduced in a class or struct hides all non-method base class members
with the same name, and all base class methods with the same signature ( §7.6).
An indexer introduced in a class or struct hides all base class indexers with the
same signature ( §7.6) .
The rules governing operator declarations ( §15.10 ) make it impossible for a derived class
to declare an operator with the same signature as an operator in a base class. Thus,
operators never hide one another.
Contrary to hiding a name from an outer scope, hiding a visible name from an inherited
scope causes a warning to be reported.
Example : In the following code
C#    static void F(int i) {}
static void F(string s) {}
class Inner
{
static void F(long l) {}
void G()
{
F(1); // Invokes Outer.Inner.F
F(&quot;Hello&quot;); // Error
}
}
}
7.7.2.3 Hiding through inheritancethe declaration of F in Derived causes a warning to be reported. Hiding an
inherited name is specifically not an error, since that would preclude separate
evolution of base classes. For example, the above situation might have come about
because a later version of Base introduced an F method that wasn’t present in an
earlier version of the class.
end ex ample
The warning caused by hiding an inherited name can be eliminated through use of the
new modifier:
Example :
C#
The new modifier indicates that the F in Derived is “new”, and that it is indeed
intended to hide the inherited member.
end ex ample
A declaration of a new member hides an inherited member only within the scope of the
new member.
Example :class Base
{
public void F() {}
}
class Derived : Base
{
public void F() {} // Warning, hiding an inherited name
}
class Base
{
public void F() {}
}
class Derived : Base
{
public new void F() {}
}C#
In the example above, the declaration of F in Derived hides the F that was
inherited from Base, but since the new  F in Derived has private access, its scope
does not extend to MoreDerived. Thus, the call F() in MoreDerived.G is valid and will
invoke Base.F.
end ex ample
Several contexts in a C# program require a namesp ace_name  or a type_name  to be
specified.
ANTLRclass Base
{
public static void F() {}
}
class Derived : Base
{
private new static void F() {} // Hides Base.F in Derived only
}
class MoreDerived  : Derived
{
static void G()
{
F();                       // Invokes Base.F
}
}
7.8 Namespace and type names
7.8.1 General
namespace_name
: namespace_or_type_name
;
type_name
: namespace_or_type_name
;</p>
<p>namespace_or_type_name
: identifier type_argument_list?
| namespace_or_type_name '.' identifier type_argument_list?A namesp ace_name  is a namesp ace_or_type_name  that refers to a namespace.
Following resolution as described below, the namesp ace_or_type_name  of a
namesp ace_name  shall refer to a namespace, or otherwise a compile-time error occurs.
No type arguments ( §8.4.2 ) can be present in a namesp ace_name  (only types can have
type arguments).
A type_name  is a namesp ace_or_type_name  that refers to a type. Following resolution as
described below, the namesp ace_or_type_name  of a type_name  shall refer to a type, or
otherwise a compile-time error occurs.
If the namesp ace_or_type_name  is a quali fied_alias_member  its meaning is as described
in §14.8.1 . Otherwise, a namesp ace_or_type_name  has one of four forms:
I
I&lt;A₁, ..., Aₓ&gt;
N.I
N.I&lt;A₁, ..., Aₓ&gt;
where I is a single identifier, N is a namesp ace_or_type_name  and &lt;A₁, ..., Aₓ&gt; is an
optional type_ar gument_list . When no type_ar gument_list  is specified, consider x to be
zero.
The meaning of a namesp ace_or_type_name  is determined as follows:
If the namesp ace_or_type_name  is a quali fied_alias_member , the meaning is as
specified in §14.8.1 .
Otherwise, if the namesp ace_or_type_name  is of the form I or of the form I&lt;A₁,
..., Aₓ&gt;:
If x is zero and the namesp ace_or_type_name  appears within a generic method
declaration ( §15.6 ) but outside the attributes of its method-header , and if that
declaration includes a type parameter ( §15.2.3 ) with name  I, then the
namesp ace_or_type_name  refers to that type parameter.
Otherwise, if the namesp ace_or_type_name  appears within a type declaration,
then for each instance type  T (§15.3.2 ), starting with the instance type of that
type declaration and continuing with the instance type of each enclosing class
or struct declaration (if any):
If x is zero and the declaration of  T includes a type parameter with name  I,
then the namesp ace_or_type_name  refers to that type parameter.    | qualified_alias_member
;Otherwise, if the namesp ace_or_type_name  appears within the body of the
type declaration, and  T or any of its base types contain a nested accessible
type having name  I and x type parameters, then the
namesp ace_or_type_name  refers to that type constructed with the given type
arguments. If there is more than one such type, the type declared within the
more derived type is selected.
Note: Non-type members (constants, fields, methods, properties, indexers,
operators, instance constructors, finalizers, and static constructors) and type
members with a different number of type parameters are ignored when
determining the meaning of the namesp ace_or_type_name . end not e
Otherwise, for each namespace  N, starting with the namespace in which the
namesp ace_or_type_name  occurs, continuing with each enclosing namespace (if
any), and ending with the global namespace, the following steps are evaluated
until an entity is located:
If x is zero and I is the name of a namespace in  N, then:
If the location where the namesp ace_or_type_name  occurs is enclosed by a
namespace declaration for N and the namespace declaration contains an
extern_alias_dir ective or using_alias_dir ective that associates the name  I
with a namespace or type, then the namesp ace_or_type_name  is
ambiguous and a compile-time error occurs.
Otherwise, the namesp ace_or_type_name  refers to the namespace
named I in N.
Otherwise, if  N contains an accessible type having name  I and x type
parameters, then:
If x is zero and the location where the namesp ace_or_type_name  occurs is
enclosed by a namespace declaration for  N and the namespace
declaration contains an extern_alias_dir ective or using_alias_dir ective that
associates the name  I with a namespace or type, then the
namesp ace_or_type_name  is ambiguous and a compile-time error occurs.
Otherwise, the namesp ace_or_type_name  refers to the type constructed
with the given type arguments.
Otherwise, if the location where the namesp ace_or_type_name  occurs is
enclosed by a namespace declaration for N:
If x is zero and the namespace declaration contains an
extern_alias_dir ective or using_alias_dir ective that associates the name  I
with an imported namespace or type, then the namesp ace_or_type_name
refers to that namespace or type.
Otherwise, if the namespaces imported by the using_namesp ace_directives
of the namespace declaration contain exactly one type having name  Iand x type parameters, then the namesp ace_or_type_name  refers to that
type constructed with the given type arguments.
Otherwise, if the namespaces imported by the using_namesp ace_directives
of the namespace declaration contain more than one type having name  I
and x type parameters, then the namesp ace_or_type_name  is ambiguous
and an error occurs.
Otherwise, the namesp ace_or_type_name  is undefined and a compile-time error
occurs.
Otherwise, the namesp ace_or_type_name  is of the form N.I or of the form N.I&lt;A₁,
..., Aₓ&gt;. N is first resolved as a namesp ace_or_type_name . If the resolution of N is
not successful, a compile-time error occurs. Otherwise, N.I or N.I&lt;A₁, ..., Aₓ&gt; is
resolved as follows:
If x is zero and N refers to a namespace and N contains a nested namespace
with name  I, then the namesp ace_or_type_name  refers to that nested
namespace.
Otherwise, if N refers to a namespace and N contains an accessible type having
name I and x type parameters, then the namesp ace_or_type_name  refers to
that type constructed with the given type arguments.
Otherwise, if N refers to a (possibly constructed) class or struct type and N or
any of its base classes contain a nested accessible type having name  I and
x type parameters, then the namesp ace_or_type_name  refers to that type
constructed with the given type arguments. If there is more than one such type,
the type declared within the more derived type is selected.
Note: If the meaning of  N.I is being determined as part of resolving the
base class specification of  N then the direct base class of  N is considered to
be object (§15.2.4.2 ). end not e
Otherwise, N.I is an invalid namesp ace_or_type_name , and a compile-time error
occurs.
A namesp ace_or_type_name  is permitted to reference a static class ( §15.2.2.4 ) only if
The namesp ace_or_type_name  is the T in a namesp ace_or_type_name  of the form
T.I, or
The namesp ace_or_type_name  is the T in a typeo f_expr ession  (§12.8.17 ) of the form
typeof(T)
7.8.2 Unqualified namesEvery namespace declaration and type declaration has an unquali fied name  determined
as follows:
For a namespace declaration, the unqualified name is the quali fied_identi fier
specified in the declaration.
For a type declaration with no type_p aramet er_list , the unqualified name is the
identi fier specified in the declaration.
For a type declaration with K type parameters, the unqualified name is the
identi fier specified in the declaration, followed by the gener ic_dimension_speci fier
(§12.8.17 ) for K type parameters.
Every namespace and type declaration has a fully quali fied name,  which uniquely
identifies the namespace or type declaration amongst all others within the program. The
fully qualified name of a namespace or type declaration with unqualified name  N is
determined as follows:
If N is a member of the global namespace, its fully qualified name is  N.
Otherwise, its fully qualified name is S.N, where S is the fully qualified name of the
namespace or type declaration in which  N is declared.
In other words, the fully qualified name of  N is the complete hierarchical path of
identifiers and gener ic_dimension_speci fiers that lead to  N, starting from the global
namespace. Because every member of a namespace or type shall have a unique name, it
follows that the fully qualified name of a namespace or type declaration is always
unique. It is a compile-time error for the same fully qualified name to refer to two
distinct entities. In particular:
It is an error for both a namespace declaration and a type declaration to have the
same fully qualified name.
It is an error for two different kinds of type declarations to have the same fully
qualified name (for example, if both a struct and class declaration have the same
fully qualified name).
It is an error for a type declaration without the partial modifier to have the same
fully qualified name as another type declaration ( §15.2.7 ).
Example : The example below shows several namespace and type declarations along
with their associated fully qualified names.
C#7.8.3 Fully qualified namesend ex ample
C# employs automatic memory management, which frees developers from manually
allocating and freeing the memory occupied by objects. Automatic memory
management policies are implemented by a garbage collector. The memory
management life cycle of an object is as follows:</p>
<ol>
<li>When the object is created, memory is allocated for it, the constructor is run, and
the object is considered live.</li>
<li>If neither the object nor any of its instance fields can be accessed by any possible
continuation of execution, other than the running of finalizers, the object is
considered no longer in us e and it becomes eligible for finalization.
Note: The C# compiler and the garbage collector might choose to analyze
code to determine which references to an object might be used in the future.
For instance, if a local variable that is in scope is the only existing reference to
an object, but that local variable is never referred to in any possible
continuation of execution from the current execution point in the procedure,class A {}                 // A
namespace  X                // X
{
class B                // X.B
{
class C {}         // X.B.C
}
namespace  Y            // X.Y
{
class D {}         // X.Y.D
}
}
namespace  X.Y              // X.Y
{
class E {}             // X.Y.E
class G<T>             // X.Y.G&lt;&gt;
{<br />
class H {}         // X.Y.G&lt;&gt;.H
}
class G&lt;S,T&gt;           // X.Y.G&lt;,&gt;
{<br />
class H<U> {}      // X.Y.G&lt;,&gt;.H&lt;&gt;
}
}
7.9 Automatic memory managementthe garbage collector might (but is not required to) treat the object as no
longer in use. end not e</li>
<li>Once the object is eligible for finalization, at some unspecified later time the
finalizer ( §15.13 ) (if any) for the object is run. Under normal circumstances the
finalizer for the object is run once only, though implementation-specific APIs may
allow this behavior to be overridden.</li>
<li>Once the finalizer for an object is run, if neither the object nor any of its instance
fields can be accessed by any possible continuation of execution, including the
running of finalizers, the object is considered inaccessible and the object becomes
eligible for collection.
Note: An object which could previously not be accessed may become
accessible again due to its finalizer. An example of this is provided below. end
note</li>
<li>Finally, at some time after the object becomes eligible for collection, the garbage
collector frees the memory associated with that object.
The garbage collector maintains information about object usage, and uses this
information to make memory management decisions, such as where in memory to
locate a newly created object, when to relocate an object, and when an object is no
longer in use or inaccessible.
Like other languages that assume the existence of a garbage collector, C# is designed so
that the garbage collector might implement a wide range of memory management
policies. C# specifies neither a time constraint within that span, nor an order in which
finalizers are run. Whether or not finalizers are run as part of application termination is
implementation-specific ( §7.2).
The behavior of the garbage collector can be controlled, to some degree, via static
methods on the class System.GC. This class can be used to request a collection to occur,
finalizers to be run (or not run), and so forth.
Example : Since the garbage collector is allowed wide latitude in deciding when to
collect objects and run finalizers, a conforming implementation might produce
output that differs from that shown by the following code. The program
C#
class A
{
~A()
{
Console.WriteLine( &quot;Finalize instance of A&quot; );creates an instance of class  A and an instance of class  B. These objects become
eligible for garbage collection when the variable  b is assigned the value null, since
after this time it is impossible for any user-written code to access them. The output
could be either
Console
or
Console
because the language imposes no constraints on the order in which objects are
garbage collected.    }
}
class B
{
object Ref;
public B(object o)
{
Ref = o;
}
~B()
{
Console.WriteLine( &quot;Finalize instance of B&quot; );
}
}
class Test
{
static void Main()
{
B b = new B(new A());
b = null;
GC.Collect();
GC.WaitForPendingFinalizers();
}
}
Finalize instance of A
Finalize instance of B
Finalize instance of B
Finalize instance of AIn subtle cases, the distinction between “eligible for finalization” and “eligible for
collection” can be important. For example,
C#
class A
{
~A()
{
Console.WriteLine( &quot;Finalize instance of A&quot; );
}
public void F()
{
Console.WriteLine( &quot;A.F&quot;);
Test.RefA = this;
}
}
class B
{
public A Ref;
~B()
{
Console.WriteLine( &quot;Finalize instance of B&quot; );
Ref.F();
}
}
class Test
{
public static A RefA;
public static B RefB;
static void Main()
{
RefB = new B();
RefA = new A();
RefB.Ref = RefA;
RefB = null;
RefA = null;
// A and B now eligible for finalization
GC.Collect();
GC.WaitForPendingFinalizers();
// B now eligible for collection, but A is not
if (RefA != null)
{
Console.WriteLine( &quot;RefA is not null&quot; );
}
}
}In the above program, if the garbage collector chooses to run the finalizer of A
before the finalizer of B, then the output of this program might be:
Console
Note that although the instance of  A was not in use and A’s finalizer was run, it is
still possible for methods of  A (in this case,  F) to be called from another finalizer.
Also, note that running of a finalizer might cause an object to become usable from
the mainline program again. In this case, the running of B’s finalizer caused an
instance of  A that was previously not in use, to become accessible from the live
reference Test.RefA. After the call to WaitForPendingFinalizers, the instance of  B is
eligible for collection, but the instance of A is not, because of the reference
Test.RefA.
end ex ample
Execution of a C# program proceeds such that the side effects of each executing thread
are preserved at critical execution points. A side ef fect is defined as a read or write of a
volatile field, a write to a non-volatile variable, a write to an external resource, and the
throwing of an exception. The critical execution points at which the order of these side
effects shall be preserved are references to volatile fields ( §15.5.4 ), lock statements
(§13.13 ), and thread creation and termination. The execution environment is free to
change the order of execution of a C# program, subject to the following constraints:
Data dependence is preserved within a thread of execution. That is, the value of
each variable is computed as if all statements in the thread were executed in
original program order.
Initialization ordering rules are preserved ( §15.5.5 , §15.5.6 ).
The ordering of side effects is preserved with respect to volatile reads and writes
(§15.5.4 ). Additionally, the execution environment need not evaluate part of an
expression if it can deduce that that expression’s value is not used and that no
needed side effects are produced (including any caused by calling a method or
accessing a volatile field). When program execution is interrupted by an
asynchronous event (such as an exception thrown by another thread), it is notFinalize instance of A
Finalize instance of B
A.F
RefA is not null
7.10 Execution orderguaranteed that the observable side effects are visible in the original program
order.
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide .C# Standar d documentation
feedb ack
C# Standard documentation is an
open source project. Select a link to
provide feedback:
 Open a documentation issue
 Provide product feedback8 Types
Article •04/07/2023
The types of the C# language are divided into two main categories: reference types  and
value types . Both value types and reference types may be gener ic types , which take one
or more type p aramet ers. Type parameters can designate both value types and
reference types.
ANTLR
point er_type  (§23.3 ) is available only in unsafe code ( §23).
Value types differ from reference types in that variables of the value types directly
contain their data, whereas variables of the reference types store references to their
data, the latter being known as objects . With reference types, it is possible for two
variables to reference the same object, and thus possible for operations on one variable
to affect the object referenced by the other variable. With value types, the variables each
have their own copy of the data, and it is not possible for operations on one to affect
the other.
Note: When a variable is a ref or out parameter, it does not have its own storage but
references the storage of another variable. In this case, the ref or out variable is
effectively an alias for another variable and not a distinct variable. end not e
C#’s type system is unified such that a value o f any type can be tr eated as an object .
Every type in C# directly or indirectly derives from the object class type, and object is
the ultimate base class of all types. V alues of reference types are treated as objects
simply by viewing the values as type object. Values of value types are treated as objects
by performing boxing and unboxing operations ( §8.3.13 ).
For convenience, throughout this specification, some library type names are written
without using their full name qualification. R efer to §C.5 for more information.8.1 General
type
: reference_type
| value_type
| type_parameter
| pointer_type     // unsafe code support
;A reference type is a class type, an interface type, an array type, a delegate type, or the
dynamic type.
ANTLR
point er_type  is available only in unsafe code ( §23.3 ).8.2 Reference types
8.2.1 General
reference_type
: class_type
| interface_type
| array_type
| delegate_type
| 'dynamic'
;
class_type
: type_name
| 'object'
| 'string'
;
interface_type
: type_name
;
array_type
: non_array_type rank_specifier+
;
non_array_type
: value_type
| class_type
| interface_type
| delegate_type
| 'dynamic'
| type_parameter
| pointer_type      // unsafe code support
;
rank_specifier
: '[' ','* ']'
;
delegate_type
: type_name
;A reference type value is a reference to an instance of the type, the latter known as an
object. The special value null is compatible with all reference types and indicates the
absence of an instance.
A class type defines a data structure that contains data member s (constants and fields),
function member s (methods, properties, events, indexers, operators, instance
constructors, finalizers, and static constructors), and nested types. Class types support
inheritance, a mechanism whereby derived classes can extend and specialize base
classes. Instances of class types are created using object_cr eation_expr ession s
(§12.8.16.2 ).
Class types are described in §15.
Certain predefined class types have special meaning in the C# language, as described in
the table below.
Class type Description
System.Object The ultimate base class of all other types. See §8.2.3 .
System.String The string type of the C# language. See §8.2.5 .
System.ValueType The base class of all value types. See §8.3.2 .
System.Enum The base class of all enum types. See §19.5 .
System.Array The base class of all array types. See §17.2.2 .
System.Delegate The base class of all delegate types. See §20.1 .
System.Exception The base class of all exception types. See §21.3 .
The object class type is the ultimate base class of all other types. Every type in C#
directly or indirectly derives from the object class type.
The keyword object is simply an alias for the predefined class System.Object.8.2.2 Class types
8.2.3 The object type
8.2.4 The dynamic typeThe dynamic type, like object, can reference any object. When operations are applied to
expressions of type dynamic, their resolution is deferred until the program is run. Thus, if
the operation cannot legitimately be applied to the referenced object, no error is given
during compilation. Instead, an exception will be thrown when resolution of the
operation fails at run-time.
The dynamic type is further described in §8.7, and dynamic binding in §12.3.1 .
The string type is a sealed class type that inherits directly from object. Instances of the
string class represent Unicode character strings.
Values of the string type can be written as string literals ( §6.4.5.6 ).
The keyword string is simply an alias for the predefined class System.String.
An interface defines a contract. A class or struct that implements an interface shall
adhere to its contract. An interface may inherit from multiple base interfaces, and a class
or struct may implement multiple interfaces.
Interface types are described in §18.
An array is a data structure that contains zero or more variables, which are accessed
through computed indices. The variables contained in an array, also called the elements
of the array, are all of the same type, and this type is called the element type of the
array.
Array types are described in §17.
A delegate is a data structure that refers to one or more methods. For instance methods,
it also refers to their corresponding object instances.
Note: The closest equivalent of a delegate in C or C++ is a function pointer, but
whereas a function pointer can only reference static functions, a delegate can
reference both static and instance methods. In the latter case, the delegate stores8.2.5 The string type
8.2.6 Interface types
8.2.7 Array types
8.2.8 Delegate typesnot only a reference to the method’s entry point, but also a reference to the object
instance on which to invoke the method. end not e
Delegate types are described in §20.
A value type is either a struct type or an enumeration type. C# provides a set of
predefined struct types called the simple types . The simple types are identified through
keywords.
ANTLR8.3 Value types
8.3.1 General
value_type
: non_nullable_value_type
| nullable_value_type
;
non_nullable_value_type
: struct_type
| enum_type
;
struct_type
: type_name
| simple_type
| tuple_type
;
simple_type
: numeric_type
| 'bool'
;
numeric_type
: integral_type
| floating_point_type
| 'decimal'
;
integral_type
: 'sbyte'
| 'byte'
| 'short'
| 'ushort'
| 'int'
| 'uint'Unlike a variable of a reference type, a variable of a value type can contain the value
null only if the value type is a nullable value type ( §8.3.12 ). For every non-nullable value
type there is a corresponding nullable value type denoting the same set of values plus
the value null.
Assignment to a variable of a value type creates a copy of the value being assigned. This
differs from assignment to a variable of a reference type, which copies the reference but
not the object identified by the reference.
All value types implicitly inherit from the class System.ValueType, which, in turn, inherits
from class object. It is not possible for any type to derive from a value type, and value
types are thus implicitly sealed ( §15.2.2.3 ).
Note that System.ValueType is not itself a value_type . Rather, it is a class_type  from which
all value_type s are automatically derived.    | 'long'
| 'ulong'
| 'char'
;
floating_point_type
: 'float'
| 'double'
;
tuple_type
: '(' tuple_type_element ( ',' tuple_type_element)+ ')'
;</li>
</ol>
<p>tuple_type_element
: type identifier?
;</p>
<p>enum_type
: type_name
;
nullable_value_type
: non_nullable_value_type '?'
;
8.3.2 The System.ValueType type
8.3.3 Default constructorsAll value types implicitly declare a public parameterless instance constructor called the
default c onstr uctor. The default constructor returns a zero-initialized instance known as
the default v alue for the value type:
For all simple_type s, the default value is the value produced by a bit pattern of all
zeros:
For sbyte, byte, short, ushort, int, uint, long, and ulong, the default value
is 0.
For char, the default value is '\x0000'.
For float, the default value is 0.0f.
For double, the default value is 0.0d.
For decimal, the default value is 0m (that is, value zero with scale 0).
For bool, the default value is false.
For an enum_type  E, the default value is 0, converted to the type E.
For a struct_type , the default value is the value produced by setting all value type
fields to their default value and all reference type fields to null.
For a nullable_v alue_type  the default value is an instance for which the HasValue
property is false. The default value is also known as the null v alue of the nullable
value type. Attempting to read the Value property of such a value causes an
exception of type System.InvalidOperationException to be thrown ( §8.3.12 ).
Like any other instance constructor, the default constructor of a value type is invoked
using the new operator.
Note: For efficiency reasons, this requirement is not intended to actually have the
implementation generate a constructor call. For value types, the default value
expression ( §12.8.20 ) produces the same result as using the default constructor. end
note
Example : In the code below, variables i, j and k are all initialized to zero.
C#
class A
{
void F()
{
int i = 0;
int j = new int();
int k = default(int);
}
}end ex ample
Because every value type implicitly has a public parameterless instance constructor, it is
not possible for a struct type to contain an explicit declaration of a parameterless
constructor. A struct type is however permitted to declare parameterized instance
constructors ( §16.4.9 ).
A struct type is a value type that can declare constants, fields, methods, properties,
events, indexers, operators, instance constructors, static constructors, and nested types.
The declaration of struct types is described in §16.
C# provides a set of predefined struct types called the simple types. The simple types
are identified through keywords, but these keywords are simply aliases for predefined
struct types in the System namespace, as described in the table below.
Keyword Aliased type
sbyte System.SByte
byte System.Byte
short System.Int16
ushort System.UInt16
int System.Int32
uint System.UInt32
long System.Int64
ulong System.UInt64
char System.Char
float System.Single
double System.Double
bool System.Boolean
decimal System.Decimal8.3.4 Struct types
8.3.5 Simple typesBecause a simple type aliases a struct type, every simple type has members.
Example : int has the members declared in System.Int32 and the members
inherited from System.Object, and the following statements are permitted:
C#
end ex ample
Note: The simple types differ from other struct types in that they permit certain
additional operations:
Most simple types permit values to be created by writing literals (§6.4.5 ),
although C# makes no provision for literals of struct types in general. Example :
123 is a literal of type int and 'a' is a literal of type char. end ex ample
When the operands of an expression are all simple type constants, it is
possible for the compiler to evaluate the expression at compile-time. Such an
expression is known as a constant_expr ession  (§12.23 ). Expressions involving
operators defined by other struct types are not considered to be constant
expressions
Through const declarations, it is possible to declare constants of the simple
types ( §15.4 ). It is not possible to have constants of other struct types, but a
similar effect is provided by static readonly fields.
Conversions involving simple types can participate in evaluation of conversion
operators defined by other struct types, but a user-defined conversion
operator can never participate in evaluation of another user-defined
conversion operator ( §10.5.3 ).
end not e.
C# supports nine integral types: sbyte, byte, short, ushort, int, uint, long, ulong,
and char. The integral types have the following sizes and ranges of values:
The sbyte type represents signed 8-bit integers with values from -128 to 127,
inclusive.int i = int.MaxValue;      // System.Int32.MaxValue constant
string s = i.ToString();   // System.Int32.ToString() instance method
string t = 123.ToString(); // System.Int32.ToString() instance method
8.3.6 Integral typesThe byte type represents unsigned 8-bit integers with values from 0 to 255,
inclusive.
The short type represents signed 16-bit integers with values from -32768 to
32767, inclusive.
The ushort type represents unsigned 16-bit integers with values from 0 to 65535,
inclusive.
The int type represents signed 32-bit integers with values from -2147483648 to
2147483647, inclusive.
The uint type represents unsigned 32-bit integers with values from 0 to
4294967295, inclusive.
The long type represents signed 64-bit integers with values from
-9223372036854775808 to 9223372036854775807, inclusive.
The ulong type represents unsigned 64-bit integers with values from 0 to
18446744073709551615, inclusive.
The char type represents unsigned 16-bit integers with values from 0 to 65535,
inclusive. The set of possible values for the char type corresponds to the Unicode
character set.
Note: Although char has the same representation as ushort, not all operations
permitted on one type are permitted on the other. end not e
All signed integral types are represented using two’s complement format.
The integral_type  unary and binary operators always operate with signed 32-bit
precision, unsigned 32-bit precision, signed 64-bit precision, or unsigned 64-bit
precision, as detailed in §12.4.7 .
The char type is classified as an integral type, but it differs from the other integral types
in two ways:
There are no predefined implicit conversions from other types to the char type. In
particular, even though the byte and ushort types have ranges of values that are
fully representable using the char type, implicit conversions from sbyte, byte, or
ushort to char do not exist.
Constants of the char type shall be written as character_lit erals or as
integer_lit erals in combination with a cast to type char.
Example : (char)10 is the same as '\x000A'. end ex ampleThe checked and unchecked operators and statements are used to control overflow
checking for integral-type arithmetic operations and conversions ( §12.8.19 ). In a checked
context, an overflow produces a compile-time error or causes a
System.OverflowException to be thrown. In an unchecked context, overflows are ignored
and any high-order bits that do not fit in the destination type are discarded.
C# supports two floating-point types: float and double. The float and double types
are represented using the 32-bit single-precision and 64-bit double-precision IEC 60559
formats, which provide the following sets of values:
Positive zero and negative zero. In most situations, positive zero and negative zero
behave identically as the simple value zero, but certain operations distinguish
between the two ( §12.10.3 ).
Positive infinity and negative infinity. Infinities are produced by such operations as
dividing a non-zero number by zero.
Example : 1.0 / 0.0 yields positive infinity, and –1.0 / 0.0 yields negative
infinity. end ex ample
The Not-a-Number  value, often abbreviated NaN. NaNs are produced by invalid
floating-point operations, such as dividing zero by zero.
The finite set of non-zero values of the form s × m × 2ᵉ, where s is 1 or −1, and m
and e are determined by the particular floating-point type: For float, 0 &lt; m &lt; 2²⁴
and −149 ≤ e ≤ 104, and for double, 0 &lt; m &lt; 2⁵³ and −1075 ≤ e ≤ 970.
Denormalized floating-point numbers are considered valid non-zero values. C#
neither requires nor forbids that a conforming implementation support
denormalized floating-point numbers.
The float type can represent values ranging from approximately 1.5 × 10⁻⁴⁵ to 3.4 ×
10³⁸ with a precision of 7 digits.
The double type can represent values ranging from approximately 5.0 × 10⁻³²⁴ to 1.7 ×
10³⁰⁸ with a precision of 15-16 digits.
If either operand of a binary operator is a floating-point type then standard numeric
promotions are applied, as detailed in §12.4.7 , and the operation is performed with
float or double precision.8.3.7 Floating-point typesThe floating-point operators, including the assignment operators, never produce
exceptions. Instead, in exceptional situations, floating-point operations produce zero,
infinity, or NaN, as described below:
The result of a floating-point operation is rounded to the nearest representable
value in the destination format.
If the magnitude of the result of a floating-point operation is too small for the
destination format, the result of the operation becomes positive zero or negative
zero.
If the magnitude of the result of a floating-point operation is too large for the
destination format, the result of the operation becomes positive infinity or
negative infinity.
If a floating-point operation is invalid, the result of the operation becomes NaN.
If one or both operands of a floating-point operation is NaN, the result of the
operation becomes NaN.
Floating-point operations may be performed with higher precision than the result type
of the operation. T o force a value of a floating-point type to the exact precision of its
type, an explicit cast ( §12.9.7 ) can be used.
Example : Some hardware architectures support an “extended” or “long double”
floating-point type with greater range and precision than the double type, and
implicitly perform all floating-point operations using this higher precision type. Only
at excessive cost in performance can such hardware architectures be made to
perform floating-point operations with less precision, and rather than require an
implementation to forfeit both performance and precision, C# allows a higher
precision type to be used for all floating-point operations. Other than delivering
more precise results, this rarely has any measurable effects. However, in expressions
of the form x * y / z, where the multiplication produces a result that is outside the
double range, but the subsequent division brings the temporary result back into the
double range, the fact that the expression is evaluated in a higher range format can
cause a finite result to be produced instead of an infinity. end ex ample
The decimal type is a 128-bit data type suitable for financial and monetary calculations.
The decimal type can represent values including those in the range at least -7.9 × 10⁻²⁸
to 7.9 × 10²⁸, with at least 28-digit precision.
The finite set of values of type decimal are of the form (–1)ᵛ × c × 10⁻ᵉ, where the sign v
is 0 or 1, the coefficient c is given by 0 ≤ c &lt; Cmax , and the scale e is such that Emin  ≤ e8.3.8 The Decimal type≤ Emax , where Cmax  is at least 1 × 10²⁸, Emin  ≤ 0, and Emax  ≥ 28. The decimal type
does not necessarily support signed zeros, infinities, or NaN’s.
A decimal is represented as an integer scaled by a power of ten. For decimals with an
absolute value less than 1.0m, the value is exact to at least the 28th decimal place. For
decimals with an absolute value greater than or equal to 1.0m, the value is exact to at
least 28 digits. Contrary to the float and double data types, decimal fractional numbers
such as 0.1 can be represented exactly in the decimal representation. In the float and
double representations, such numbers often have non-terminating binary expansions,
making those representations more prone to round-off errors.
If either operand of a binary operator is of decimal type then standard numeric
promotions are applied, as detailed in §12.4.7 , and the operation is performed with
double precision.
The result of an operation on values of type decimal is that which would result from
calculating an exact result (preserving scale, as defined for each operator) and then
rounding to fit the representation. R esults are rounded to the nearest representable
value, and, when a result is equally close to two representable values, to the value that
has an even number in the least significant digit position (this is known as “banker’s
rounding”). That is, results are exact to at least the 28th decimal place. Note that
rounding may produce a zero value from a non-zero value.
If a decimal arithmetic operation produces a result whose magnitude is too large for the
decimal format, a System.OverflowException is thrown.
The decimal type has greater precision but may have a smaller range than the floating-
point types. Thus, conversions from the floating-point types to decimal might produce
overflow exceptions, and conversions from decimal to the floating-point types might
cause loss of precision or overflow exceptions. For these reasons, no implicit conversions
exist between the floating-point types and decimal, and without explicit casts, a
compile-time error occurs when floating-point and decimal operands are directly mixed
in the same expression.
The bool type represents Boolean logical quantities. The possible values of type bool
are true and false. The representation of false is described in §8.3.3 . Although the
representation of true is unspecified, it shall be different from that of false.8.3.9 The Bool typeNo standard conversions exist between bool and other value types. In particular, the
bool type is distinct and separate from the integral types, a bool value cannot be used
in place of an integral value, and vice versa.
Note: In the C and C++ languages, a zero integral or floating-point value, or a null
pointer can be converted to the Boolean value false, and a non-zero integral or
floating-point value, or a non-null pointer can be converted to the Boolean value
true. In C#, such conversions are accomplished by explicitly comparing an integral
or floating-point value to zero, or by explicitly comparing an object reference to
null. end not e
An enumeration type is a distinct type with named constants. Every enumeration type
has an underlying type, which shall be byte, sbyte, short, ushort, int, uint, long or
ulong. The set of values of the enumeration type is the same as the set of values of the
underlying type. V alues of the enumeration type are not restricted to the values of the
named constants. Enumeration types are defined through enumeration declarations
(§19.2 ).
A tuple type represents an ordered, fixed-length sequence of values with optional
names and individual types. The number of elements in a tuple type is referred to as its
arity. A tuple type is written (T1 I1, ..., Tn In) with n ≥ 2, where the identifiers
I1...In are optional tuple element names .
This syntax is shorthand for a type constructed with the types T1...Tn from
System.ValueTuple&lt;...&gt;, which shall be a set of generic struct types capable of directly
expressing tuple types of any arity between two and seven inclusive. There does not
need to exist a System.ValueTuple&lt;...&gt; declaration that directly matches the arity of any
tuple type with a corresponding number of type parameters. Instead, tuples with an arity
greater than seven are represented with a generic struct type System.ValueTuple&lt;T1,
..., T7, TRest&gt; that in addition to tuple elements has a Rest field containing a nested
value of the remaining elements, using another System.ValueTuple&lt;...&gt; type. Such
nesting may be observable in various ways, e.g. via the presence of a Rest field. Where
only a single additional field is required, the generic struct type System.ValueTuple<T1>
is used; this type is not considered a tuple type in itself. Where more than seven8.3.10 Enumeration types
8.3.11 Tuple typesadditional fields are required, System.ValueTuple&lt;T1, ..., T7, TRest&gt; is used
recursively.
Element names within a tuple type shall be distinct. A tuple element name of the form
ItemX, where X is any sequence of non- 0-initiated decimal digits that could represent
the position of a tuple element, is only permitted at the position denoted by X.
The optional element names are not represented in the ValueTuple&lt;...&gt; types, and are
not stored in the runtime representation of a tuple value. There is an identity conversion
between all tuple types with the same arity and identity-convertible sequences of
element types, as well as to and from the corresponding constructed ValueTuple&lt;...&gt;
type.
The new operator §12.8.16.2  cannot be applied with the tuple type syntax new (T1, ...,
Tn). Tuple values can be created from tuple expressions ( §12.8.6 ), or by applying the
new operator directly to a type constructed from ValueTuple&lt;...&gt;.
Tuple elements are public fields with the names Item1, Item2, etc., and can be accessed
via a member access on a tuple value ( §12.8.7 . Additionally, if the tuple type has a name
for a given element, that name can be used to access the element in question.
Note: Even when large tuples are represented with nested System.ValueTuple&lt;...&gt;
values, each tuple element can still be accessed directly with the Item... name
corresponding to its position. end not e
Example : Given the following examples:
C#
The tuple types for pair1, pair2, and pair3 are all valid, with names for no, some
or all of the tuple type elements.
The tuple type for pair4 is valid because the names Item1 and Item2 match their
positions, whereas the tuple type for pair5 is disallowed, because the names Item2(int, string) pair1 = ( 1, &quot;One&quot;);
(int, string word) pair2 = ( 2, &quot;Two&quot;);
(int number, string word) pair3 = ( 3, &quot;Three&quot;);
(int Item1, string Item2) pair4 = ( 4, &quot;Four&quot;);
// Error: &quot;Item&quot; names do not match their position
(int Item2, string Item123) pair5 = ( 5, &quot;Five&quot;);
(int, string) pair6 = new ValueTuple&lt; int, string&gt;(6, &quot;Six&quot;);
ValueTuple&lt; int, string&gt; pair7 = ( 7, &quot;Seven&quot;);
Console.WriteLine( $&quot;{pair2.Item1} , {pair2.Item2} , {pair2.word} &quot;);and Item123 do not.
The declarations for pair6 and pair7 demonstrate that tuple types are
interchangeable with constructed types of the form ValueTuple&lt;...&gt;, and that the
new operator is allowed with the latter syntax.
The last line shows that tuple elements can be accessed by the Item name
corresponding to their position, as well as by the corresponding tuple element
name, if present in the type. end ex ample
A nullable value type can represent all values of its underlying type plus an additional
null value. A nullable value type is written T?, where T is the underlying type. This
syntax is shorthand for System.Nullable<T>, and the two forms can be used
interchangeably.
Conversely, a non-nullable v alue type  is any value type other than System.Nullable<T>
and its shorthand T? (for any T), plus any type parameter that is constrained to be a
non-nullable value type (that is, any type parameter with a value type constraint
(§15.2.5 )). The System.Nullable<T> type specifies the value type constraint for T, which
means that the underlying type of a nullable value type can be any non-nullable value
type. The underlying type of a nullable value type cannot be a nullable value type or a
reference type. For example, int?? and string? are invalid types.
An instance of a nullable value type T? has two public read-only properties:
A HasValue property of type bool
A Value property of type T
An instance for which HasValue is true is said to be non-null. A non-null instance
contains a known value and Value returns that value.
An instance for which HasValue is false is said to be null. A null instance has an
undefined value. Attempting to read the Value of a null instance causes a
System.InvalidOperationException to be thrown. The process of accessing the V alue
property of a nullable instance is referred to as unwr apping .
In addition to the default constructor, every nullable value type T? has a public
constructor with a single parameter of type T. Given a value x of type T, a constructor
invocation of the form8.3.12 Nullable value typesC#
creates a non-null instance of T? for which the Value property is x. The process of
creating a non-null instance of a nullable value type for a given value is referred to as
wrapping .
Implicit conversions are available from the null literal to T? (§10.2.7 ) and from T to T?
(§10.2.6 ).
The nullable type T? implements no interfaces ( §18). In particular, this means it does not
implement any interface that the underlying type T does.
The concept of boxing and unboxing provide a bridge between value_type s and
reference_type s by permitting any value of a value_type  to be converted to and from
type object. Boxing and unboxing enables a unified view of the type system wherein a
value of any type can ultimately be treated as an object.
Boxing is described in more detail in §10.2.9  and unboxing is described in §10.3.7 .
A generic type declaration, by itself, denotes an unbound gener ic type  that is used as a
“blueprint” to form many different types, by way of applying type ar guments . The type
arguments are written within angle brackets ( &lt; and &gt;) immediately following the name
of the generic type. A type that includes at least one type argument is called a
constr ucted type . A constructed type can be used in most places in the language in
which a type name can appear. An unbound generic type can only be used within a
typeo f_expr ession  (§12.8.17 ).
Constructed types can also be used in expressions as simple names ( §12.8.4 ) or when
accessing a member ( §12.8.7 ).
When a namesp ace_or_type_name  is evaluated, only generic types with the correct
number of type parameters are considered. Thus, it is possible to use the same identifier
to identify different types, as long as the types have different numbers of typenew T?(x)
8.3.13 Boxing and unboxing
8.4 Constructed types
8.4.1 Generalparameters. This is useful when mixing generic and non-generic classes in the same
program.
Example :
C#
end ex ample
The detailed rules for name lookup in the namesp ace_or_type_name  productions is
described in §7.8. The resolution of ambiguities in these productions is described in
§6.2.5 . A type_name  might identify a constructed type even though it doesn’t specify
type parameters directly. This can occur where a type is nested within a generic class
declaration, and the instance type of the containing declaration is implicitly used for
name lookup ( §15.3.9.7 ).
Example :
C#
end ex amplenamespace  Widgets
{
class Queue {...}
class Queue<TElement > {...}
}
namespace  MyApplication
{
using Widgets;
class X
{
Queue q1;      // Non-generic Widgets.Queue
Queue<int> q2; // Generic Widgets.Queue
}
}
class Outer<T>
{
public class Inner {...}
public Inner i; // Type of i is Outer<T>.Inner
}A non-enum constructed type shall not be used as an unmanaged_type  (§8.8).
Each argument in a type argument list is simply a type.
ANTLR
Each type argument shall satisfy any constraints on the corresponding type parameter
(§15.2.5 ).
All types can be classified as either open types  or closed types . An open type is a type
that involves type parameters. More specifically:
A type parameter defines an open type.
An array type is an open type if and only if its element type is an open type.
A constructed type is an open type if and only if one or more of its type arguments
is an open type. A constructed nested type is an open type if and only if one or
more of its type arguments or the type arguments of its containing type(s) is an
open type.
A closed type is a type that is not an open type.
At run-time, all of the code within a generic type declaration is executed in the context
of a closed constructed type that was created by applying type arguments to the
generic declaration. Each type parameter within the generic type is bound to a particular
run-time type. The run-time processing of all statements and expressions always occurs
with closed types, and open types occur only during compile-time processing.
Each closed constructed type has its own set of static variables, which are not shared
with any other closed constructed types. Since an open type does not exist at run-time,8.4.2 Type arguments
type_argument_list
: '&lt;' type_arguments '&gt;'
;
type_arguments
: type_argument ( ',' type_argument)*
;<br />
type_argument
: type
;
8.4.3 Open and closed typesthere are no static variables associated with an open type. T wo closed constructed types
are the same type if they are constructed from the same unbound generic type, and
their corresponding type arguments are the same type.
The term unbound type  refers to a non-generic type or an unbound generic type. The
term bound type  refers to a non-generic type or a constructed type.
An unbound type refers to the entity declared by a type declaration. An unbound
generic type is not itself a type, and cannot be used as the type of a variable, argument
or return value, or as a base type. The only construct in which an unbound generic type
can be referenced is the typeof expression ( §12.8.17 ).
Whenever a constructed type or generic method is referenced, the supplied type
arguments are checked against the type parameter constraints declared on the generic
type or method ( §15.2.5 ). For each where clause, the type argument A that corresponds
to the named type parameter is checked against each constraint as follows:
If the constraint is a class type, an interface type, or a type parameter, let C
represent that constraint with the supplied type arguments substituted for any
type parameters that appear in the constraint. T o satisfy the constraint, it shall be
the case that type A is convertible to type C by one of the following:
An identity conversion ( §10.2.2 )
An implicit reference conversion ( §10.2.8 )
A boxing conversion ( §10.2.9 ), provided that type A is a non-nullable value type.
An implicit reference, boxing or type parameter conversion from a type
parameter A to C.
If the constraint is the reference type constraint ( class), the type A shall satisfy
one of the following:
A is an interface type, class type, delegate type, array type or the dynamic type.
Note: System.ValueType and System.Enum are reference types that satisfy this
constraint. end not e
A is a type parameter that is known to be a reference type ( §8.2).
If the constraint is the value type constraint ( struct), the type A shall satisfy one
of the following:8.4.4 Bound and unbound types
8.4.5 Satisfying constraintsA is a struct type or enum type, but not a nullable value type.
Note: System.ValueType and System.Enum are reference types that do not
satisfy this constraint. end not e
A is a type parameter having the value type constraint ( §15.2.5 ).
If the constraint is the constructor constraint new(), the type A shall not be
abstract and shall have a public parameterless constructor. This is satisfied if one
of the following is true:
A is a value type, since all value types have a public default constructor ( §8.3.3 ).
A is a type parameter having the constructor constraint ( §15.2.5 ).
A is a type parameter having the value type constraint ( §15.2.5 ).
A is a class that is not abstract and contains an explicitly declared public
constructor with no parameters.
A is not abstract and has a default constructor ( §15.11.5 ).
A compile-time error occurs if one or more of a type parameter’s constraints are not
satisfied by the given type arguments.
Since type parameters are not inherited, constraints are never inherited either.
Example : In the following, D needs to specify the constraint on its type parameter T
so that T satisfies the constraint imposed by the base class B<T>. In contrast,
class E need not specify a constraint, because List<T> implements IEnumerable
for any T.
C#
end ex ample
A type parameter is an identifier designating a value type or reference type that the
parameter is bound to at run-time.
ANTLRclass B<T> where T: IEnumerable  {...}
class D<T> : B<T> where T: IEnumerable  {...}
class E<T> : B&lt;List<T>&gt; {...}
8.5 Type parametersSince a type parameter can be instantiated with many different type arguments, type
parameters have slightly different operations and restrictions than other types.
Note: These include:
A type parameter cannot be used directly to declare a base class ( §15.2.4.2 ) or
interface ( §18.2.4 ).
The rules for member lookup on type parameters depend on the constraints, if
any, applied to the type parameter. They are detailed in §12.5 .
The available conversions for a type parameter depend on the constraints, if
any, applied to the type parameter. They are detailed in §10.2.12  and §10.3.9 .
The literal null cannot be converted to a type given by a type parameter,
except if the type parameter is known to be a reference type ( §10.2.12 ).
However, a default expression ( §12.8.20 ) can be used instead. In addition, a
value with a type given by a type parameter can be compared with null using
== and != (§12.12.7 ) unless the type parameter has the value type constraint.
A new expression ( §12.8.16.2 ) can only be used with a type parameter if the
type parameter is constrained by a constr uctor_constr aint or the value type
constraint ( §15.2.5 ).
A type parameter cannot be used anywhere within an attribute.
A type parameter cannot be used in a member access ( §12.8.7 ) or type name
(§7.8) to identify a static member or a nested type.
A type parameter cannot be used as an unmanaged_type  (§8.8).
end not e
As a type, type parameters are purely a compile-time construct. At run-time, each type
parameter is bound to a run-time type that was specified by supplying a type argument
to the generic type declaration. Thus, the type of a variable declared with a type
parameter will, at run-time, be a closed constructed type §8.4.3 . The run-time execution
of all statements and expressions involving type parameters uses the type that was
supplied as the type argument for that parameter.type_parameter
: identifier
;
8.6 Expression tree typesExpression tr ees permit lambda expressions to be represented as data structures instead
of executable code. Expression trees are values of expression tr ee types  of the form
System.Linq.Expressions.Expression<TDelegate>, where TDelegate is any delegate type.
For the remainder of this specification these types will be referred to using the
shorthand Expression<TDelegate>.
If a conversion exists from a lambda expression to a delegate type D, a conversion also
exists to the expression tree type Expression<TDelegate>. Whereas the conversion of a
lambda expression to a delegate type generates a delegate that references executable
code for the lambda expression, conversion to an expression tree type creates an
expression tree representation of the lambda expression. More details of this conversion
are provided in §10.7.3 .
Example : The following program represents a lambda expression both as executable
code and as an expression tree. Because a conversion exists to Func&lt;int,int&gt;, a
conversion also exists to Expression&lt;Func&lt;int,int&gt;&gt;:
C#
Following these assignments, the delegate del references a method that returns x</p>
<ul>
<li>
<p>1, and the expression tree exp references a data structure that describes the
expression x =&gt; x + 1.
end ex ample
Expression<TDelegate> provides an instance method Compile which produces a
delegate of type TDelegate:
C#
Invoking this delegate causes the code represented by the expression tree to be
executed. Thus, given the definitions above, del and del2 are equivalent, and the
following two statements will have the same effect:
C#Func&lt;int,int&gt; del = x =&gt; x + 1;             // Code
Expression&lt;Func&lt; int,int&gt;&gt; exp = x =&gt; x + 1; // Data
Func&lt;int,int&gt; del2 = exp.Compile();After executing this code, i1 and i2 will both have the value 2.
The API surface provided by Expression<TDelegate> is implementation-specific beyond
the requirement for a Compile method described above.
Note: While the details of the API provided for expression trees are implementation-
specific, it is expected that an implementation will:
Enable code to inspect and respond to the structure of an expression tree
created as the result of a conversion from a lambda expression
Enable expression trees to be created programatically within user code
end not e
The type dynamic uses dynamic binding, as described in detail in §12.3.2 , as opposed to
static binding which is used by all other types.
dynamic is considered identical to object except in the following respects:
Operations on expressions of type dynamic can be dynamically bound ( §12.3.3 ).
Type inference ( §12.6.3 ) will prefer dynamic over object if both are candidates.
dynamic cannot be used as
the type in an object_cr eation_expr ession  (§12.8.16.2 )
a predefined_type  in a member_ac cess (§12.8.7.1 )
the operand of the typeof operator
an attribute argument
a constraint
an extension method type
any part of a type argument within struct_int erfaces (§16.2.5 ) or
interface_type_list  (§15.2.4.1 ).
Because of this equivalence, the following holds:
There is an implicit identity conversion between object and dynamic, and between
constructed types that are the same when replacing dynamic with object.int i1 = del( 1);
int i2 = del2( 1);
8.7 The dynamic typeImplicit and explicit conversions to and from object also apply to and from
dynamic.
Signatures that are the same when replacing dynamic with object are considered
the same signature.
The type dynamic is indistinguishable from object at run-time.
An expression of the type dynamic is referred to as a dynamic expr ession .
ANTLR
An unmanaged_type  is any type that isn’t a reference_type , a type_p aramet er, or a
constructed type, and contains no instance fields whose type is not an unmanaged_type .
In other words, an unmanaged_type  is one of the following:
sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double,
decimal, or bool.
Any enum_type .
Any user-defined struct_type  that is not a constructed type and contains instance
fields of unmanaged_type s only.8.8 Unm anaged types
unmanaged_type
: value_type
| pointer_type     // unsafe code support
;9 Variables
Article •06/08/2023
Variables represent storage locations. Every variable has a type that determines what
values can be stored in the variable. C# is a type-safe language, and the C# compiler
guarantees that values stored in variables are always of the appropriate type. The value
of a variable can be changed through assignment or through use of the ++ and --
operators.
A variable shall be definitely assigned  (§9.4) before its value can be obtained.
As described in the following subclauses, variables are either initially assigned  or
initially unassigned . An initially assigned variable has a well-defined initial value and is
always considered definitely assigned. An initially unassigned variable has no initial
value. For an initially unassigned variable to be considered definitely assigned at a
certain location, an assignment to the variable shall occur in every possible execution
path leading to that location.
C# defines eight categories of variables: static variables, instance variables, array
elements, value parameters, input parameters, reference parameters, output parameters,
and local variables. The subclauses that follow describe each of these categories.
Example : In the following code
C#9.1 General
9.2 Variable categories
9.2.1 General
class A
{
public static int x;
int y;
void F(int[] v, int a, ref int b, out int c, in int d)
{
int i = 1;
c = a + b++ + d;x is a static variable, y is an instance variable, v[0] is an array element, a is a value
parameter, b is a reference parameter, c is an output parameter, d is an input
parameter, and i is a local variable. end ex ample
A field declared with the static modifier is a static variable. A static variable comes into
existence before execution of the static constructor ( §15.12 ) for its containing type,
and ceases to exist when the associated application domain ceases to exist.
The initial value of a static variable is the default value ( §9.3) of the variable’s type.
For the purposes of definite-assignment checking, a static variable is considered initially
assigned.
A field declared without the static modifier is an instance variable.
An instance variable of a class comes into existence when a new instance of that class is
created, and ceases to exist when there are no references to that instance and the
instance’s finalizer (if any) has executed.
The initial value of an instance variable of a class is the default value ( §9.3) of the
variable’s type.
For the purpose of definite-assignment checking, an instance variable of a class is
considered initially assigned.
An instance variable of a struct has exactly the same lifetime as the struct variable to
which it belongs. In other words, when a variable of a struct type comes into existence
or ceases to exist, so too do the instance variables of the struct.    }
}
9.2.2 Static variables
9.2.3 Instance variables
9.2.3.1 General
9.2.3.2 Instance variables in classes
9.2.3.3 Instance variables in structsThe initial assignment state of an instance variable of a struct is the same as that of the
containing struct variable. In other words, when a struct variable is considered initially
assigned, so too are its instance variables, and when a struct variable is considered
initially unassigned, its instance variables are likewise unassigned.
The elements of an array come into existence when an array instance is created, and
cease to exist when there are no references to that array instance.
The initial value of each of the elements of an array is the default value ( §9.3) of the type
of the array elements.
For the purpose of definite-assignment checking, an array element is considered initially
assigned.
A parameter declared without an in, out, or ref modifier is a value p aramet er.
A value parameter comes into existence upon invocation of the function member
(method, instance constructor, accessor, or operator) or anonymous function to which
the parameter belongs, and is initialized with the value of the argument given in the
invocation. A value parameter normally ceases to exist when execution of the function
body completes. However, if the value parameter is captured by an anonymous function
(§12.19.6.2 ), its lifetime extends at least until the delegate or expression tree created
from that anonymous function is eligible for garbage collection.
For the purpose of definite-assignment checking, a value parameter is considered
initially assigned.
A parameter declared with a ref modifier is a reference paramet er.
A reference parameter is a reference variable ( §9.7) which comes into existence upon
invocation of the function member, delegate, anonymous function, or local function and
its referent is initialized to the variable given as the argument in that invocation. A
reference parameter ceases to exist when execution of the function body completes.
Unlike value parameters a reference parameter may not be captured ( §9.7.2.9 ).
The following definite-assignment rules apply to reference parameters.9.2.4 Array elements
9.2.5 Value parameters
9.2.6 Reference parametersNote: The rules for output parameters are different, and are described in ( §9.2.7 ). end
note
A variable shall be definitely assigned ( §9.4) before it can be passed as a reference
parameter in a function member or delegate invocation.
Within a function member or anonymous function, a reference parameter is
considered initially assigned.
For a struct type, within an instance method or instance accessor ( §12.2.1 ) or instance
constructor with a constructor initializer, the this keyword behaves exactly as a
reference parameter of the struct type ( §12.8.13 ).
A parameter declared with an out modifier is an output p aramet er.
An output parameter is a reference variable ( §9.7) which comes into existence upon
invocation of the function member, delegate, anonymous function, or local function and
its referent is initialized to the variable given as the argument in that invocation. An
output parameter ceases to exist when execution of the function body completes. Unlike
value parameters an output parameter may not be captured ( §9.7.2.9 ).
The following definite-assignment rules apply to output parameters.
Note: The rules for reference parameters are different, and are described in ( §9.2.6 ).
end not e
A variable need not be definitely assigned before it can be passed as an output
parameter in a function member or delegate invocation.
Following the normal completion of a function member or delegate invocation,
each variable that was passed as an output parameter is considered assigned in
that execution path.
Within a function member or anonymous function, an output parameter is
considered initially unassigned.
Every output parameter of a function member, anonymous function, or local
function shall be definitely assigned ( §9.4) before the function member,
anonymous function, or local function returns normally.
A parameter declared with an in modifier is an input p aramet er.9.2.7 Output parameters
9.2.8 Input parametersAn input parameter is a reference variable ( §9.7) which comes into existence upon
invocation of the function member, delegate, anonymous function, or local function and
its referent is initialized to the variable_r eference given as the argument in that
invocation. An input parameter ceases to exist when execution of the function body
completes. Unlike value parameters an input parameter may not be captured ( §9.7.2.9 ).
The following definite assignment rules apply to input parameters.
A variable shall be definitely assigned ( §9.4) before it can be passed as an input
parameter in a function member or delegate invocation.
Within a function member, anonymous function, or local function an input
parameter is considered initially assigned.
A local v ariable  is declared by a local_v ariable_declar ation , declar ation_expr ession ,
foreach_st atement , or speci fic_cat ch_claus e of a try_statement . A local variable can also
be declared by certain kinds of patterns (§11). For a foreach_st atement , the local variable
is an iteration variable ( §13.9.5 ). For a speci fic_cat ch_claus e, the local variable is an
exception variable ( §13.11 ). A local variable declared by a foreach_st atement  or
speci fic_cat ch_claus e is considered initially assigned.
A local_v ariable_declar ation  can occur in a block , a for_st atement , a switch_block , or a
using_st atement . A declar ation_expr ession  can occur as an out argument_v alue, and as a
tuple_element  that is the target of a deconstructing assignment ( §12.21.2 ).
The lifetime of a local variable is the portion of program execution during which storage
is guaranteed to be reserved for it. This lifetime extends from entry into the scope with
which it is associated, at least until execution of that scope ends in some way. (Entering
an enclosed block , calling a method, or yielding a value from an iterator block suspends,
but does not end, execution of the current scope.) If the local variable is captured by an
anonymous function ( §12.19.6.2 ), its lifetime extends at least until the delegate or
expression tree created from the anonymous function, along with any other objects that
come to reference the captured variable, are eligible for garbage collection. If the parent
scope is entered recursively or iteratively, a new instance of the local variable is created
each time, and its initializer, if any, is evaluated each time.
Note: A local variable is instantiated each time its scope is entered. This behavior is
visible to user code containing anonymous methods. end not e
Note: The lifetime of an iteration v ariable  (§13.9.5 ) declared by a foreach_st atement  is
a single iteration of that statement. Each iteration creates a new variable. end not e9.2.9 Local variablesNote: The actual lifetime of a local variable is implementation-dependent. For
example, a compiler might statically determine that a local variable in a block is only
used for a small portion of that block. Using this analysis, the compiler could
generate code that results in the variable’s storage having a shorter lifetime than its
containing block.
The storage referred to by a local reference variable is reclaimed independently of
the lifetime of that local reference variable ( §7.9).
end not e
A local variable introduced by a local_v ariable_declar ation  or declar ation_expr ession  is
not automatically initialized and thus has no default value. Such a local variable is
considered initially unassigned.
Note: A local_v ariable_declar ation  that includes an initializer is still initially
unassigned. Execution of the declaration behaves exactly like an assignment to the
variable ( §9.4.4.5 ). Using a variable before its initializer has been executed; e.g.,
within the initializer expression itself or by using a goto_statement  which bypasses
the initializer; is a compile-time error:
C#
Within the scope of a local variable, it is a compile-time error to refer to that local
variable in a textual position that precedes its declarator.
end not e
A discard is a local variable that has no name. A discard is introduced by a declaration
expression ( §12.17 ) with the identifier _; and is either implicitly typed ( _ or var _) or
explicitly typed ( T <em>).
Note: _ is a valid identifier in many forms of declarations. end not egoto L;
int x = 1; // never executed
L: x += 1; // error: x not definitely assigned
9.2.9.1 DiscardsBecause a discard has no name, the only reference to the variable it represents is the
expression that introduces it.
Note: A discard can however be passed as an out argument, allowing the out
parameter to denote its associated storage location. end not e
A discard is not initially assigned, so it is always an error to access its value.
Example :
C#
The example assumes that there is no declaration of the name _ in scope.
The assignment to _ shows a simple pattern for ignoring the result of an
expression. The call of M shows the different forms of discards available in tuples
and as out parameters.
end ex ample
The following categories of variables are automatically initialized to their default values:
Static variables.
Instance variables of class instances.
Array elements.
The default value of a variable depends on the type of the variable and is determined as
follows:
For a variable of a value_type , the default value is the same as the value computed
by the value_type ’s default constructor ( §8.3.3 ).
For a variable of a reference_type , the default value is null.
Note: Initialization to default values is typically done by having the memory
manager or garbage collector initialize memory to all-bits-zero before it is allocated
for use. For this reason, it is convenient to use all-bits-zero to represent the null
reference. end not e</em> = &quot;Hello&quot;.Length;
(int, int, int) M(out int i1, out int i2, out int i3) { ... }
(int _, var _, _) = M( out int _, out var _, out <em>);
9.3 Default valuesAt a given location in the executable code of a function member or an anonymous
function, a variable is said to be definitely assigned  if the compiler can prove, by a
particular static flow analysis ( §9.4.4 ), that the variable has been automatically initialized
or has been the target of at least one assignment.
Note: Informally stated, the rules of definite assignment are:
An initially assigned variable ( §9.4.2 ) is always considered definitely assigned.
An initially unassigned variable ( §9.4.3 ) is considered definitely assigned at a
given location if all possible execution paths leading to that location contain at
least one of the following:
A simple assignment ( §12.21.2 ) in which the variable is the left operand.
An invocation expression ( §12.8.9 ) or object creation expression ( §12.8.16.2 )
that passes the variable as an output parameter.
For a local variable, a local variable declaration for the variable ( §13.6.2 ) that
includes a variable initializer.
The formal specification underlying the above informal rules is described in §9.4.2 ,
§9.4.3 , and §9.4.4 .
end not e
The definite-assignment states of instance variables of a struct_type  variable are tracked
individually as well as collectively. In additional to the rules above, the following rules
apply to struct_type  variables and their instance variables:
An instance variable is considered definitely assigned if its containing struct_type
variable is considered definitely assigned.
A struct_type  variable is considered definitely assigned if each of its instance
variables is considered definitely assigned.
Definite assignment is a requirement in the following contexts:
A variable shall be definitely assigned at each location where its value is obtained.
Note: This ensures that undefined values never occur. end not e
The occurrence of a variable in an expression is considered to obtain the value
of the variable, except when9.4 Definite assignment
9.4.1 Generalthe variable is the left operand of a simple assignment,
the variable is passed as an output parameter, or
the variable is a struct_type  variable and occurs as the left operand of a member
access.
A variable shall be definitely assigned at each location where it is passed as a
reference parameter.
Note: This ensures that the function member being invoked can consider the
reference parameter initially assigned. end not e
A variable shall be definitely assigned at each location where it is passed as an
input parameter.
Note: This ensures that the function member being invoked can consider the
input parameter initially assigned. end not e
All output parameters of a function member shall be definitely assigned at each
location where the function member returns (through a return statement or
through execution reaching the end of the function member body).
Note: This ensures that function members do not return undefined values in
output parameters, thus enabling the compiler to consider a function member
invocation that takes a variable as an output parameter equivalent to an
assignment to the variable. end not e
The this variable of a struct_type  instance constructor shall be definitely assigned
at each location where that instance constructor returns.
The following categories of variables are classified as initially assigned:
Static variables.
Instance variables of class instances.
Instance variables of initially assigned struct variables.
Array elements.
Value parameters.
Reference parameters.
Input parameters.
Variables declared in a catch clause or a foreach statement.9.4.2 Initially assigned variablesThe following categories of variables are classified as initially unassigned:
Instance variables of initially unassigned struct variables.
Output parameters, including the this variable of struct instance constructors
without a constructor initializer.
Local variables, except those declared in a catch clause or a foreach statement.
In order to determine that each used variable is definitely assigned, the compiler shall
use a process that is equivalent to the one described in this subclause.
The compiler processes the body of each function member that has one or more initially
unassigned variables. For each initially unassigned variable v, the compiler determines a
definite-assignment st ate for v at each of the following points in the function member:
At the beginning of each statement
At the end point ( §13.2 ) of each statement
On each arc which transfers control to another statement or to the end point of a
statement
At the beginning of each expression
At the end of each expression
The definite-assignment state of v can be either:
Definitely assigned. This indicates that on all possible control flows to this point, v
has been assigned a value.
Not definitely assigned. For the state of a variable at the end of an expression of
type bool, the state of a variable that isn’t definitely assigned might (but doesn’t
necessarily) fall into one of the following sub-states:
Definitely assigned after true expression. This state indicates that v is definitely
assigned if the Boolean expression evaluated as true, but is not necessarily
assigned if the Boolean expression evaluated as false.
Definitely assigned after false expression. This state indicates that v is definitely
assigned if the Boolean expression evaluated as false, but is not necessarily
assigned if the Boolean expression evaluated as true.
The following rules govern how the state of a variable v is determined at each location.9.4.3 Initially unassigned variables
9.4.4 Precise rules for determining definite assignment
9.4.4.1 Generalv is not definitely assigned at the beginning of a function member body.
The definite-assignment state of v at the beginning of any other statement is
determined by checking the definite-assignment state of v on all control flow
transfers that target the beginning of that statement. If (and only if) v is definitely
assigned on all such control flow transfers, then v is definitely assigned at the
beginning of the statement. The set of possible control flow transfers is
determined in the same way as for checking statement reachability ( §13.2 ).
The definite-assignment state of v at the end point of a block, checked,
unchecked, if, while, do, for, foreach, lock, using, or switch statement is
determined by checking the definite-assignment state of v on all control flow
transfers that target the end point of that statement. If v is definitely assigned on
all such control flow transfers, then v is definitely assigned at the end point of the
statement. Otherwise, v is not definitely assigned at the end point of the
statement. The set of possible control flow transfers is determined in the same way
as for checking statement reachability ( §13.2 ).
Note: Because there are no control paths to an unreachable statement, v is definitely
assigned at the beginning of any unreachable statement. end not e
The definite-assignment state of v on the control transfer to the first statement of the
statement list in the block (or to the end point of the block, if the statement list is
empty) is the same as the definite-assignment statement of v before the block, checked,
or unchecked statement.
For an expression statement stmt that consists of the expression expr:
v has the same definite-assignment state at the beginning of expr as at the
beginning of stmt.
If v if definitely assigned at the end of expr, it is definitely assigned at the end point
of stmt; otherwise, it is not definitely assigned at the end point of stmt.
If stmt is a declaration statement without initializers, then v has the same definite-
assignment state at the end point of stmt as at the beginning of stmt.9.4.4.2 General rules for statements
9.4.4.3 Block statements, checked, and unchecked statements
9.4.4.4 Expression statements
9.4.4.5 Declaration statementsIf stmt is a declaration statement with initializers, then the definite-assignment
state for v is determined as if stmt were a statement list, with one assignment
statement for each declaration with an initializer (in the order of declaration).
For a statement stmt of the form:
C#
v has the same definite-assignment state at the beginning of expr as at the
beginning of stmt.
If v is definitely assigned at the end of expr, then it is definitely assigned on the
control flow transfer to then_stmt  and to either else_stmt  or to the end-point of
stmt if there is no else clause.
If v has the state “definitely assigned after true expression” at the end of expr, then
it is definitely assigned on the control flow transfer to then_stmt , and not definitely
assigned on the control flow transfer to either else_stmt  or to the end-point of stmt
if there is no else clause.
If v has the state “definitely assigned after false expression” at the end of expr, then
it is definitely assigned on the control flow transfer to else_stmt , and not definitely
assigned on the control flow transfer to then_stmt . It is definitely assigned at the
end-point of stmt if and only if it is definitely assigned at the end-point of
then_stmt .
Otherwise, v is considered not definitely assigned on the control flow transfer to
either the then_stmt  or else_stmt , or to the end-point of stmt if there is no else
clause.
For a switch statement stmt with a controlling expression expr:
The definite-assignment state of v at the beginning of expr is the same as the state of v
at the beginning of stmt.
The definite-assignment state of v at the beginning of a case’s guard clause is
If v is a pattern variable declared in the switch_label : “definitely assigned”.
If the switch label containing that guard clause ( §13.8.3 ) is not reachable: “definitely
assigned”.9.4.4.6 If statements
if ( «expr» ) «then_stmt» else «else_stmt»
9.4.4.7 Switch statementsOtherwise, the state of v is the same as the state of v after expr.
Example : The second rule eliminates the need for the compiler to issue an error if an
unassigned variable is accessed in unreachable code. The state of b is “definitely
assigned” in the unreachable switch label case 2 when b.
C#
end ex ample
The definite-assignment state of v on the control flow transfer to a reachable switch
block statement list is
If the control transfer was due to a ‘goto case’ or ‘goto default’ statement, then the
state of v is the same as the state at the beginning of that ‘goto’ statement.
If the control transfer was due to the default label of the switch, then the state of
v is the same as the state of v after expr.
If the control transfer was due to an unreachable switch label, then the state of v is
“definitely assigned”.
If the control transfer was due to a reachable switch label with a guard clause, then
the state of v is the same as the state of v after the guard clause.
If the control transfer was due to a reachable switch label without a guard clause,
then the state of v is
If v is a pattern variable declared in the switch_label : “definitely assigned”.
Otherwise, the state of v is the same as the stat of v after expr.
A consequence of these rules is that a pattern variable declared in a switch_label  will be
“not definitely assigned” in the statements of its switch section if it is not the only
reachable switch label in its section.
Example :
C#bool b;
switch (1) 
{
case 2 when b: // b is definitely assigned here.
break;
}
public static double ComputeArea (object shape)
{
switch (shape)
{end ex ample
For a statement stmt of the form:
C#
v has the same definite-assignment state at the beginning of expr as at the
beginning of stmt.
If v is definitely assigned at the end of expr, then it is definitely assigned on the
control flow transfer to while_body  and to the end point of stmt.
If v has the state “definitely assigned after true expression” at the end of expr, then
it is definitely assigned on the control flow transfer to while_body , but not
definitely assigned at the end-point of stmt.
If v has the state “definitely assigned after false expression” at the end of expr, then
it is definitely assigned on the control flow transfer to the end point of stmt, but
not definitely assigned on the control flow transfer to while_body .
For a statement stmt of the form:
C#        case Square s when s.Side == 0:
case Circle c when c.Radius == 0:
case Triangle t when t.Base == 0 || t.Height == 0:
case Rectangle r when r.Length == 0 || r.Height == 0:
// none of s, c, t, or r is definitely assigned
return 0;
case Square s:
// s is definitely assigned
return s.Side * s.Side;
case Circle c:
// c is definitely assigned
return c.Radius * c.Radius * Math.PI;
…
}
}
9.4.4.8 While statements
while ( «expr» ) «while_body»
9.4.4.9 Do statements
do «do_body» while ( «expr» ) ;v has the same definite-assignment state on the control flow transfer from the
beginning of stmt to do_body  as at the beginning of stmt.
v has the same definite-assignment state at the beginning of expr as at the end
point of do_body .
If v is definitely assigned at the end of expr, then it is definitely assigned on the
control flow transfer to the end point of stmt.
If v has the state “definitely assigned after false expression” at the end of expr, then
it is definitely assigned on the control flow transfer to the end point of stmt, but
not definitely assigned on the control flow transfer to do_body .
For a statement of the form:
C#
definite-assignment checking is done as if the statement were written:
C#
with continue statements that target the for statement being translated to goto
statements targeting the label LLoop. If the for_condition  is omitted from the for
statement, then evaluation of definite-assignment proceeds as if for_condition  were
replaced with true in the above expansion.
The definite-assignment state of v on the control flow transfer caused by a break,
continue, or goto statement is the same as the definite-assignment state of v at the
beginning of the statement.9.4.4.10 For statements
for ( «for_initializer» ; «for_condition» ; «for_iterator» )
«embedded_statement»
{
«for_initializer» ;
while ( «for_condition» )
{
«embedded_statement» ;
LLoop: «for_iterator» ;
}
}
9.4.4.11 Break, continue, and goto statementsFor a statement stmt of the form:
C#
the definite-assignment state of v at the beginning of expr is the same as the definite-
assignment state of v at the beginning of stmt.
For a statement stmt of the form:
C#
The definite-assignment state of v at the beginning of expr is the same as the
definite-assignment state of v at the beginning of stmt.
If v is an output parameter, then it shall be definitely assigned either:
after expr
or at the end of the finally block of a try-finally or try-catch-finally
that encloses the return statement.
For a statement stmt of the form:
C#
If v is an output parameter, then it shall be definitely assigned either:
before stmt
or at the end of the finally block of a try-finally or try-catch-finally
that encloses the return statement.
For a statement stmt of the form:
C#9.4.4.12 Throw statements
throw «expr» ;
9.4.4.13 Return statements
return «expr» ;
return ;
9.4.4.14 Try-catch statementsThe definite-assignment state of v at the beginning of try_block  is the same as the
definite-assignment state of v at the beginning of stmt.
The definite-assignment state of v at the beginning of catch_block_i  (for any i) is
the same as the definite-assignment state of v at the beginning of stmt.
The definite-assignment state of v at the end-point of stmt is definitely assigned if
(and only if) v is definitely assigned at the end-point of try_block  and every
catch_block_i  (for every i from 1 to n).
For a statement stmt of the form:
C#
The definite-assignment state of v at the beginning of try_block  is the same as the
definite-assignment state of v at the beginning of stmt.
The definite-assignment state of v at the beginning of finally_block  is the same as
the definite-assignment state of v at the beginning of stmt.
The definite-assignment state of v at the end-point of stmt is definitely assigned if
(and only if) at least one of the following is true:
v is definitely assigned at the end-point of try_block
v is definitely assigned at the end-point of finally_block
If a control flow transfer (such as a goto statement) is made that begins within try_block ,
and ends outside of try_block , then v is also considered definitely assigned on that
control flow transfer if v is definitely assigned at the end-point of finally_block . (This is
not an only if—if v is definitely assigned for another reason on this control flow transfer,
then it is still considered definitely assigned.)
For a statement of the form:
C#try «try_block»
catch ( ... ) «catch_block_1»
...
catch ( ... ) «catch_block_n»
9.4.4.15 Try-finally statements
try «try_block» finally «finally_block»
9.4.4.16 Try-catch-finally statementsdefinite-assignment analysis is done as if the statement were a try-finally statement
enclosing a try-catch statement:
C#
Example : The following example demonstrates how the different blocks of a try
statement ( §13.11 ) affect definite assignment.
C#try «try_block»
catch ( ... ) «catch_block_1»
...
catch ( ... ) «catch_block_n»
finally «finally_block»
try
{
try «try_block»
catch ( ... ) «catch_block_1»
...
catch ( ... ) «catch_block_n»
}
finally «finally_block»
class A
{
static void F()
{
int i, j;
try
{
goto LABEL;
// neither i nor j definitely assigned
i = 1;
// i definitely assigned
}
catch
{
// neither i nor j definitely assigned
i = 3;
// i definitely assigned
}
finally
{
// neither i nor j definitely assigned
j = 5;
// j definitely assigned
}
// i and j definitely assignedend ex ample
For a statement stmt of the form:
C#
The definite-assignment state of v at the beginning of expr is the same as the state
of v at the beginning of stmt.
The definite-assignment state of v on the control flow transfer to
embedded_st atement  or to the end point of stmt is the same as the state of v at the
end of expr.
For a statement stmt of the form:
C#
The definite-assignment state of v at the beginning of resource_acquisition  is the
same as the state of v at the beginning of stmt.
The definite-assignment state of v on the control flow transfer to
embedded_st atement  is the same as the state of v at the end of
resource_acquisition .
For a statement stmt of the form:
C#        LABEL: ;
// j definitely assigned
}
}
9.4.4.17 Foreach statements
foreach ( «type» «identifier» in «expr» ) «embedded_statement»
9.4.4.18 Using statements
using ( «resource_acquisition» ) «embedded_statement»
9.4.4.19 Lock statements
lock ( «expr» ) «embedded_statement»The definite-assignment state of v at the beginning of expr is the same as the state
of v at the beginning of stmt.
The definite-assignment state of v on the control flow transfer to
embedded_st atement  is the same as the state of v at the end of expr.
For a statement stmt of the form:
C#
The definite-assignment state of v at the beginning of expr is the same as the state
of v at the beginning of stmt.
The definite-assignment state of v at the end of stmt is the same as the state of v
at the end of expr.
A yield break statement has no effect on the definite-assignment state.
The following applies to any constant expression, and takes priority over any rules from
the following sections that might apply:
For a constant expression with value true:
If v is definitely assigned before the expression, then v is definitely assigned after
the expression.
Otherwise v is “definitely assigned after false expression” after the expression.
Example :
C#
end ex ample9.4.4.20 Yield statements
yield return «expr» ;
9.4.4.21 General rules for constant expressions
int x;
if (true) {}
else
{
Console.WriteLine(x);
}For a constant expression with value false:
If v is definitely assigned before the expression, then v is definitely assigned after
the expression.
Otherwise v is “definitely assigned after true expression” after the expression.
Example :
C#
end ex ample
For all other constant expressions, the definite-assignment state of v after the
expression is the same as the definite-assignment state of v before the expression.
The following rule applies to these kinds of expressions: literals ( §12.8.2 ), simple names
(§12.8.4 ), member access expressions ( §12.8.7 ), non-indexed base access expressions
(§12.8.14 ), typeof expressions ( §12.8.17 ), default value expressions ( §12.8.20 ), nameof
expressions ( §12.8.22 ), and declaration expressions ( §12.17 ).
The definite-assignment state of v at the end of such an expression is the same as
the definite-assignment state of v at the beginning of the expression.
The following rules apply to these kinds of expressions: parenthesized expressions
(§12.8.5 ), tuple expressions ( §12.8.6 ), element access expressions ( §12.8.11 ), base access
expressions with indexing ( §12.8.14 ), increment and decrement expressions ( §12.8.15 ,
§12.9.6 ), cast expressions ( §12.9.7 ), unary +, -, ~, * expressions, binary +, -, *, /, %,
&lt;&lt;, &gt;&gt;, &lt;, &lt;=, &gt;, &gt;=, ==, !=, is, as, &amp;, |, ^ expressions ( §12.10 , §12.11 , §12.12 ,
§12.13 ), compound assignment expressions ( §12.21.4 ), checked and unchecked
expressions ( §12.8.19 ), array and delegate creation expressions ( §12.8.16 ) , and await
expressions ( §12.9.8 ).int x;
if (false)
{
Console.WriteLine(x);
}
9.4.4.22 General rules for simple expressions
9.4.4.23 General rules for expressions with embedded expressionsEach of these expressions has one or more subexpressions that are unconditionally
evaluated in a fixed order.
Example : The binary % operator evaluates the left hand side of the operator, then
the right hand side. An indexing operation evaluates the indexed expression, and
then evaluates each of the index expressions, in order from left to right. end ex ample
For an expression expr, which has subexpressions expr₁ , expr₂ , …, exprₓ , evaluated in that
order:
The definite-assignment state of v at the beginning of expr₁  is the same as the
definite-assignment state at the beginning of expr.
The definite-assignment state of v at the beginning of exprᵢ (i greater than one) is
the same as the definite-assignment state at the end of exprᵢ₋₁ .
The definite-assignment state of v at the end of expr is the same as the definite-
assignment state at the end of exprₓ .
If the method to be invoked is a partial method that has no implementing partial
method declaration, or is a conditional method for which the call is omitted ( §22.5.3.2 ),
then the definite-assignment state of v after the invocation is the same as the definite-
assignment state of v before the invocation. Otherwise the following rules apply:
For an invocation expression expr of the form:
C#
or an object-creation expression expr of the form:
C#
For an invocation expression, the definite assignment state of v before
primary_expr ession  is the same as the state of v before expr.
For an invocation expression, the definite assignment state of v before arg₁ is the
same as the state of v after primary_expr ession .
For an object creation expression, the definite assignment state of v before arg₁ is
the same as the state of v before expr.9.4.4.24 Invocation expressions and object creation expressions
«primary_expression» ( «arg₁», «arg₂», … , «argₓ» )
new «type» ( «arg₁», «arg₂», … , «argₓ» )For each argument argᵢ, the definite assignment state of v after argᵢ is determined
by the normal expression rules, ignoring any in, out, or ref modifiers.
For each argument argᵢ for any i greater than one, the definite assignment state of
v before argᵢ is the same as the state of v after argᵢ₋₁.
If the variable v is passed as an out argument (i.e., an argument of the form “out
v”) in any of the arguments, then the state of v after expr is definitely assigned.
Otherwise, the state of v after expr is the same as the state of v after argₓ.
For array initializers ( §12.8.16.5 ), object initializers ( §12.8.16.3 ), collection initializers
(§12.8.16.4 ) and anonymous object initializers ( §12.8.16.7 ), the definite-assignment
state is determined by the expansion that these constructs are defined in terms of.
Let the set of assignment t argets in an expression e be defined as follows:
If e is a tuple expression, then the assignment targets in e are the union of the
assignment targets of the elements of e.
Otherwise, the assignment targets in e are e.
For an expression expr of the form:
C#
The definite-assignment state of v before expr_lhs  is the same as the definite-
assignment state of v before expr.
The definite-assignment state of v before expr_r hs is the same as the definite-
assignment state of v after expr_lhs .
If v is an assignment target of expr_lhs , then the definite-assignment state of v
after expr is definitely assigned. Otherwise, if the assignment occurs within the
instance constructor of a struct type, and v is the hidden backing field of an
automatically implemented property P on the instance being constructed, and a
property access designating P is an assigment target of expr_lhs , then the definite-
assignment state of v after expr is definitely assigned. Otherwise, the definite-
assignment state of v after expr is the same as the definite-assignment state of v
after expr_r hs.
Example : In the following code
C#9.4.4.25 Simple assignment expressions
«expr_lhs» = «expr_rhs»the variable x is considered definitely assigned after arr[x = 1] is evaluated as the
left hand side of the second simple assignment.
end ex ample
For an expression expr of the form:
C#
The definite-assignment state of v before expr_f irst is the same as the definite-
assignment state of v before expr.
The definite-assignment state of v before expr_s econd is definitely assigned if and
only if the state of v after expr_f irst is either definitely assigned or “definitely
assigned after true expression”. Otherwise, it is not definitely assigned.
The definite-assignment state of v after expr is determined by:
If the state of v after expr_f irst is definitely assigned, then the state of v after
expr is definitely assigned.
Otherwise, if the state of v after expr_s econd is definitely assigned, and the state
of v after expr_f irst is “definitely assigned after false expression”, then the state
of v after expr is definitely assigned.
Otherwise, if the state of v after expr_s econd is definitely assigned or “definitely
assigned after true expression”, then the state of v after expr is “definitely
assigned after true expression”.
Otherwise, if the state of v after expr_f irst is “definitely assigned after false
expression”, and the state of v after expr_s econd is “definitely assigned after
false expression”, then the state of v after expr is “definitely assigned after false
expression”.
Otherwise, the state of v after expr is not definitely assigned.class A
{
static void F(int[] arr)
{
int x;
arr[x = 1] = x; // ok
}
}
9.4.4.26 &amp;&amp; expressions
«expr_first» &amp;&amp; «expr_second»Example : In the following code
C#
the variable i is considered definitely assigned in one of the embedded statements
of an if statement but not in the other. In the if statement in method F, the
variable i is definitely assigned in the first embedded statement because execution
of the expression (i = y) always precedes execution of this embedded statement.
In contrast, the variable i is not definitely assigned in the second embedded
statement, since x &gt;= 0 might have tested false, resulting in the variable i’s being
unassigned.
end ex ample
For an expression expr of the form:
C#
The definite-assignment state of v before expr_f irst is the same as the definite-
assignment state of v before expr.
The definite-assignment state of v before expr_s econd is definitely assigned if and
only if the state of v after expr_f irst is either definitely assigned or “definitely
assigned after true expression”. Otherwise, it is not definitely assigned.
The definite-assignment statement of v after expr is determined by:class A
{
static void F(int x, int y)
{
int i;
if (x &gt;= 0 &amp;&amp; (i = y) &gt;= 0)
{
// i definitely assigned
}
else
{
// i not definitely assigned
}
// i not definitely assigned
}
}
9.4.4.27 || expressions
«expr_first» || «expr_second»If the state of v after expr_f irst is definitely assigned, then the state of v after
expr is definitely assigned.
Otherwise, if the state of v after expr_s econd is definitely assigned, and the state
of v after expr_f irst is “definitely assigned after true expression”, then the state of
v after expr is definitely assigned.
Otherwise, if the state of v after expr_s econd is definitely assigned or “definitely
assigned after false expression”, then the state of v after expr is “definitely
assigned after false expression”.
Otherwise, if the state of v after expr_f irst is “definitely assigned after true
expression”, and the state of v after expr</em> s econd is “definitely assigned after
true expression”, then the state of v after expr is “definitely assigned after true
expression”.
Otherwise, the state of v after expr is not definitely assigned.
Example : In the following code
C#
the variable i is considered definitely assigned in one of the embedded statements
of an if statement but not in the other. In the if statement in method G, the
variable i is definitely assigned in the second embedded statement because
execution of the expression (i = y) always precedes execution of this embedded
statement. In contrast, the variable i is not definitely assigned in the first
embedded statement, since x &gt;= 0 might have tested true, resulting in the variable
i’s being unassigned.
end ex ampleclass A
{
static void G(int x, int y)
{
int i;
if (x &gt;= 0 || (i = y) &gt;= 0)
{
// i not definitely assigned
}
else
{
// i definitely assigned
}
// i not definitely assigned
}
}For an expression expr of the form:
C#
The definite-assignment state of v before expr_oper and is the same as the definite-
assignment state of v before expr.
The definite-assignment state of v after expr is determined by:
If the state of v after expr_oper and is definitely assigned, then the state of v
after expr is definitely assigned.
Otherwise, if the state of v after expr_oper and is “definitely assigned after false
expression”, then the state of v after expr is “definitely assigned after true
expression”.
Otherwise, if the state of v after expr_oper and is “definitely assigned after true
expression”, then the state of v after expr is “definitely assigned after false
expression”.
Otherwise, the state of v after expr is not definitely assigned.
For an expression expr of the form:
C#
The definite-assignment state of v before expr_f irst is the same as the definite-
assignment state of v before expr.
The definite-assignment state of v before expr_s econd is the same as the definite-
assignment state of v after expr_f irst.
The definite-assignment statement of v after expr is determined by:
If expr_f irst is a constant expression ( §12.23 ) with value null, then the state of v
after expr is the same as the state of v after expr_s econd.
Otherwise, the state of v after expr is the same as the definite-assignment state
of v after expr_f irst.9.4.4.28 ! expressions
! «expr_operand»
9.4.4.29 ?? expressions
«expr_first» ?? «expr_second»
9.4.4.30 ?: expressionsFor an expression expr of the form:
C#
The definite-assignment state of v before expr_c ond is the same as the state of v
before expr.
The definite-assignment state of v before expr_tr ue is definitely assigned if the
state of v after expr_c ond is definitely assigned or “definitely assigned after true
expression”.
The definite-assignment state of v before expr_fals e is definitely assigned if the
state of v after expr_c ond is definitely assigned or “definitely assigned after false
expression”.
The definite-assignment state of v after expr is determined by:
If expr_c ond is a constant expression ( §12.23 ) with value true then the state of v
after expr is the same as the state of v after expr_tr ue.
Otherwise, if expr_c ond is a constant expression ( §12.23 ) with value false then
the state of v after expr is the same as the state of v after expr_fals e.
Otherwise, if the state of v after expr_tr ue is definitely assigned and the state of
v after expr_fals e is definitely assigned, then the state of v after expr is definitely
assigned.
Otherwise, the state of v after expr is not definitely assigned.
For a lambda_expr ession  or anon ymous_method_expr ession  expr with a body (either block
or expression ) body :
The definite assignment state of a parameter is the same as for a parameter of a
named method ( §9.2.6 , §9.2.7 , §9.2.8 ).
The definite assignment state of an outer variable v before body  is the same as the
state of v before expr. That is, definite assignment state of outer variables is
inherited from the context of the anonymous function.
The definite assignment state of an outer variable v after expr is the same as the
state of v before expr.
Example : The example
C#«expr_cond» ? «expr_true» : «expr_false»
9.4.4.31 Anonymous functionsgenerates a compile-time error since max is not definitely assigned where the
anonymous function is declared.
end ex ample
Example : The example
C#
also generates a compile-time error since the assignment to n in the anonymous
function has no affect on the definite-assignment state of n outside the anonymous
function.
end ex ample
For an expression expr of the form:
throw thrown_exprclass A
{
delegate  bool Filter(int i);
void F()
{
int max;
// Error, max is not definitely assigned
Filter f = ( int n) =&gt; n &lt; max;
max = 5;
DoWork(f);
}
void DoWork(Filter f ) { ... }
}
class A
{
delegate  void D();
void F()
{
int n;
D d = () =&gt; { n = 1; };
d();
// Error, n is not definitely assigned
Console.WriteLine(n);
}
}
9.4.4.32 Throw expressionsThe definite assignment state of v before thrown_expr  is the same as the state of v
before expr.
The definite assignment state of v after expr is “definitely assigned”.
Local functions are analyzed in the context of their parent method. There are two
control flow paths that matter for local functions: function calls and delegate
conversions.
Definite assignment for the body of each local function is defined separately for each
call site. At each invocation, variables captured by the local function are considered
definitely assigned if they were definitely assigned at the point of call. A control flow
path also exists to the local function body at this point and is considered reachable.
After a call to the local function, captured variables that were definitely assigned at
every control point leaving the function ( return statements, yield statements, await
expressions) are considered definitely assigned after the call location.
Delegate conversions have a control flow path to the local function body. Captured
variables are definitely assigned for the body if they are definitely assigned before the
conversion. V ariables assigned by the local function are not considered assigned after
the conversion.
Note: the above implies that bodies are re-analyzed for definite assignment at every
local function invocation or delegate conversion. Compilers are not required to re-
analyze the body of a local function at each invocation or delegate conversion. The
implementation must produce results equivalent to that description. end not e
Example : The following example demonstrates definite assignment for captured
variables in local functions. If a local function reads a captured variable before
writing it, the captured variable must be definitely assigned before calling the local
function. The local function F1 reads s without assigning it. It is an error if F1 is
called before s is definitely assigned. F2 assigns i before reading it. It may be
called before i is definitely assigned. Furthermore, F3 may be called after F2
because s2 is definitely assigned in F2.
C#9.4.4.33 Rules for variables in local functions
void M()
{
string s;
int i;
string s2;end ex ample
For an expression expr of the form:
expr_oper and is pattern
The definite-assignment state of v before expr_oper and is the same as the definite-
assignment state of v before expr.
If the variable ‘v’ is declared in pattern, then the definite-assignment state of ‘v’
after expr is “definitely assigned when true”.
Otherwise the definite assignment state of ‘v’ after expr is the same as the definite
assignment state of ‘v’ after expr_oper and.<br />
// Error: Use of unassigned local variable s:
F1();
// OK, F2 assigns i before reading it.
F2();</p>
<p>// OK, i is definitely assigned in the body of F2:
s = i.ToString();</p>
<p>// OK. s is now definitely assigned.
F1();
// OK, F3 reads s2, which is definitely assigned in F2.
F3();
void F1()
{
Console.WriteLine(s);
}</p>
<p>void F2()
{
i = 5;
// OK. i is definitely assigned.
Console.WriteLine(i);
s2 = i.ToString();
}
void F3()
{
Console.WriteLine(s2);
}
}
9.4.4.34 is-pattern expressionsA variable_r eference is an expression  that is classified as a variable. A variable_r eference
denotes a storage location that can be accessed both to fetch the current value and to
store a new value.
ANTLR
Note: In C and C++, a variable_r eference is known as an lvalue. end not e
Reads and writes of the following data types shall be atomic: bool, char, byte, sbyte,
short, ushort, uint, int, float, and reference types. In addition, reads and writes of
enum types with an underlying type in the previous list shall also be atomic. R eads and
writes of other types, including long, ulong, double, and decimal, as well as user-
defined types, need not be atomic. Aside from the library functions designed for that
purpose, there is no guarantee of atomic read-modify-write, such as in the case of
increment or decrement.
A reference variable  is a variable that refers to another variable, called the referent
(§9.2.6 ). A reference variable is a local variable declared with the ref modifier.
A reference variable stores a variable_r eference (§9.5) to its referent and not the value of
its referent. When a reference variable is used where a value is required its referent’s
value is returned; similarly when a reference variable is the target of an assignment it is
the referent which is assigned to. The variable to which a reference variable refers, i.e.
the stored variable_r eference for its referent, can be changed using a ref assignment ( =
ref).
Example:  The following example demonstrates a local reference variable whose
referent is an element of an array:9.5 Variable references
variable_reference
: expression
;
9.6 Atomicity of variable references
9.7 Reference variables and returns
9.7.1 GeneralC#
end ex ample
A reference return is the variable_r eference returned from a returns-by-ref method
(§15.6.1 ). This variable_r eference is the referent of the reference return.
Example:  The following example demonstrates a reference return whose referent is
an element of an array field:
C#
end ex ample
All reference variables obey safety rules that ensure the ref-safe-context of the reference
variable is not greater than the ref-safe-context of its referent.
Note: The related notion of a safe-c ontext is defined in ( §16.4.12 ), along with
associated constraints. end not epublic class C
{
public void M()
{
int[] arr = new int[10];
// element is a reference variable that refers to arr[5]
ref int element = ref arr[5];
element += 5; // arr[5] has been incremented by 5
}<br />
}
public class C
{
private int[] arr = new int[10];
public ref readonly  int M()
{
// element is a reference variable that refers to arr[5]
ref int element = ref arr[5];
return ref element; // return reference to arr[5];
}<br />
}
9.7.2 Ref safe contexts
9.7.2.1 GeneralFor any variable, the ref-safe-c ontext of that variable is the context where a
variable_r eference (§9.5) to that variable is valid. The referent of a reference variable shall
have a ref-safe-context that is at least as wide as the ref-safe-context of the reference
variable itself.
Note: The compiler determines the ref-safe-context through a static analysis of the
program text. The ref-safe-context reflects the lifetime of a variable at runtime. end
note
There are three ref-safe-contexts:
declar ation-block : The ref-safe-context of a variable_r eference to a local variable
(§9.2.9 ) is that local variable’s scope ( §13.6.2 ), including any nested embedded-
statement s in that scope.
A variable_r eference to a local variable is a valid referent for a reference variable
only if the reference variable is declared within the ref-safe-context of that variable.
function-member : Within a function a variable_r eference to any of the following
has a ref-safe-context of function-member:
Value parameters ( §9.2.5 ) on a function member declaration, including the
implicit this of class member functions; and
The implicit reference ( ref) parameter ( §9.2.6 ) this of a struct member
function, along with its fields.
A variable_r eference with ref-safe-context of function-member is a valid referent
only if the reference variable is declared in the same function member.
caller -context: Within a function a variable_r eference to any of the following has a
ref-safe-context of caller-context:
Reference ( ref) parameters ( §9.2.6 ) other than the implicit this of a struct
member function;
Member fields and elements of such parameters;
Member fields of parameters of class type; and
Elements of parameters of array type.
A variable_r eference with ref-safe-context of caller-context can be the referent of a
reference return.
These values form a nesting relationship from narrowest (declaration-block) to widest
(caller-context). Each nested block represents a different context.Example : The following code shows examples of the different ref-safe-contexts. The
declarations show the ref-safe-context for a referent to be the initializing expression
for a ref variable. The examples show the ref-safe-context for a reference return:
C#
end ex ample.public class C
{
// ref safe context of arr is &quot;caller-context&quot;. 
// ref safe context of arr[i] is &quot;caller-context&quot;.
private int[] arr = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; 
// ref safe context is &quot;caller-context&quot;
public ref int M1(ref int r1)
{
return ref r1; // r1 is safe to ref return
}
// ref safe context is &quot;function-member&quot;
public ref int M2(int v1)
{
return ref v1; // error: v1 isn't safe to ref return
}
public ref int M3()
{
int v2 = 5;
return ref arr[v2]; // arr[v2] is safe to ref return
}
public void M4(int p) 
{
int v3 = 6;
// context of r2 is declaration-block,
// ref safe context of p is function-member
ref int r2 = ref p;
// context of r3 is declaration-block,
// ref safe context of v3 is declaration-block
ref int r3 = ref v3;
// context of r4 is declaration-block,
// ref safe context of arr[v3] is caller-context
ref int r4 = ref arr[v3]; 
}
}Example : For struct types, the implicit this parameter is passed as a ref
parameter. The ref-safe-context of the fields of a struct type as function-member
prevents returning those fields by reference return. This rule prevents the following
code:
C#
end ex ample.
For a local variable v:
If v is a reference variable, its ref-safe-context is the same as the ref-safe-context
of its initializing expression.
Otherwise its ref-safe-context is declaration-block.
For a formal parameter p:
If p is a ref, or in parameter, its ref-safe-context is the caller-context. If p is an
in parameter, it can’t be returned as a writable ref but can be returned as ref
readonly.
If p is an out parameter, its ref-safe-context is the caller-context.public struct S
{
private int n;
// Disallowed: returning ref of a field.
public ref int GetN() =&gt; ref n;
}
class Test
{
public ref int M()
{
S s = new S();
ref int numRef = ref s.GetN();
return ref numRef; // reference to local variable 'numRef'<br />
returned
}
}
9.7.2.2 Local variable ref safe context
9.7.2.3 Parameter ref safe contextOtherwise, if p is the this parameter of a struct type, its ref-safe-context is the
function-member.
Otherwise, the parameter is a value parameter, and its ref-safe-context is the
function-member.
For a variable designating a reference to a field, e.F:
If e is of a reference type, its ref-safe-context is the caller-context.
Otherwise, if e is of a value type, its ref-safe-context is the same as the ref-safe-
context of e.
The conditional operator ( §12.18 ), c ? ref e1 : ref e2, and reference assignment
operator, = ref e (§12.21.1 ) have reference variables as operands and yield a reference
variable. For those operators, the ref-safe-context of the result is the narrowest context
among the ref-safe-contexts of all ref operands.
For a variable c resulting from a ref-returning function invocation, its ref-safe-context is
the narrowest of the following contexts:
The caller-context.
The ref-safe-context of all ref, out, and in argument expressions (excluding the
receiver).
For each in parameter, if there is a corresponding expression that is a variable and
there exists an identity conversion between the type of the variable and the type of
the parameter, the variable’s ref-safe-context, otherwise the nearest enclosing
context.
The safe-context ( §16.4.12 ) of all argument expressions (including the receiver).
Example : the last bullet is necessary to handle code such as
C#9.7.2.4 Field ref safe context
9.7.2.5 Operators
9.7.2.6 Function invocation
ref int M2()
{
int v = 5;
// Not valid.end ex ample
A property invocation and an indexer invocation (either get or set) is treated as a
function invocation of the underlying accessor by the above rules. A local function
invocation is a function invocation.
A value’s ref-safe-context is the nearest enclosing context.
Note: This occurs in an invocation such as M(ref d.Length) where d is of type
dynamic. It is also consistent with arguments corresponding to in parameters. end
note
A new expression that invokes a constructor obeys the same rules as a method
invocation ( §9.7.2.6 ) that is considered to return the type being constructed.
Neither a reference parameter, nor an output parameter, nor an input parameter,
nor a ref local, nor a parameter or local of a ref struct type shall be captured by
lambda expression or local function.
Neither a reference parameter, nor an output parameter, nor an input parameter,
nor a parameter of a ref struct type shall be an argument for an iterator method
or an async method.
Neither a ref local, nor a local of a ref struct type shall be in context at the
point of a yield return statement or an await expression.
For a ref reassignment e1 = ref e2, the ref-safe-context of e2 shall be at least as
wide a context as the ref-safe-c ontext of e1.    // ref safe context of &quot;v&quot; is block.
// Therefore, ref safe context of the return value of M() is block.
return ref M(ref v);
}
ref int M(ref int p)
{
return ref p;
}
9.7.2.7 Values
9.7.2.8 Constructor invocations
9.7.2.9 Limitations on reference variablesFor a ref return statement return ref e1, the ref-safe-context of e1 shall be the
caller-context.
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide .C# Standar d documentation
feedb ack
C# Standard documentation is an
open source project. Select a link to
provide feedback:
 Open a documentation issue
 Provide product feedback10 Conversions
Article •03/09/2023
A conversion causes an expression to be converted to, or treated as being of, a
particular type; in the former case a conversion may involve a change in representation.
Conversions can be implicit  or explicit , and this determines whether an explicit cast is
required.
Example : For instance, the conversion from type int to type long is implicit, so
expressions of type int can implicitly be treated as type long. The opposite
conversion, from type long to type int, is explicit and so an explicit cast is required.
C#
end ex ample
Some conversions are defined by the language. Programs may also define their own
conversions ( §10.5 ).
Some conversions in the language are defined from expressions to types, others from
types to types. A conversion from a type applies to all expressions that have that type.
Example :
C#10.1 General
int a = 123;
long b = a;      // implicit conversion from int to long
int c = (int) b; // explicit conversion from long to int
enum Color { Red, Blue, Green }
// The expression 0 converts implicitly to enum types
Color c0 = 0;
// Other int expressions need explicit conversion
Color c1 = (Color) 1;
// Conversion from null expression (no type) to string
string x = null;end ex ample
The following conversions are classified as implicit conversions:
Identity conversions
Implicit numeric conversions
Implicit enumeration conversions
Implicit interpolated string conversions
Implicit reference conversions
Boxing conversions
Implicit dynamic conversions
Implicit type parameter conversions
Implicit constant expression conversions
User-defined implicit conversions
Anonymous function conversions
Method group conversions
Null literal conversions
Implicit nullable conversions
Implicit tuple conversions
Lifted user-defined implicit conversions
Default literal conversions
Implicit throw conversion
Implicit conversions can occur in a variety of situations, including function member
invocations ( §12.6.6 ), cast expressions ( §12.9.7 ), and assignments ( §12.21 ).
The pre-defined implicit conversions always succeed and never cause exceptions to be
thrown.
Note: Properly designed user-defined implicit conversions should exhibit these
characteristics as well. end not e
For the purposes of conversion, the types object and dynamic are considered
equivalent.// Conversion from lambda expression to delegate type
Func&lt;int, int&gt; square = x =&gt; x * x;
10.2 Implicit conversions
10.2.1 GeneralHowever, dynamic conversions ( §10.2.10  and §10.3.8 ) apply only to expressions of type
dynamic (§8.2.4 ).
An identity conversion converts from any type to the same type. One reason this
conversion exists is so that a type T or an expression of type T can be said to be
convertible to T itself.
In some cases there is an identity conversion between types that are not exactly the
same, but are considered equivalent. Such identity conversions exist:
between object and dynamic.
between tuple types with the same arity, when an identity conversion exists
between each pair of corresponding element types.
between types constructed from the same generic type where there exists an
identity conversion between each corresponding type argument.
In most cases, an identity conversion has no effect at runtime. However, since floating
point operations may be performed at higher precision than prescribed by their type
(§8.3.7 ), assignment of their results may result in a loss of precision, and explicit casts are
guaranteed to reduce precision to what is prescribed by the type ( §12.9.7 ).
The implicit numeric conversions are:
From sbyte to short, int, long, float, double, or decimal.
From byte to short, ushort, int, uint, long, ulong, float, double, or decimal.
From short to int, long, float, double, or decimal.
From ushort to int, uint, long, ulong, float, double, or decimal.
From int to long, float, double, or decimal.
From uint to long, ulong, float, double, or decimal.
From long to float, double, or decimal.
From ulong to float, double, or decimal.
From char to ushort, int, uint, long, ulong, float, double, or decimal.
From float to double.
Conversions from int, uint, long or ulong to float and from long or ulong to
double may cause a loss of precision, but will never cause a loss of magnitude. The
other implicit numeric conversions never lose any information.10.2.2 Identity conversion
10.2.3 Implicit numeric conversionsThere are no predefined implicit conversions to the char type, so values of the other
integral types do not automatically convert to the char type.
An implicit enumeration conversion permits a constant_expr ession  (§12.23 ) with any
integer type and the value zero to be converted to any enum_type  and to any
nullable_v alue_type  whose underlying type is an enum_type . In the latter case the
conversion is evaluated by converting to the underlying enum_type  and wrapping the
result ( §8.3.12 ).
An implicit interpolated string conversion permits an interpolat ed_str ing_expr ession
(§12.8.3 ) to be converted to System.IFormattable or System.FormattableString (which
implements System.IFormattable). When this conversion is applied, a string value is not
composed from the interpolated string. Instead an instance of
System.FormattableString is created, as further described in §12.8.3 .
The implicit nullable conversions are those nullable conversions ( §10.6.1 ) derived from
implicit predefined conversions.
An implicit conversion exists from the null literal to any reference type or nullable value
type. This conversion produces a null reference if the target type is a reference type, or
the null value ( §8.3.12 ) of the given nullable value type.
The implicit reference conversions are:
From any reference_type  to object and dynamic.
From any class_type  S to any class_type  T, provided S is derived from  T.
From any class_type  S to any interface_type  T, provided S implements  T.
From any interface_type  S to any interface_type  T, provided S is derived from  T.
From an array_type  S with an element type  Sᵢ to an array_type  T with an element
type Tᵢ, provided all of the following are true:10.2.4 Implicit enumeration conversions
10.2.5 Implicit interpolated string conversions
10.2.6 Implicit nullable conversions
10.2.7 Null literal conversions
10.2.8 Implicit reference conversionsS and T differ only in element type. In other words, S and T have the same
number of dimensions.
An implicit reference conversion exists from  Sᵢ to Tᵢ.
From a single-dimensional array type S[] to
System.Collections.Generic.IList<T>,
System.Collections.Generic.IReadOnlyList<T>, and their base interfaces, provided
that there is an implicit identity or reference conversion from  S to T.
From any array_type  to System.Array and the interfaces it implements.
From any delegat e_type  to System.Delegate and the interfaces it implements.
From the null literal ( §6.4.5.7 ) to any reference-type.
From any reference_type  to a reference_type  T if it has an implicit identity or
reference conversion to a reference_type  T₀ and T₀ has an identity conversion
to T.
From any reference_type  to an interface or delegate type  T if it has an implicit
identity or reference conversion to an interface or delegate type  T₀ and T₀ is
variance-convertible ( §18.2.3.3 ) to T.
Implicit conversions involving type parameters that are known to be reference
types. See §10.2.12  for more details on implicit conversions involving type
parameters.
The implicit reference conversions are those conversions between reference_type s that
can be proven to always succeed, and therefore require no checks at run-time.
Reference conversions, implicit or explicit, never change the referential identity of the
object being converted.
Note: In other words, while a reference conversion can change the type of the
reference, it never changes the type or value of the object being referred to. end
note
A boxing conversion permits a value_type  to be implicitly converted to a reference_type .
The following boxing conversions exist:
From any value_type  to the type object.
From any value_type  to the type System.ValueType.
From any enum_type  to the type System.Enum.
From any non_nullable_v alue_type  to any interface_type  implemented by the
non_nullable_v alue_type .10.2.9 Boxing conversionsFrom any non_nullable_v alue_type  to any interface_type  I such that there is a
boxing conversion from the non_nullable_v alue_type  to another interface_type  I₀,
and I₀ has an identity conversion to  I.
From any non_nullable_v alue_type  to any interface_type  I such that there is a
boxing conversion from the non_nullable_v alue_type  to another interface_type  I₀,
and I₀ is variance-convertible ( §18.2.3.3 ) to I.
From any nullable_v alue_type  to any reference_type  where there is a boxing
conversion from the underlying type of the nullable_v alue_type  to the
reference_type.
From a type parameter that is not known to be a reference type to any type such
that the conversion is permitted by §10.2.12 .
Boxing a value of a non-nullable-v alue-type  consists of allocating an object instance and
copying the value into that instance.
Boxing a value of a nullable_v alue_type  produces a null reference if it is the null value
(HasValue is false), or the result of unwrapping and boxing the underlying value
otherwise.
Note: The process of boxing may be imagined in terms of the existence of a boxing
class for every value type. For example, consider a struct S implementing an
interface I, with a boxing class called S_Boxing.
C#
interface  I
{
void M();
}
struct S : I
{
public void M() { ... }
}
sealed class S_Boxing  : I
{
S value;
public S_Boxing (S value)
{
this.value = value;
}
public void M()
{
value.M();Boxing a value v of type S now consists of executing the expression new
S_Boxing(v) and returning the resulting instance as a value of the target type of the
conversion. Thus, the statements
C#
can be thought of as similar to:
C#
The imagined boxing type described above does not actually exist. Instead, a boxed
value of type  S has the runtime type  S, and a runtime type check using the is
operator with a value type as the right operand tests whether the left operand is a
boxed version of the right operand. For example,
C#
will output the following:
Console
A boxing conversion implies making a copy of the value being boxed. This is
different from a conversion of a reference_type  to type object, in which the value
continues to reference the same instance and simply is regarded as the less derived
type object. For example, the following    }
}
S s = new S();
object box = s;
S s = new S();
object box = new S_Boxing(s);
int i = 123;
object box = i;
if (box is int)
{
Console.Write( &quot;Box contains an int&quot; );
}
Box contains an intC#
will output the value 10 on the console because the implicit boxing operation that
occurs in the assignment of p to box causes the value of p to be copied. Had
Point been declared a class instead, the value 20 would be output because p and
box would reference the same instance.
The analogy of a boxing class should not be used as more than a helpful tool for
picturing how boxing works conceptually. There are numerous subtle differences
between the behavior described by this specification and the behavior that would
result from boxing being implemented in precisely this manner.
end not e
An implicit dynamic conversion exists from an expression of type dynamic to any
type T. The conversion is dynamically bound §12.3.3 , which means that an implicit
conversion will be sought at run-time from the run-time type of the expression to  T. If
no conversion is found, a run-time exception is thrown.
This implicit conversion seemingly violates the advice in the beginning of §10.2  that an
implicit conversion should never cause an exception. However, it is not the conversion
itself, but the finding  of the conversion that causes the exception. The risk of run-timestruct Point
{
public int x, y;
public Point(int x, int y)
{
this.x = x;
this.y = y;
}
}
class A
{
void M() 
{
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
}
}
10.2.10 Implicit dynamic conversionsexceptions is inherent in the use of dynamic binding. If dynamic binding of the
conversion is not desired, the expression can be first converted to object, and then to
the desired type.
Example : The following illustrates implicit dynamic conversions:
C#
The assignments to  s2 and i both employ implicit dynamic conversions, where the
binding of the operations is suspended until run-time. At run-time, implicit
conversions are sought from the run-time type of  d(string) to the target type. A
conversion is found to string but not to int.
end ex ample
An implicit constant expression conversion permits the following conversions:
A constant_expr ession  (§12.23 ) of type int can be converted to type sbyte, byte,
short, ushort, uint, or ulong, provided the value of the constant_expr ession  is
within the range of the destination type.
A constant_expr ession  of type long can be converted to type ulong, provided the
value of the constant_expr ession  is not negative.
For a type_p aramet er T that is known to be a reference type ( §15.2.5 ), the following
implicit reference conversions ( §10.2.8 ) exist:
From T to its effective base class C, from T to any base class of C, and from T to
any interface implemented by C.
From T to an interface_type  I in T’s effective interface set and from T to any base
interface of I.
From T to a type parameter U provided that T depends on U (§15.2.5 ).object o = &quot;object&quot; ;
dynamic d = &quot;dynamic&quot; ;
string s1 = o;         // Fails at compile-time – no conversion exists
string s2 = d;         // Compiles and succeeds at run-time
int i = d;             // Compiles but fails at run-time – no conversion<br />
exists
10.2.11 Implicit constant expression conversions
10.2.12 Implicit conversions involving type parametersNote: Since T is known to be a reference type, within the scope of T, the run-
time type of U will always be a reference type, even if U is not known to be a
reference type at compile-time. end not e
From the null literal ( §6.4.5.7 ) to T.
For a type_p aramet er T that is not known to be a reference type §15.2.5 , the following
conversions involving T are considered to be boxing conversions ( §10.2.9 ) at compile-
time. At run-time, if T is a value type, the conversion is executed as a boxing conversion.
At run-time, if T is a reference type, the conversion is executed as an implicit reference
conversion or identity conversion.
From T to its effective base class C, from T to any base class of C, and from T to
any interface implemented by C.
Note: C will be one of the types System.Object, System.ValueType, or
System.Enum (otherwise T would be known to be a reference type). end not e
From T to an interface_type  I in T’s effective interface set and from T to any base
interface of I.
For a type_p aramet er T that is not known to be a reference type, there is an implicit
conversion from T to a type parameter U provided T depends on U. At run-time, if T is
a value type and U is a reference type, the conversion is executed as a boxing
conversion. At run-time, if both T and U are value types, then T and U are necessarily
the same type and no conversion is performed. At run-time, if T is a reference type,
then U is necessarily also a reference type and the conversion is executed as an implicit
reference conversion or identity conversion ( §15.2.5 ).
The following further implicit conversions exist for a given type parameter  T:
From T to a reference type  S if it has an implicit conversion to a reference type  S₀
and S₀ has an identity conversion to  S. At run-time, the conversion is executed
the same way as the conversion to  S₀.
From T to an interface type  I if it has an implicit conversion to an interface
type I₀, and I₀ is variance-convertible to  I (§18.2.3.3 ). At run-time, if  T is a value
type, the conversion is executed as a boxing conversion. Otherwise, the conversion
is executed as an implicit reference conversion or identity conversion.
In all cases, the rules ensure that a conversion is executed as a boxing conversion if and
only if at run-time the conversion is from a value type to a reference type.An implicit conversion exists from a tuple expression E to a tuple type T if E has the
same arity as T and an implicit conversion exists from each element in E to the
corresponding element type in T. The conversion is performed by creating an instance
of T’s corresponding System.ValueTuple&lt;...&gt; type, and initializing each of its fields in
order from left to right by evaluating the corresponding tuple element expression of E,
converting it to the corresponding element type of T using the implicit conversion
found, and initializing the field with the result.
If an element name in the tuple expression does not match a corresponding element
name in the tuple type, a warning shall be issued.
Example :
C#
The declarations of t1, t2, t4 and t5 are all valid, since implicit conversions exist
from the element expressions to the corresponding element types. The declaration
of t3 is invalid, because there is no conversion from null to int. The declaration of
t5 causes a warning because the element names in the tuple expression differs
from those in the tuple type.
end ex ample
A user-defined implicit conversion consists of an optional standard implicit conversion,
followed by execution of a user-defined implicit conversion operator, followed by
another optional standard implicit conversion. The exact rules for evaluating user-
defined implicit conversions are described in §10.5.4 .10.2.13 Implicit tuple conversions
(int, string) t1 = ( 1, &quot;One&quot;);
(byte, string) t2 = ( 2, null);
(int, string) t3 = ( null, null);        // Error: No conversion
(int i, string s) t4 = (i: 4, &quot;Four&quot;);
(int i, string) t5 = (x: 5, s: &quot;Five&quot;); // Warning: Names are ignored
10.2.14 User-defined implicit conversions
10.2.15 Anonymous function conversions and method
group conversionsAnonymous functions and method groups do not have types in and of themselves, but
they may be implicitly converted to delegate types. Additionally, some lambda
expressions may be implicitly converted to expression tree types. Anonymous function
conversions are described in more detail in §10.7  and method group conversions
in §10.8 .
An implicit conversion exists from a default_lit eral (§12.8.20 ) to any type. This conversion
produces the default value ( §9.3) of the inferred type.
While throw expressions do not have a type, they may be implicitly converted to any
type.
The following conversions are classified as explicit conversions:
All implicit conversions
Explicit numeric conversions
Explicit enumeration conversions
Explicit nullable conversions
Explicit tuple conversions
Explicit reference conversions
Explicit interface conversions
Unboxing conversions
Explicit type parameter conversions
Explicit dynamic conversions
User-defined explicit conversions
Explicit conversions can occur in cast expressions ( §12.9.7 ).
The set of explicit conversions includes all implicit conversions.
Note: This, for example, allows an explicit cast to be used when an implicit
conversion to the same type exists, in order to force the selection of a particular
method overload. end not e10.2.16 Default literal conversions
10.2.17 Implicit throw conversions
10.3 Explicit conversions
10.3.1 GeneralThe explicit conversions that are not implicit conversions are conversions that cannot be
proven always to succeed, conversions that are known possibly to lose information, and
conversions across domains of types sufficiently different to merit explicit notation.
The explicit numeric conversions are the conversions from a numer ic_type  to another
numer ic_type  for which an implicit numeric conversion ( §10.2.3 ) does not already exist:
From sbyte to byte, ushort, uint, ulong, or char.
From byte to sbyte or char.
From short to sbyte, byte, ushort, uint, ulong, or char.
From ushort to sbyte, byte, short, or char.
From int to sbyte, byte, short, ushort, uint, ulong, or char.
From uint to sbyte, byte, short, ushort, int, or char.
From long to sbyte, byte, short, ushort, int, uint, ulong, or char.
From ulong to sbyte, byte, short, ushort, int, uint, long, or char.
From char to sbyte, byte, or short.
From float to sbyte, byte, short, ushort, int, uint, long, ulong, char, or
decimal.
From double to sbyte, byte, short, ushort, int, uint, long, ulong, char, float,
or decimal.
From decimal to sbyte, byte, short, ushort, int, uint, long, ulong, char,
float, or double.
Because the explicit conversions include all implicit and explicit numeric conversions, it is
always possible to convert from any numer ic_type  to any other numer ic_type  using a cast
expression ( §12.9.7 ).
The explicit numeric conversions possibly lose information or possibly cause exceptions
to be thrown. An explicit numeric conversion is processed as follows:
For a conversion from an integral type to another integral type, the processing
depends on the overflow checking context ( §12.8.19 ) in which the conversion takes
place:
In a checked context, the conversion succeeds if the value of the source
operand is within the range of the destination type, but throws a
System.OverflowException if the value of the source operand is outside the
range of the destination type.10.3.2 Explicit numeric conversionsIn an unchecked context, the conversion always succeeds, and proceeds as
follows.
If the source type is larger than the destination type, then the source value is
truncated by discarding its “extra” most significant bits. The result is then
treated as a value of the destination type.
If the source type is the same size as the destination type, then the source
value is treated as a value of the destination type
For a conversion from decimal to an integral type, the source value is rounded
towards zero to the nearest integral value, and this integral value becomes the
result of the conversion. If the resulting integral value is outside the range of the
destination type, a System.OverflowException is thrown.
For a conversion from float or double to an integral type, the processing depends
on the overflow-checking context ( §12.8.19 ) in which the conversion takes place:
In a checked context, the conversion proceeds as follows:
If the value of the operand is NaN or infinite, a System.OverflowException is
thrown.
Otherwise, the source operand is rounded towards zero to the nearest
integral value. If this integral value is within the range of the destination type
then this value is the result of the conversion.
Otherwise, a System.OverflowException is thrown.
In an unchecked context, the conversion always succeeds, and proceeds as
follows.
If the value of the operand is NaN or infinite, the result of the conversion is
an unspecified value of the destination type.
Otherwise, the source operand is rounded towards zero to the nearest
integral value. If this integral value is within the range of the destination type
then this value is the result of the conversion.
Otherwise, the result of the conversion is an unspecified value of the
destination type.
For a conversion from double to float, the double value is rounded to the nearest
float value. If the double value is too small to represent as a float, the result
becomes zero with the same sign as the value. If the magnitude of the double
value is too large to represent as a float, the result becomes infinity with the
same sign as the value. If the double value is NaN, the result is also NaN.
For a conversion from float or double to decimal, the source value is converted
to decimal representation and rounded to the nearest number if required ( §8.3.8 ).
If the source value is too small to represent as a decimal, the result becomes
zero, preserving the sign of the original value if decimal supports signed zero
values.If the source value’s magnitude is too large to represent as a decimal, or that
value is infinity, the result is infinity preserving the sign of the original value, if
the decimal representation supports infinities; otherwise a
System.OverflowException is thrown.
If the source value is NaN, the result is NaN if the decimal representation
supports NaNs; otherwise a S ystem.OverflowException is thrown.
For a conversion from decimal to float or double, the decimal value is rounded
to the nearest double or float value. If the source value’s magnitude is too large
to represent in the target type, or that value is infinity, the result is infinity
preserving the sign of the original value. If the source value is NaN, the result is
NaN. While this conversion may lose precision, it never causes an exception to be
thrown.
Note: The decimal type is not required to support infinities or NaN values but may
do so; its range may be smaller than the range of float and double, but is not
guaranteed to be. For decimal representations without infinities or NaN values, and
with a range smaller than float, the result of a conversion from decimal to either
float or double will never be infinity or NaN. end not e
The explicit enumeration conversions are:
From sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, or
decimal to any enum_type .
From any enum_type  to sbyte, byte, short, ushort, int, uint, long, ulong, char,
float, double, or decimal.
From any enum_type  to any other enum_type .
An explicit enumeration conversion between two types is processed by treating any
participating enum_type  as the underlying type of that enum_type , and then performing
an implicit or explicit numeric conversion between the resulting types.
Example : Given an enum_type  E with and underlying type of int, a conversion from
E to byte is processed as an explicit numeric conversion ( §10.3.2 ) from int to byte,
and a conversion from byte to E is processed as an implicit numeric conversion
(§10.2.3 ) from byte to int. end ex ample10.3.3 Explicit enumeration conversions
10.3.4 Explicit nullable conversionsThe explicit nullable conversions are those nullable conversions ( §10.6.1 ) derived from
explicit and implicit predefined conversions.
The explicit reference conversions are:
From object and dynamic to any other reference_type .
From any class_type  S to any class_type  T, provided S is a base class of  T.
From any class_type  S to any interface_type  T, provided S is not sealed and
provided S does not implement  T.
From any interface_type  S to any class_type  T, provided T is not sealed or
provided T implements  S.
From any interface_type  S to any interface_type  T, provided S is not derived
from T.
From an array_type  S with an element type  Sᵢ to an array_type  T with an element
type Tᵢ, provided all of the following are true:
S and T differ only in element type. In other words, S and T have the same
number of dimensions.
An explicit reference conversion exists from  Sᵢ to Tᵢ.
From System.Array and the interfaces it implements, to any array_type .
From a single-dimensional array_type  S[] to
System.Collections.Generic.IList<T>,
System.Collections.Generic.IReadOnlyList<T>, and its base interfaces, provided
that there is an identity conversion or explicit reference conversion from  S to T.
From System.Collections.Generic.IList<S>,
System.Collections.Generic.IReadOnlyList<S>, and their base interfaces to a
single-dimensional array type T[], provided that there is an identity conversion or
explicit reference conversion from  S to T.
From System.Delegate and the interfaces it implements to any delegat e_type .
From a reference type  S to a reference type  T if it has an explicit reference
conversion from  S to a reference type T₀ and T₀ and there is an identity
conversion from  T₀ to T.
From a reference type  S to an interface or delegate type  T if it there is an explicit
reference conversion from  S to an interface or delegate type  T₀ and either  T₀ is
variance-convertible to  T or T is variance-convertible to  T₀ §18.2.3.3 .
From D&lt;S₁...Sᵥ&gt; to D&lt;T₁...Tᵥ&gt; where D&lt;X₁...Xᵥ&gt; is a generic delegate type,
D&lt;S₁...Sᵥ&gt; is not compatible with or identical to D&lt;T₁...Tᵥ&gt;, and for each type10.3.5 Explicit reference conversionsparameter  Xᵢ of D the following holds:
If Xᵢ is invariant, then  Sᵢ is identical to  Tᵢ.
If Xᵢ is covariant, then there is an identity conversion, implicit reference
conversion or explicit reference conversion from  Sᵢ to Tᵢ.
If Xᵢ is contravariant, then  Sᵢ and Tᵢ are either identical or both reference
types.
Explicit conversions involving type parameters that are known to be reference
types. For more details on explicit conversions involving type parameters, see
§10.3.9 .
The explicit reference conversions are those conversions between reference_type s that
require run-time checks to ensure they are correct.
For an explicit reference conversion to succeed at run-time, the value of the source
operand shall be null, or the type of the object referenced by the source operand shall
be a type that can be converted to the destination type by an implicit reference
conversion ( §10.2.8 ). If an explicit reference conversion fails, a
System.InvalidCastException is thrown.
Note: Reference conversions, implicit or explicit, never change the value of the
reference itself ( §8.2.1 ), only its type; neither does it change the type or value of the
object being referenced. end not e
An explicit conversion exists from a tuple expression E to a tuple type T if E has the
same arity as T and an implicit or explicit conversion exists from each element in E to
the corresponding element type in T. The conversion is performed by creating an
instance of T’s corresponding System.ValueTuple&lt;...&gt; type, and initializing each of its
fields in order from left to right by evaluating the corresponding tuple element
expression of E, converting it to the corresponding element type of T using the explicit
conversion found, and initializing the field with the result.
An unboxing conversion permits a reference_type  to be explicitly converted to a
value_type . The following unboxing conversions exist:
From the type object to any value_type .
From the type System.ValueType to any value_type .10.3.6 Explicit tuple conversions
10.3.7 Unboxing conversionsFrom the type System.Enum to any enum_type .
From any interface_type  to any non-nullable_v alue_type  that implements the
interface_type .
From any interface_type  I to any non_nullable_v alue_type  where there is an
unboxing conversion from an interface_type  I₀ to the non_nullable_v alue-type  and
an identity conversion from I to I₀.
From any interface_type  I to any non_nullable_v alue_type  where there is an
unboxing conversion from an interface_type  I₀ to the non_nullable_v alue_type  and
either either  I₀ is variance_convertible to  I or I is variance-convertible to  I₀
(§18.2.3.3 ).
From any reference_type  to any nullable_v alue_type  where there is an unboxing
conversion from reference_type  to the underlying non_nullable_v alue_type  of the
nullable_v alue_type .
From a type parameter which is not known to be a value type to any type such that
the conversion is permitted by §10.3.9 .
An unboxing operation to a non_nullable_v alue_type  consists of first checking that the
object instance is a boxed value of the given non_nullable_v alue_type , and then copying
the value out of the instance.
Unboxing to a nullable_v alue_type  produces the null value of the nullable_v alue_type  if
the source operand is null, or the wrapped result of unboxing the object instance to
the underlying type of the nullable_v alue_type  otherwise.
Note: Referring to the imaginary boxing class described in §10.2.9 , an unboxing
conversion of an object box to a value_type  S consists of executing the expression
((S_Boxing)box).value. Thus, the statements
C#
conceptually correspond to
C#
end not eobject box = new S();
S s = (S)box;
object box = new S_Boxing( new S());
S s = ((S_Boxing)box). value;For an unboxing conversion to a given non_nullable_v alue_type  to succeed at run-time,
the value of the source operand shall be a reference to a boxed value of that
non_nullable_v alue_type . If the source operand is null a System.NullReferenceException
is thrown. If the source operand is a reference to an incompatible object, a
System.InvalidCastException is thrown.
For an unboxing conversion to a given nullable_v alue_type  to succeed at run-time, the
value of the source operand shall be either null or a reference to a boxed value of the
underlying non_nullable_v alue_type  of the nullable_v alue_type . If the source operand is a
reference to an incompatible object, a System.InvalidCastException is thrown.
An explicit dynamic conversion exists from an expression of type dynamic to any type  T.
The conversion is dynamically bound ( §12.3.3 ), which means that an explicit conversion
will be sought at run-time from the run-time type of the expression to  T. If no
conversion is found, a run-time exception is thrown.
If dynamic binding of the conversion is not desired, the expression can be first
converted to object, and then to the desired type.
Example : Assume the following class is defined:
C#
The following illustrates explicit dynamic conversions:
C#10.3.8 Explicit dynamic conversions
class C
{
int i;
public C(int i)
{
this.i = i;
}
public static explicit  operator  C(string s)
{
return new C(int.Parse(s));
}
}
object o = &quot;1&quot;;
dynamic d = &quot;2&quot;;The best conversion of  o to C is found at compile-time to be an explicit reference
conversion. This fails at run-time, because  &quot;1&quot; is not in fact a  C. The conversion
of d to C however, as an explicit dynamic conversion, is suspended to run-time,
where a user defined conversion from the run-time type of  d (string) to C is
found, and succeeds.
end ex ample
For a type_p aramet er T that is known to be a reference type ( §15.2.5 ), the following
explicit reference conversions ( §10.3.5 ) exist:
From the effective base class C of T to T and from any base class of C to T.
From any interface_type  to T.
From T to any interface_type  I provided there isn’t already an implicit reference
conversion from T to I.
From a type_p aramet er U to T provided that T depends on U (§15.2.5 ).
Note: Since T is known to be a reference type, within the scope of T, the run-
time type of U will always be a reference type, even if U is not known to be a
reference type at compile-time. end not e
For a type_p aramet er T that is not known to be a reference type ( §15.2.5 ), the following
conversions involving T are considered to be unboxing conversions ( §10.3.7 ) at
compile-time. At run-time, if T is a value type, the conversion is executed as an
unboxing conversion. At run-time, if T is a reference type, the conversion is executed as
an explicit reference conversion or identity conversion.
From the effective base class C of T to T and from any base class of C to T.
Note: C will be one of the types System.Object, System.ValueType, or
System.Enum (otherwise T would be known to be a reference type). end not e
From any interface_type  to T.var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
10.3.9 Explicit conversions involving type parametersFor a type_p aramet er T that is not known to be a reference type ( §15.2.5 ), the following
explicit conversions exist:
From T to any interface_type  I provided there is not already an implicit
conversion from T to I. This conversion consists of an implicit boxing conversion
(§10.2.9 ) from T to object followed by an explicit reference conversion from
object to I. At run-time, if T is a value type, the conversion is executed as a
boxing conversion followed by an explicit reference conversion. At run-time, if T is
a reference type, the conversion is executed as an explicit reference conversion.
From a type parameter U to T provided that T depends on U (§15.2.5 ). At run-
time, if T is a value type and U is a reference type, the conversion is executed as
an unboxing conversion. At run-time, if both T and U are value types, then T and
U are necessarily the same type and no conversion is performed. At run-time, if T
is a reference type, then U is necessarily also a reference type and the conversion
is executed as an explicit reference conversion or identity conversion.
In all cases, the rules ensure that a conversion is executed as an unboxing conversion if
and only if at run-time the conversion is from a reference type to a value type.
The above rules do not permit a direct explicit conversion from an unconstrained type
parameter to a non-interface type, which might be surprising. The reason for this rule is
to prevent confusion and make the semantics of such conversions clear.
Example : Consider the following declaration:
C#
If the direct explicit conversion of  t to long were permitted, one might easily
expect that X<int>.F(7) would return  7L. However, it would not, because the
standard numeric conversions are only considered when the types are known to be
numeric at binding-time. In order to make the semantics clear, the above example
must instead be written:
C#class X<T>
{
public static long F(T t)
{
return (long)t;         // Error
}
}This code will now compile but executing X<int>.F(7) would then throw an
exception at run-time, since a boxed int cannot be converted directly to a long.
end ex ample
A user-defined explicit conversion consists of an optional standard explicit conversion,
followed by execution of a user-defined implicit or explicit conversion operator,
followed by another optional standard explicit conversion. The exact rules for evaluating
user-defined explicit conversions are described in §10.5.5 .
The standard conversions are those pre-defined conversions that can occur as part of a
user-defined conversion.
The following implicit conversions are classified as standard implicit conversions:
Identity conversions ( §10.2.2 )
Implicit numeric conversions ( §10.2.3 )
Implicit nullable conversions ( §10.2.6 )
Null literal conversions ( §10.2.7 )
Implicit reference conversions ( §10.2.8 )
Boxing conversions ( §10.2.9 )
Implicit constant expression conversions ( §10.2.11 )
Implicit conversions involving type parameters ( §10.2.12 )class X<T>
{
public static long F(T t)
{
return (long)(object)t;         // Ok, but will only work when T<br />
is long
}
}
10.3.10 User-defined explicit conversions
10.4 Standard conversions
10.4.1 General
10.4.2 Standard implicit conversionsThe standard implicit conversions specifically exclude user-defined implicit conversions.
The standard explicit conversions are all standard implicit conversions plus the subset of
the explicit conversions for which an opposite standard implicit conversion exists.
Note: In other words, if a standard implicit conversion exists from a type  A to a
type B, then a standard explicit conversion exists from type  A to type  B and from
type B to type  A. end not e
C# allows the pre-defined implicit and explicit conversions to be augmented by user-
defined conversions. User-defined conversions are introduced by declaring conversion
operators ( §15.10.4 ) in class and struct types.
C# permits only certain user-defined conversions to be declared. In particular, it is not
possible to redefine an already existing implicit or explicit conversion.
For a given source type  S and target type  T, if S or T are nullable value types, let  S₀
and T₀ refer to their underlying types, otherwise  S₀ and T₀ are equal to  S and T
respectively. A class or struct is permitted to declare a conversion from a source type  S
to a target type  T only if all of the following are true:
S₀ and T₀ are different types.
Either S₀ or T₀ is the class or struct type in which the operator declaration takes
place.
Neither S₀ nor T₀ is an interface_type .
Excluding user-defined conversions, a conversion does not exist from  S to T or
from T to S.
The restrictions that apply to user-defined conversions are specified in §15.10.4 .10.4.3 Standard explicit conversions
10.5 User-defined conversions
10.5.1 General
10.5.2 Permitted user-defined conversions
10.5.3 Evaluation of user-defined conversionsA user-defined conversion converts a source expr ession , which may have a  source type ,
to another type, called the target type . Evaluation of a user-defined conversion centers
on finding the most -speci fic user-defined conversion operator for the source expression
and target type. This determination is broken into several steps:
Finding the set of classes and structs from which user-defined conversion
operators will be considered. This set consists of the source type and its base
classes, if the source type exists, along with the target type and its base classes. For
this purpose it is assumed that only classes and structs can declare user-defined
operators, and that non-class types have no base classes. Also, if either the source
or target type is a nullable-value-type, their underlying type is used instead.
From that set of types, determining which user-defined and lifted conversion
operators are applicable. For a conversion operator to be applicable, it shall be
possible to perform a standard conversion ( §10.4 ) from the source expression to
the operand type of the operator, and it shall be possible to perform a standard
conversion from the result type of the operator to the target type.
From the set of applicable user-defined operators, determining which operator is
unambiguously the most-specific. In general terms, the most-specific operator is
the operator whose operand type is “closest” to the source expression and whose
result type is “closest” to the target type. User-defined conversion operators are
preferred over lifted conversion operators. The exact rules for establishing the
most-specific user-defined conversion operator are defined in the following
subclauses.
Once a most-specific user-defined conversion operator has been identified, the actual
execution of the user-defined conversion involves up to three steps:
First, if required, performing a standard conversion from the source expression to
the operand type of the user-defined or lifted conversion operator.
Next, invoking the user-defined or lifted conversion operator to perform the
conversion.
Finally, if required, performing a standard conversion from the result type of the
user-defined conversion operator to the target type.
Evaluation of a user-defined conversion never involves more than one user-defined or
lifted conversion operator. In other words, a conversion from type  S to type  T will never
first execute a user-defined conversion from  S to X and then execute a user-defined
conversion from  X to T.
Exact definitions of evaluation of user-defined implicit or explicit conversions are
given in the following subclauses. The definitions make use of the following terms:If a standard implicit conversion ( §10.4.2 ) exists from a type  A to a type  B, and if
neither A nor B are interface_type  s, then A is said to be encompassed by B, and
B is said to encompass A.
If a standard implicit conversion ( §10.4.2 ) exists from an expression  E to a type  B,
and if neither  B nor the type of  E (if it has one) are interface_type  s, then E is said
to be encompassed by B, and B is said to encompass E.
The most -encompassing type  in a set of types is the one type that encompasses all
other types in the set. If no single type encompasses all other types, then the set
has no most-encompassing type. In more intuitive terms, the most-encompassing
type is the “largest” type in the set—the one type to which each of the other types
can be implicitly converted.
The most -encompassed type  in a set of types is the one type that is encompassed
by all other types in the set. If no single type is encompassed by all other types,
then the set has no most-encompassed type. In more intuitive terms, the most-
encompassed type is the “smallest” type in the set—the one type that can be
implicitly converted to each of the other types.
A user-defined implicit conversion from an expression  E to a type  T is processed as
follows:
Determine the types  S, S₀ and T₀.
If E has a type, let  S be that type.
If S or T are nullable value types, let  Sᵢ and Tᵢ be their underlying types,
otherwise let  Sᵢ and Tᵢ be S and T, respectively.
If Sᵢ or Tᵢ are type parameters, let  S₀ and T₀ be their effective base classes,
otherwise let  S₀ and T₀ be Sₓ and Tᵢ, respectively.
Find the set of types, D, from which user-defined conversion operators will be
considered. This set consists of  S₀ (if S₀ exists and is a class or struct), the base
classes of  S₀ (if S₀ exists and is a class), and  T₀ (if T₀ is a class or struct). A type is
added to the set  D only if an identity conversion to another type already included
in the set doesn’t exist.
Find the set of applicable user-defined and lifted conversion operators, U. This set
consists of the user-defined and lifted implicit conversion operators declared by
the classes or structs in  D that convert from a type encompassing  E to a type
encompassed by  T. If U is empty, the conversion is undefined and a compile-time
error occurs.10.5.4 User-defined implicit conversionsIf S exists and any of the operators in  U convert from  S, then Sₓ is S.
Otherwise, Sₓ is the most-encompassed type in the combined set of source
types of the operators in  U. If exactly one most-encompassed type cannot be
found, then the conversion is ambiguous and a compile-time error occurs.
Find the most-specific target type, Tₓ, of the operators in  U:
If any of the operators in U convert to  T, then Tₓ is T.
Otherwise, Tₓ is the most-encompassing type in the combined set of target
types of the operators in  U. If exactly one most-encompassing type cannot be
found, then the conversion is ambiguous and a compile-time error occurs.
Find the most-specific conversion operator:
If U contains exactly one user-defined conversion operator that converts from
Sₓ to Tₓ, then this is the most-specific conversion operator.
Otherwise, if U contains exactly one lifted conversion operator that converts
from Sₓ to Tₓ, then this is the most-specific conversion operator.
Otherwise, the conversion is ambiguous and a compile-time error occurs.
Finally, apply the conversion:
If E does not already have the type  Sₓ, then a standard implicit conversion
from E to Sₓ is performed.
The most-specific conversion operator is invoked to convert from Sₓ to Tₓ.
If Tₓ is not T, then a standard implicit conversion from Tₓ to T is performed.
A user-defined implicit conversion from a type  S to a type  T exists if a user-defined
implicit conversion exists from a variable of type  S to T.
A user-defined explicit conversion from an expression  E to a type  T is processed as
follows:
Determine the types  S, S₀ and T₀.
If E has a type, let  S be that type.
If S or T are nullable value types, let  Sᵢ and Tᵢ be their underlying types,
otherwise let  Sᵢ and Tᵢ be S and T, respectively.
If Sᵢ or Tᵢ are type parameters, let  S₀ and T₀ be their effective base classes,
otherwise let  S₀ and T₀ be Sᵢ and Tᵢ, respectively.
Find the set of types, D, from which user-defined conversion operators will be
considered. This set consists of S₀ (if S₀ exists and is a class or struct), the base10.5.5 User-defined explicit conversionsclasses of S₀ (if S₀ exists and is a class), T₀ (if T₀ is a class or struct), and the base
classes of T₀ (if T₀ is a class). A type is added to the set  D only if an identity
conversion to another type already included in the set doesn’t exist.
Find the set of applicable user-defined and lifted conversion operators,  U. This set
consists of the user-defined and lifted implicit or explicit conversion operators
declared by the classes or structs in  D that convert from a type encompassing  E or
encompassed by  S (if it exists) to a type encompassing or encompassed by  T. If U
is empty, the conversion is undefined and a compile-time error occurs.
Find the most-specific source type, Sₓ, of the operators in  U:
If S exists and any of the operators in U convert from  S, then Sₓ is S.
Otherwise, if any of the operators in U convert from types that encompass  E,
then Sₓ is the most-encompassed type in the combined set of source types of
those operators. If no most-encompassed type can be found, then the
conversion is ambiguous and a compile-time error occurs.
Otherwise, Sₓ is the most-encompassing type in the combined set of source
types of the operators in  U. If exactly one most-encompassing type cannot be
found, then the conversion is ambiguous and a compile-time error occurs.
Find the most-specific target type, Tₓ, of the operators in  U:
If any of the operators in U convert to  T, then Tₓ is T.
Otherwise, if any of the operators in U convert to types that are encompassed
by T, then Tₓ is the most-encompassing type in the combined set of target
types of those operators. If exactly one most-encompassing type cannot be
found, then the conversion is ambiguous and a compile-time error occurs.
Otherwise, Tₓ is the most-encompassed type in the combined set of target
types of the operators in  U. If no most-encompassed type can be found, then
the conversion is ambiguous and a compile-time error occurs.
Find the most-specific conversion operator:
If U contains exactly one user-defined conversion operator that converts
from Sₓ to Tₓ, then this is the most-specific conversion operator.
Otherwise, if  U contains exactly one lifted conversion operator that converts
from Sₓ to Tₓ, then this is the most-specific conversion operator.
Otherwise, the conversion is ambiguous and a compile-time error occurs.
Finally, apply the conversion:
If E does not already have the type  Sₓ, then a standard explicit conversion
from E to  Sₓ is performed.
The most-specific user-defined conversion operator is invoked to convert
from Sₓ to Tₓ.
If Tₓ is not T, then a standard explicit conversion from Tₓ to T is performed.A user-defined explicit conversion from a type  S to a type  T exists if a user-defined
explicit conversion exists from a variable of type  S to T.
Nullable c onversions  permit predefined conversions that operate on non-nullable value
types to also be used with nullable forms of those types. For each of the predefined
implicit or explicit conversions that convert from a non-nullable value type S to a non-
nullable value type  T (§10.2.2 , §10.2.3 , §10.2.4 , §10.2.11 , §10.3.2  and §10.3.3 ), the
following nullable conversions exist:
An implicit or explicit conversion from  S? to T?
An implicit or explicit conversion from  S to T?
An explicit conversion from  S? to T.
A nullable conversion is itself classified as an implicit or explicit conversion.
Certain nullable conversions are classified as standard conversions and can occur as part
of a user-defined conversion. Specifically, all implicit nullable conversions are classified
as standard implicit conversions ( §10.4.2 ), and those explicit nullable conversions that
satisfy the requirements of §10.4.3  are classified as standard explicit conversions.
Evaluation of a nullable conversion based on an underlying conversion from  S to T
proceeds as follows:
If the nullable conversion is from  S? to T?:
If the source value is null ( HasValue property is false), the result is the null
value of type  T?.
Otherwise, the conversion is evaluated as an unwrapping from  S? to S,
followed by the underlying conversion from  S to T, followed by a wrapping
from T to T?.
If the nullable conversion is from  S to T?, the conversion is evaluated as the
underlying conversion from  S to T followed by a wrapping from  T to T?.
If the nullable conversion is from  S? to T, the conversion is evaluated as an
unwrapping from  S? to S followed by the underlying conversion from  S to T.10.6 Conversions involving nulla ble types
10.6.1 Nullable Conversions
10.6.2 Lifted conversionsGiven a user-defined conversion operator that converts from a non-nullable value
type S to a non-nullable value type  T, a lifted conversion oper ator exists that converts
from S? to T?. This lifted conversion operator performs an unwrapping from  S? to S
followed by the user-defined conversion from  S to T followed by a wrapping from  T
to T?, except that a null valued  S? converts directly to a null valued  T?. A lifted
conversion operator has the same implicit or explicit classification as its underlying user-
defined conversion operator.
An anon ymous_method_expr ession  or lambda_expr ession  is classified as an anonymous
function ( §12.19 ). The expression does not have a type, but can be implicitly converted
to a compatible delegate type. Some lambda expressions may also be implicitly
converted to a compatible expression tree type.
Specifically, an anonymous function  F is compatible with a delegate type  D provided:
If F contains an anon ymous_f unction_signatur e, then D and F have the same
number of parameters.
If F does not contain an anon ymous_f unction_signatur e, then D may have zero or
more parameters of any type, as long as no parameter of  D has the out parameter
modifier.
If F has an explicitly typed parameter list, each parameter in  D has the same type
and modifiers as the corresponding parameter in  F.
If F has an implicitly typed parameter list, D has no ref or out parameters.
If the body of  F is an expression, and either  D has a void return type or F is async
and D has a «TaskType» return type ( §15.15.1 ), then when each parameter of  F is
given the type of the corresponding parameter in  D, the body of  F is a valid
expression (w.r.t  §12) that would be permitted as a statement_expr ession  (§13.7 ).
If the body of  F is a block, and either  D has a void return type or F is async and  D
has a «TaskType» return type , then when each parameter of  F is given the type of
the corresponding parameter in  D, the body of  F is a valid block (w.r.t  §13.3 ) in
which no return statement specifies an expression.
If the body of  F is an expression, and either  F is non-async and  D has a non- void
return type  T, or F is async and  D has a «TaskType»<T> return type ( §15.15.1 ), then
when each parameter of  F is given the type of the corresponding parameter in  D,
the body of  F is a valid expression (w.r.t §12) that is implicitly convertible to  T.10.7 Anonymous function conversions
10.7.1 GeneralIf the body of  F is a block, and either  F is non-async and  D has a non-void return
type T, or F is async and  D has a «TaskType»<T> return type, then when each
parameter of  F is given the type of the corresponding parameter in  D, the body
of F is a valid statement block (w.r.t  §13.3 ) with a non-reachable end point in
which each return statement specifies an expression that is implicitly convertible
to T.
Example : The following examples illustrate these rules:
C#
delegate  void D(int x);
D d1 = delegate  { };                         // Ok
D d2 = delegate () { };                       // Error, signature<br />
mismatch
D d3 = delegate (long x) { };                 // Error, signature<br />
mismatch
D d4 = delegate (int x) { };                  // Ok
D d5 = delegate (int x) { return; };          // Ok
D d6 = delegate (int x) { return x; };        // Error, return type<br />
mismatch
delegate  void E(out int x);
E e1 = delegate  { };                         // Error, E has an out<br />
parameter
E e2 = delegate (out int x) { x = 1; };       // Ok
E e3 = delegate (ref int x) { x = 1; };       // Error, signature<br />
mismatch
delegate  int P(params int[] a);
P p1 = delegate  { };                         // Error, end of block<br />
reachable
P p2 = delegate  { return; };                 // Error, return type<br />
mismatch
P p3 = delegate  { return 1; };               // Ok
P p4 = delegate  { return &quot;Hello&quot;; };         // Error, return type<br />
mismatch
P p5 = delegate (int[] a)                     // Ok
{
return a[0];
};
P p6 = delegate (params int[] a)              // Error, params modifier
{
return a[0];
};
P p7 = delegate (int[] a)                     // Error, return type<br />
mismatch
{
if (a.Length &gt; 0) return a[0];
return &quot;Hello&quot;;
};end ex ample
Example : The examples that follow use a generic delegate type Func&lt;A,R&gt; that
represents a function that takes an argument of type  A and returns a value of
type R:
C#
In the assignments
C#
the parameter and return types of each anonymous function are determined from
the type of the variable to which the anonymous function is assigned.
The first assignment successfully converts the anonymous function to the delegate
type Func&lt;int,int&gt; because, when  x is given type int, x + 1 is a valid expression
that is implicitly convertible to type int.
Likewise, the second assignment successfully converts the anonymous function to
the delegate type Func&lt;int,double&gt; because the result of x + 1 (of type int) is
implicitly convertible to type double.
However, the third assignment is a compile-time error because, when  x is given
type double, the result of x + 1 (of type double) is not implicitly convertible to type
int.
The fourth assignment successfully converts the anonymous async function to the
delegate type Func&lt;int, Task<int>&gt; because the result of x + 1 (of type int) isdelegate  object Q(params int[] a);
Q q1 = delegate (int[] a)                    // Ok
{
if (a.Length &gt; 0) return a[0];
return &quot;Hello&quot;;
};
delegate  R Func&lt;A,R&gt;(A arg);
Func&lt;int,int&gt; f1 = x =&gt; x + 1; // Ok
Func&lt;int,double&gt; f2 = x =&gt; x + 1; // Ok
Func&lt;double,int&gt; f3 = x =&gt; x + 1; // Error
Func&lt;int, Task<int>&gt; f4 = async x =&gt; x + 1; // Okimplicitly convertible to the effective return type int of the async lambda, which has
a return type Task<int>.
end ex ample
A lambda expression  F is compatible with an expression tree type Expression<D> if F is
compatible with the delegate type  D. This does not apply to anonymous methods, only
lambda expressions.
Anonymous functions may influence overload resolution, and participate in type
inference. See §12.6  for further details.
Conversion of an anonymous function to a delegate type produces a delegate instance
that references the anonymous function and the (possibly empty) set of captured outer
variables that are active at the time of the evaluation. When the delegate is invoked, the
body of the anonymous function is executed. The code in the body is executed using
the set of captured outer variables referenced by the delegate. A
delegat e_creation_expr ession  (§12.8.16.6 ) can be used as an alternate syntax for
converting an anonymous method to a delegate type.
The invocation list of a delegate produced from an anonymous function contains a
single entry. The exact target object and target method of the delegate are unspecified.
In particular, it is unspecified whether the target object of the delegate is null, the this
value of the enclosing function member, or some other object.
Conversions of semantically identical anonymous functions with the same (possibly
empty) set of captured outer variable instances to the same delegate types are
permitted (but not required) to return the same delegate instance. The term
semantically identical is used here to mean that execution of the anonymous functions
will, in all cases, produce the same effects given the same arguments. This rule permits
code such as the following to be optimized.
C#10.7.2 Evaluation of anonymous function conversions to
delegate types
delegate  double Function (double x);
class Test
{
static double[] Apply(double[] a, Function f )
{Since the two anonymous function delegates have the same (empty) set of captured
outer variables, and since the anonymous functions are semantically identical, the
compiler is permitted to have the delegates refer to the same target method. Indeed,
the compiler is permitted to return the very same delegate instance from both
anonymous function expressions.
Conversion of a lambda expression to an expression tree type produces an expression
tree ( §8.6). More precisely, evaluation of the lambda expression conversion produces an
object structure that represents the structure of the lambda expression itself.
Not every lambda expression can be converted to expression tree types. The conversion
to a compatible delegate type always exists , but it may fail at compile-time for
implementation-specific reasons.
Note: Common reasons for a lambda expression to fail to convert to an expression
tree type include:
It has a block body
It has the async modifier
It contains an assignment operator
It contains an out or ref parameter
It contains a dynamically bound expression
end not e        double[] result = new double[a.Length];
for (int i = 0; i &lt; a.Length; i++)
{
result[i] = f(a[i]);
}
return result;
}
static void F(double[] a, double[] b)
{
a = Apply(a, ( double x) =&gt; Math.Sin(x));
b = Apply(b, ( double y) =&gt; Math.Sin(y));
...
}
}
10.7.3 Evaluation of lambda expression conversions to
expression tree typesAn implicit conversion exists from a method group ( §12.2 ) to a compatible delegate type
(§20.4 ). If D is a delegate type, and E is an expression that is classified as a method
group, then D is compatible with E if and only if E contains at least one method that is
applicable in its normal form ( §12.6.4.2 ) to any argument list ( §12.6.2 ) having types and
modifiers matching the parameter types and modifiers of D, as described in the
following.
The compile-time application of the conversion from a method group  E to a delegate
type D is described in the following.
A single method  M is selected corresponding to a method invocation ( §12.8.9.2 ) of
the form  E(A), with the following modifications:
The argument list  A is a list of expressions, each classified as a variable and with
the type and modifier ( in, out, or ref) of the corresponding parameter in the
formal_p aramet er_list  of D — excepting parameters of type dynamic, where the
corresponding expression has the type object instead of dynamic.
The candidate methods considered are only those methods that are applicable
in their normal form and do not omit any optional parameters ( §12.6.4.2 ). Thus,
candidate methods are ignored if they are applicable only in their expanded
form, or if one or more of their optional parameters do not have a
corresponding parameter in  D.
A conversion is considered to exist if the algorithm of §12.8.9.2  produces a single
best method  M which is compatible ( §20.4 ) with D.
If the selected method  M is an instance method, the instance expression associated
with E determines the target object of the delegate.
If the selected method  M is an extension method which is denoted by means of a
member access on an instance expression, that instance expression determines the
target object of the delegate.
The result of the conversion is a value of type  D, namely a delegate that refers to
the selected method and target object.
Example : The following demonstrates method group conversions:
C#10.8 Method group conversions
delegate  string D1(object o);
delegate  object D2(string s);
delegate  object D3();
delegate  string D4(object o, params object[] a);
delegate  string D5(int i);The assignment to  d1 implicitly converts the method group  F to a value of type  D1.
The assignment to  d2 shows how it is possible to create a delegate to a method
that has less derived (contravariant) parameter types and a more derived (covariant)
return type.
The assignment to  d3 shows how no conversion exists if the method is not
applicable.
The assignment to  d4 shows how the method must be applicable in its normal
form.
The assignment to  d5 shows how parameter and return types of the delegate and
method are allowed to differ only for reference types.
end ex ample
As with all other implicit and explicit conversions, the cast operator can be used to
explicitly perform a particular conversion.
Example : Thus, the example
C#
could instead be written
C#class Test
{
static string F(object o) {...}
static void G()
{
D1 d1 = F;         // Ok
D2 d2 = F;         // Ok
D3 d3 = F;         // Error – not applicable
D4 d4 = F;         // Error – not applicable in normal form
D5 d5 = F;         // Error – applicable but not compatible
}
}
object obj = new EventHandler(myDialog.OkClick);
object obj = (EventHandler)myDialog.OkClick;end ex ample
A method group conversion can refer to a generic method, either by explicitly specifying
type arguments within  E, or via type inference ( §12.6.3 ). If type inference is used, the
parameter types of the delegate are used as argument types in the inference process.
The return type of the delegate is not used for inference. Whether the type arguments
are specified or inferred, they are part of the method group conversion process; these
are the type arguments used to invoke the target method when the resulting delegate is
invoked.
Example :
C#
end ex ample
Method groups may influence overload resolution, and participate in type inference. See
§12.6  for further details.
The run-time evaluation of a method group conversion proceeds as follows:
If the method selected at compile-time is an instance method, or it is an extension
method which is accessed as an instance method, the target object of the delegate
is determined from the instance expression associated with  E:
The instance expression is evaluated. If this evaluation causes an exception, no
further steps are executed.
If the instance expression is of a reference_type , the value computed by the
instance expression becomes the target object. If the selected method is andelegate  int D(string s, int i);
delegate  int E();
class X
{
public static T F<T>( string s, T t) {...}
public static T G<T>() {...}
static void Main()
{
D d1 = F&lt; int&gt;;        // Ok, type argument given explicitly
D d2 = F;             // Ok, int inferred as type argument
E e1 = G&lt; int&gt;;        // Ok, type argument given explicitly
E e2 = G;             // Error, cannot infer from return type
}
}instance method and the target object is null, a
System.NullReferenceException is thrown and no further steps are executed.
If the instance expression is of a value_type , a boxing operation ( §10.2.9 ) is
performed to convert the value to an object, and this object becomes the target
object.
Otherwise, the selected method is part of a static method call, and the target
object of the delegate is null.
A delegate instance of delegate type  D is obtained with a reference to the method
that was determined at compile-time and a reference to the target object
computed above, as follows:
The conversion is permitted (but not required) to use an existing delegate instance
that already contains these references.
If an existing instance was not reused, a new one is created ( §20.5 ). If there is not
enough memory available to allocate the new instance, a
System.OutOfMemoryException is thrown. Otherwise the instance is initialized with
the given references.11 Patterns and pattern matching
Article •11/30/2023
A pattern is a syntactic form that can be used with the is operator ( §12.12.12 ) and in a
switch_st atement  (§13.8.3 ) to express the shape of data against which incoming data is
to be compared. A pattern is tested against the expression  of a switch statement, or
against a relational_expr ession  that is on the left-hand side of an is operator, each of
which is referred to as a pattern input v alue.
A pattern may have one of the following forms:
ANTLR
A declar ation_p attern and a var_pattern can result in the declaration of a local variable.
Each pattern form defines the set of types for input values that the pattern may be
applied to. A pattern P is applicable t o a type T if T is among the types whose values
the pattern may match. It is a compile-time error if a pattern P appears in a program to
match a pattern input value ( §11.1 ) of type T if P is not applicable to T.
Example : The following example generates a compile-time error because the
compile-time type of v is TextReader. A variable of type TextReader can never have
a value that is reference-compatible with string:
C#11.1 General
11.2 Pattern forms
11.2.1 General
pattern
: declaration_pattern
| constant_pattern
| var_pattern
;
TextReader v = Console.In; // compile-time type of 'v' is 'TextReader'
if (v is string) // compile-time error
{However, the following doesn’t generate a compile-time error because the compile-
time type of v is object. A variable of type object could have a value that is
reference-compatible with string:
C#
end ex ample
Each pattern form defines the set of values for which the pattern matches the value at
runtime.
A declar ation_p attern is used to test that a value has a given type and, if the test
succeeds, provide the value in a variable of that type.
ANTLR
The runtime type of the value is tested against the type in the pattern using the same
rules specified in the is-type operator ( §12.12.12.1 ). If the test succeeds, the pattern
matches that value. It is a compile-time error if the type is a nullable value type ( §8.3.12 ).
This pattern form never matches a null value.
Note: The is-type expression e is T and the declaration pattern e is T _ are
equivalent when T isn’t a nullable type. end not e    // code assuming v is a string
}
object v = Console.In;
if (v is string s)
{
// code assuming v is a string
}
11.2.2 Declaration pattern
declaration_pattern
: type simple_designation
;
simple_designation
: single_variable_designation
;
single_variable_designation
: identifier
;Given a pattern input value ( §11.1 ) e, if the simple_designation  is the identi fier _, it
denotes a discard ( §9.2.9.1 ) and the value of e is not bound to anything. (Although a
declared variable with the name _ may be in scope at that point, that named variable is
not seen in this context.) If simple_designation  is any other identifier, a local variable
(§9.2.9 ) of the given type named by the given identifier is introduced. That local variable
is assigned the value of the pattern input value when the pattern matches the value.
Certain combinations of static type of the pattern input value and the given type are
considered incompatible and result in a compile-time error. A value of static type E is
said to be pattern compatible  with the type T if there exists an identity conversion, an
implicit or explicit reference conversion, a boxing conversion, or an unboxing conversion
from E to T, or if either E or T is an open type ( §8.4.3 ). A declaration pattern naming a
type T is applicable t o every type E for which E is pattern compatible with T.
Note: The support for open types can be most useful when checking types that may
be either struct or class types, and boxing is to be avoided. end not e
Example : The declaration pattern is useful for performing run-time type tests of
reference types, and replaces the idiom
C#
with the slightly more concise
C#
end ex ample
It is an error if type is a nullable value type.
Example : The declaration pattern can be used to test values of nullable types: a
value of type Nullable<T> (or a boxed T) matches a type pattern T2 id if the value
is non-null and T2 is T, or some base type or interface of T. For example, in the
code fragment
C#var v = expr as Type;
if (v != null) { /* code using v <em>/  }
if (expr is Type v) { /</em> code using v <em>/  }The condition of the if statement is true at runtime and the variable v holds the
value 3 of type int inside the block. end ex ample
A constant_p attern is used to test the value of a pattern input value ( §11.1 ) against the
given constant value.
ANTLR
A constant pattern P is applicable t o a type T if there is an implicit conversion from the
constant expression of P to the type T.
For a constant pattern P, its converted value is
if the pattern input value’s type is an integral type or an enum type, the pattern’s
constant value converted to that type; otherwise
if the pattern input value’s type is the nullable version of an integral type or an
enum type, the pattern’s constant value converted to its underlying type; otherwise
the value of the pattern’s constant value.
Given a pattern input value e and a constant pattern P with converted value v,
if e has integral type or enum type, or a nullable form of one of those, and v has
integral type, the pattern P matches the value e if result of the expression e == v
is true; otherwise
the pattern P matches the value e if object.Equals(e, v) returns true.
Example : The switch statement in the following method uses five constant patterns
in its case labels.
C#int? x = 3;
if (x is int v) { /</em> code using v */  }
11.2.3 Constant pattern
constant_pattern
: constant_expression
;
static decimal GetGroupTicketPrice (int visitorCount )
{
switch (visitorCount) end ex ample
A var_pattern matches every value. That is, a pattern-matching operation with a
var_pattern always succeeds.
A var_pattern is applicable t o every type.
ANTLR
Given a pattern input value ( §11.1 ) e, if designation  is the identi fier _, it denotes a
discard ( §9.2.9.1 ), and the value of e is not bound to anything. (Although a declared
variable with that name may be in scope at that point, that named variable is not seen in
this context.) If designation  is any other identifier, at runtime the value of e is bound to a
newly introduced local variable ( §9.2.9 ) of that name whose type is the static type of e,
and the pattern input value is assigned to that local variable.
It is an error if the name var would bind to a type where a var_pattern is used.
In a switch statement, it is an error if a case’s pattern is subsumed  by the preceding set
of unguarded cases ( §13.8.3 ). Informally, this means that any input value would have
been matched by one of the previous cases. The following rules define when a set of
patterns subsumes a given pattern:    {
case 1: return 12.0m;
case 2: return 20.0m;
case 3: return 27.0m;
case 4: return 32.0m;
case 0: return 0.0m;
default: throw new ArgumentException(...);
}
}
11.2.4 Var pattern
var_pattern
: 'var' designation
;
designation
: simple_designation
;
11.3 Pattern subsump tionA pattern P would mat ch a constant K if the specification for that pattern’s runtime
behavior is that P matches K.
A set of patterns Q subsumes  a pattern P if any of the following conditions hold:
P is a constant pattern and any of the patterns in the set Q would match P’s
converted value
P is a var pattern and the set of patterns Q is exhaustiv e (§11.4 ) for the type of the
pattern input value ( §11.1 ), and either the pattern input value is not of a nullable
type or some pattern in Q would match null.
P is a declaration pattern with type T and the set of patterns Q is exhaustiv e for
the type T (§11.4 ).
Informally, a set of patterns is exhaustive for a type if, for every possible value of that
type other than null, some pattern in the set is applicable. The following rules define
when a set of patterns is exhaustiv e for a type:
A set of patterns Q is exhaustiv e for a type T if any of the following conditions hold:</p>
</li>
</ul>
<ol>
<li>T is an integral or enum type, or a nullable version of one of those, and for every
possible value of T’s non-nullable underlying type, some pattern in Q would
match that value; or</li>
<li>Some pattern in Q is a var pattern; or</li>
<li>Some pattern in Q is a declar ation p attern for type D, and there is an identity
conversion, an implicit reference conversion, or a boxing conversion from T to D.
Example :
C#11.4 Pattern exhaustiveness
static void M(byte b)
{
switch (b) {
case 0: case 1: case 2: ... // handle every specific value of<br />
byte
break;
// error: the pattern 'byte other' is subsumed by the<br />
(exhaustive)
// previous cases
case byte other: 
break;end ex ample    }
}
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide .C# Standar d documentation
feedb ack
C# Standard documentation is an
open source project. Select a link to
provide feedback:
 Open a documentation issue
 Provide product feedback12 Expressions
Article •04/12/2023
An expression is a sequence of operators and operands. This clause defines the syntax,
order of evaluation of operands and operators, and meaning of expressions.
The result of an expression is classified as one of the following:
A value. Every value has an associated type.
A variable. Unless otherwise specified, a variable is explicitly typed and has an
associated type, namely the declared type of the variable. An implicitly typed
variable has no associated type.
A null literal. An expression with this classification can be implicitly converted to a
reference type or nullable value type.
An anonymous function. An expression with this classification can be implicitly
converted to a compatible delegate type or expression tree type.
A tuple. Every tuple has a fixed number of elements, each with an expression and
an optional tuple element name.
A property access. Every property access has an associated type, namely the type
of the property. Furthermore, a property access may have an associated instance
expression. When an accessor of an instance property access is invoked, the result
of evaluating the instance expression becomes the instance represented by this
(§12.8.13 ).
An indexer access. Every indexer access has an associated type, namely the
element type of the indexer. Furthermore, an indexer access has an associated
instance expression and an associated argument list. When an accessor of an
indexer access is invoked, the result of evaluating the instance expression becomes
the instance represented by this (§12.8.13 ), and the result of evaluating the
argument list becomes the parameter list of the invocation.
Nothing. This occurs when the expression is an invocation of a method with a
return type of void. An expression classified as nothing is only valid in the context
of a statement_expr ession  (§13.7 ) or as the body of a lambda_expr ession  (§12.19 ).12.1 General
12.2 Expression classifications
12.2.1 GeneralFor expressions which occur as subexpressions of larger expressions, with the noted
restrictions, the result can also be classified as one of the following:
A namespace. An expression with this classification can only appear as the left-
hand side of a member_ac cess (§12.8.7 ). In any other context, an expression
classified as a namespace causes a compile-time error.
A type. An expression with this classification can only appear as the left-hand side
of a member_ac cess (§12.8.7 ). In any other context, an expression classified as a
type causes a compile-time error.
A method group, which is a set of overloaded methods resulting from a member
lookup ( §12.5 ). A method group may have an associated instance expression and
an associated type argument list. When an instance method is invoked, the result
of evaluating the instance expression becomes the instance represented by this
(§12.8.13 ). A method group is permitted in an invocation_expr ession  (§12.8.9 ) or a
delegat e_creation_expr ession  (§12.8.16.6 ), and can be implicitly converted to a
compatible delegate type ( §10.8 ). In any other context, an expression classified as a
method group causes a compile-time error.
An event access. Every event access has an associated type, namely the type of the
event. Furthermore, an event access may have an associated instance expression.
An event access may appear as the left operand of the += and -= operators
(§12.21.5 ). In any other context, an expression classified as an event access causes a
compile-time error. When an accessor of an instance event access is invoked, the
result of evaluating the instance expression becomes the instance represented by
this (§12.8.13 ).
A throw expression, which may be used is several contexts to throw an exception
in an expression. A throw expression may be converted by an implicit conversion
to any type.
A property access or indexer access is always reclassified as a value by performing an
invocation of the get_ac cessor or the set_ac cessor. The particular accessor is determined
by the context of the property or indexer access: If the access is the target of an
assignment, the set_ac cessor is invoked to assign a new value ( §12.21.2 ). Otherwise, the
get_ac cessor is invoked to obtain the current value ( §12.2.2 ).
An instance accessor is a property access on an instance, an event access on an instance,
or an indexer access.
Most of the constructs that involve an expression ultimately require the expression to
denote a value. In such cases, if the actual expression denotes a namespace, a type, a12.2.2 Values of expressionsmethod group, or nothing, a compile-time error occurs. However, if the expression
denotes a property access, an indexer access, or a variable, the value of the property,
indexer, or variable is implicitly substituted:
The value of a variable is simply the value currently stored in the storage location
identified by the variable. A variable shall be considered definitely assigned ( §9.4)
before its value can be obtained, or otherwise a compile-time error occurs.
The value of a property access expression is obtained by invoking the get_ac cessor
of the property. If the property has no get_ac cessor, a compile-time error occurs.
Otherwise, a function member invocation ( §12.6.6 ) is performed, and the result of
the invocation becomes the value of the property access expression.
The value of an indexer access expression is obtained by invoking the get_ac cessor
of the indexer. If the indexer has no get_ac cessor, a compile-time error occurs.
Otherwise, a function member invocation ( §12.6.6 ) is performed with the argument
list associated with the indexer access expression, and the result of the invocation
becomes the value of the indexer access expression.
The value of a tuple expression is obtained by applying an implicit tuple
conversion ( §10.2.13 ) to the type of the tuple expression. It is an error to obtain the
value of a tuple expression that does not have a type.
Binding  is the process of determining what an operation refers to, based on the type or
value of expressions (arguments, operands, receivers). For instance, the binding of a
method call is determined based on the type of the receiver and arguments. The
binding of an operator is determined based on the type of its operands.
In C# the binding of an operation is usually determined at compile-time, based on the
compile-time type of its subexpressions. Likewise, if an expression contains an error, the
error is detected and reported by the compiler. This approach is known as static
binding .
However, if an expression is a dynamic expr ession  (i.e., has the type dynamic) this
indicates that any binding that it participates in should be based on its run-time type
rather than the type it has at compile-time. The binding of such an operation is
therefore deferred until the time where the operation is to be executed during the
running of the program. This is referred to as dynamic binding .12.3 Static and Dynamic Binding
12.3.1 GeneralWhen an operation is dynamically bound, little or no checking is performed by the
compiler. Instead if the run-time binding fails, errors are reported as exceptions at run-
time.
The following operations in C# are subject to binding:
Member access: e.M
Method invocation: e.M(e₁,...,eᵥ)
Delegate invocation: e(e₁,...,eᵥ)
Element access: e[e₁,...,eᵥ]
Object creation: new C(e₁,...,eᵥ)
Overloaded unary operators: +, -, !, ~, ++, --, true, false
Overloaded binary operators: +, -, *, /, %, &amp;, &amp;&amp;, |, ||, ??, ^, &lt;&lt;, &gt;&gt;, ==, !=,
&gt;, &lt;, &gt;=, &lt;=
Assignment operators: =, = ref, +=, -=, *=, /=, %=, &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=
Implicit and explicit conversions
When no dynamic expressions are involved, C# defaults to static binding, which means
that the compile-time types of subexpressions are used in the selection process.
However, when one of the subexpressions in the operations listed above is a dynamic
expression, the operation is instead dynamically bound.
It is a compile time error if a method invocation is dynamically bound and any of the
parameters, including the receiver, has the in modifier.
Static binding takes place at compile-time, whereas dynamic binding takes place at run-
time. In the following subclauses, the term binding-time  refers to either compile-time or
run-time, depending on when the binding takes place.
Example : The following illustrates the notions of static and dynamic binding and of
binding-time:
C#12.3.2 Binding-time
object o = 5;
dynamic d = 5;
Console.WriteLine( 5); // static binding to Console.WriteLine(int)
Console.WriteLine(o); // static binding to Console.WriteLine(object)
Console.WriteLine(d); // dynamic binding to Console.WriteLine(int)The first two calls are statically bound: the overload of Console.WriteLine is picked
based on the compile-time type of their argument. Thus, the binding-time is
compile-time .
The third call is dynamically bound: the overload of Console.WriteLine is picked
based on the run-time type of its argument. This happens because the argument is
a dynamic expression – its compile-time type is dynamic. Thus, the binding-time for
the third call is run-time .
end ex ample
This subclause is informativ e.
Dynamic binding allows C# programs to interact with dynamic objects, i.e., objects that
do not follow the normal rules of the C# type system. Dynamic objects may be objects
from other programming languages with different types systems, or they may be
objects that are programmatically setup to implement their own binding semantics for
different operations.
The mechanism by which a dynamic object implements its own semantics is
implementation-defined. A given interface – again implementation-defined – is
implemented by dynamic objects to signal to the C# run-time that they have special
semantics. Thus, whenever operations on a dynamic object are dynamically bound, their
own binding semantics, rather than those of C# as specified in this specification, take
over.
While the purpose of dynamic binding is to allow interoperation with dynamic objects,
C# allows dynamic binding on all objects, whether they are dynamic or not. This allows
for a smoother integration of dynamic objects, as the results of operations on them may
not themselves be dynamic objects, but are still of a type unknown to the programmer
at compile-time. Also, dynamic binding can help eliminate error-prone reflection-based
code even when no objects involved are dynamic objects.
When an operation is statically bound, the type of a subexpression (e.g., a receiver, and
argument, an index or an operand) is always considered to be the compile-time type of
that expression.12.3.3 Dynamic binding
12.3.4 Types of subexpressionsWhen an operation is dynamically bound, the type of a subexpression is determined in
different ways depending on the compile-time type of the subexpression:
A subexpression of compile-time type dynamic is considered to have the type of
the actual value that the expression evaluates to at run-time
A subexpression whose compile-time type is a type parameter is considered to
have the type which the type parameter is bound to at run-time
Otherwise, the subexpression is considered to have its compile-time type.
Expressions are constructed from operands and operators. The operators of an
expression indicate which operations to apply to the operands.
Example : Examples of operators include +, -, *, /, and new. Examples of operands
include literals, fields, local variables, and expressions. end ex ample
There are three kinds of operators:
Unary operators. The unary operators take one operand and use either prefix
notation (such as  –x) or postfix notation (such as  x++).
Binary operators. The binary operators take two operands and all use infix notation
(such as x + y).
Ternary operator. Only one ternary operator, ?:, exists; it takes three operands and
uses infix notation ( c ? x : y).
The order of evaluation of operators in an expression is determined by the precedenc e
and associativity  of the operators ( §12.4.2 ).
Operands in an expression are evaluated from left to right.
Example : In F(i) + G(i++) * H(i), method  F is called using the old value of  i, then
method  G is called with the old value of  i, and, finally, method  H is called with the
new value of i. This is separate from and unrelated to operator precedence. end
example
Certain operators can be overloaded . Operator overloading ( §12.4.3 ) permits user-
defined operator implementations to be specified for operations where one or both of
the operands are of a user-defined class or struct type.12.4 Operators
12.4.1 GeneralWhen an expression contains multiple operators, the precedenc e of the operators
controls the order in which the individual operators are evaluated.
Note: For example, the expression x + y * z is evaluated as x + (y * z) because
the * operator has higher precedence than the binary + operator. end not e
The precedence of an operator is established by the definition of its associated grammar
production.
Note: For example, an additiv e_expr ession  consists of a sequence of
multiplicativ e_expr ession s separated by + or - operators, thus giving the + and
- operators lower precedence than the *, /, and % operators. end not e
Note: The following table summarizes all operators in order of precedence from
highest to lowest:
Subclause Categor y Operat ors
§12.8 Primary x.y x?.y f(x) a[x] a?[x] x++ x-- new typeof
default checked unchecked delegate stackalloc
§12.9 Unary + - ! ~ ++x --x (T)x await x
§12.10 Multiplicative * / %
§12.10 Additive + -
§12.11 Shift &lt;&lt; &gt;&gt;
§12.12 Relational and type-
testing&lt; &gt; &lt;= &gt;= is as
§12.12 Equality == !=
§12.13 Logical AND &amp;
§12.13 Logical X OR ^
§12.13 Logical OR |
§12.14 Conditional AND &amp;&amp;
§12.14 Conditional OR ||12.4.2 Operator precedence and associativitySubclause Categor y Operat ors
§12.15  and
§12.16Null coalescing and
throw expression?? throw x
§12.18 Conditional ?:
§12.21  and
§12.19Assignment and
lambda expression= = ref *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |= =&gt;
end not e
When an operand occurs between two operators with the same precedence, the
associativity  of the operators controls the order in which the operations are performed:
Except for the assignment operators and the null coalescing operator, all binary
operators are left-associativ e, meaning that operations are performed from left to
right.
Example : x + y + z is evaluated as (x + y) + z. end ex ample
The assignment operators, the null coalescing operator and the conditional
operator ( ?:) are right-associativ e, meaning that operations are performed from
right to left.
Example : x = y = z is evaluated as x = (y = z). end ex ample
Precedence and associativity can be controlled using parentheses.
Example : x + y * z first multiplies  y by z and then adds the result to  x, but
(x + y) * z first adds  x and y and then multiplies the result by  z. end ex ample
All unary and binary operators have predefined implementations. In addition, user-
defined implementations can be introduced by including operator declarations ( §15.10 )
in classes and structs. User-defined operator implementations always take precedence
over predefined operator implementations: Only when no applicable user-defined
operator implementations exist will the predefined operator implementations be
considered, as described in §12.4.4  and §12.4.5 .
The overloadable unar y oper ators are:12.4.3 Operator overloadingC#
Note: Although true and false are not used explicitly in expressions (and therefore
are not included in the precedence table in §12.4.2 ), they are considered operators
because they are invoked in several expression contexts: Boolean expressions
(§12.24 ) and expressions involving the conditional ( §12.18 ) and conditional logical
operators ( §12.14 ). end not e
The overloadable binar y oper ators are:
C#
Only the operators listed above can be overloaded. In particular, it is not possible to
overload member access, method invocation, or the =, &amp;&amp;, ||, ??, ?:, =&gt;, checked,
unchecked, new, typeof, default, as, and is operators.
When a binary operator is overloaded, the corresponding compound assignment
operator, if any, is also implicitly overloaded.
Example : An overload of operator  * is also an overload of operator  *=. This is
described further in  §12.21 . end ex ample
The assignment operator itself (=) cannot be overloaded. An assignment always
performs a simple store of a value into a variable ( §12.21.2 ).
Cast operations, such as (T)x, are overloaded by providing user-defined conversions
(§10.5 ).
Note: User-defined conversions do not affect the behavior of the is or as
operators. end not e
Element access, such as a[x], is not considered an overloadable operator. Instead, user-
defined indexing is supported through indexers ( §15.9 ).
In expressions, operators are referenced using operator notation, and in declarations,
operators are referenced using functional notation. The following table shows the
relationship between operator and functional notations for unary and binary operators.+  -  !  ~  ++  --  true  false</li>
</ol>
<ul>
<li>
<ul>
<li>
<ul>
<li>/  %  &amp;  |  ^  &lt;&lt;  &gt;&gt;  ==  !=  &gt;  &lt;  &lt;=  &gt;=In the first entry, «op» denotes any overloadable unary prefix operator. In the second
entry, «op» denotes the unary postfix ++ and -- operators. In the third entry, «op»
denotes any overloadable binary operator.
Note: For an example of overloading the ++ and -- operators see §15.10.2 . end not e
Operat or notation Functional notation
«op» x operator «op»(x)
x «op» operator «op»(x)
x «op» y operator «op»(x, y)
User-defined operator declarations always require at least one of the parameters to be
of the class or struct type that contains the operator declaration.
Note: Thus, it is not possible for a user-defined operator to have the same signature
as a predefined operator. end not e
User-defined operator declarations cannot modify the syntax, precedence, or
associativity of an operator.
Example : The / operator is always a binary operator, always has the precedence
level specified in §12.4.2 , and is always left-associative. end ex ample
Note: While it is possible for a user-defined operator to perform any computation it
pleases, implementations that produce results other than those that are intuitively
expected are strongly discouraged. For example, an implementation of operator  ==
should compare the two operands for equality and return an appropriate bool
result. end not e
The descriptions of individual operators in §12.9  through §12.21  specify the predefined
implementations of the operators and any additional rules that apply to each operator.
The descriptions make use of the terms unar y oper ator overload resolution , binar y
operator overload resolution , numer ic promotion , and lifted operator definitions of
which are found in the following subclauses.
12.4.4 Unary operator overload resolutionAn operation of the form «op» x or x «op», where «op» is an overloadable unary
operator, and x is an expression of type  X, is processed as follows:
The set of candidate user-defined operators provided by  X for the operation
operator «op»(x) is determined using the rules of §12.4.6 .
If the set of candidate user-defined operators is not empty, then this becomes the
set of candidate operators for the operation. Otherwise, the predefined binary
operator «op» implementations, including their lifted forms, become the set of
candidate operators for the operation. The predefined implementations of a given
operator are specified in the description of the operator. The predefined operators
provided by an enum or delegate type are only included in this set when the
binding-time type—or the underlying type if it is a nullable type—of either
operand is the enum or delegate type.
The overload resolution rules of §12.6.4  are applied to the set of candidate
operators to select the best operator with respect to the argument list  (x), and
this operator becomes the result of the overload resolution process. If overload
resolution fails to select a single best operator, a binding-time error occurs.
An operation of the form x «op» y, where «op» is an overloadable binary operator, x is
an expression of type  X, and y is an expression of type  Y, is processed as follows:
The set of candidate user-defined operators provided by X and Y for the
operation operator «op»(x, y) is determined. The set consists of the union of the
candidate operators provided by X and the candidate operators provided by  Y,
each determined using the rules of §12.4.6 . For the combined set, candidates are
merged as follows:
If X and Y are the same type, or if  X and Y are derived from a common base
type, then shared candidate operators only occur in the combined set once.
If there is an identity conversion between  X and Y, an operator «op»Y provided
by Y has the same return type as an «op»X provided by  X and the operand
types of «op»Y have an identity conversion to the corresponding operand types
of «op»X then only «op»X occurs in the set.
If the set of candidate user-defined operators is not empty, then this becomes the
set of candidate operators for the operation. Otherwise, the predefined binary
operator «op» implementations, including their lifted forms, become the set of
candidate operators for the operation. The predefined implementations of a given
operator are specified in the description of the operator. For predefined enum and12.4.5 Binary operator overload resolutiondelegate operators, the only operators considered are those provided by an enum
or delegate type that is the binding-time type of one of the operands.
The overload resolution rules of §12.6.4  are applied to the set of candidate
operators to select the best operator with respect to the argument list (x, y), and
this operator becomes the result of the overload resolution process. If overload
resolution fails to select a single best operator, a binding-time error occurs.
Given a type  T and an operation operator «op»(A), where «op» is an overloadable
operator and A is an argument list, the set of candidate user-defined operators
provided by T for operator  «op»(A) is determined as follows:
Determine the type T₀. If T is a nullable value type, T₀ is its underlying type;
otherwise,  T₀ is equal to  T.
For all operator «op» declarations in  T₀ and all lifted forms of such operators, if at
least one operator is applicable ( §12.6.4.2 ) with respect to the argument list  A,
then the set of candidate operators consists of all such applicable operators in  T₀.
Otherwise, if  T₀ is object, the set of candidate operators is empty.
Otherwise, the set of candidate operators provided by  T₀ is the set of candidate
operators provided by the direct base class of  T₀, or the effective base class of  T₀
if T₀ is a type parameter.
This subclause is informativ e.
§12.4.7  and its subclauses are a summary of the combined effect of:
the rules for implicit numeric conversions ( §10.2.3 );
the rules for better conversion ( §12.6.4.7 ); and
the available arithmetic ( §12.10 ), relational ( §12.12 ), and integral logical ( §12.13.2 )
operators.
Numeric promotion consists of automatically performing certain implicit conversions of
the operands of the predefined unary and binary numeric operators. Numeric
promotion is not a distinct mechanism, but rather an effect of applying overload
resolution to the predefined operators. Numeric promotion specifically does not affect12.4.6 Candidate user-defined operators
12.4.7 Numeric promotions
12.4.7.1 Generalevaluation of user-defined operators, although user-defined operators can be
implemented to exhibit similar effects.
As an example of numeric promotion, consider the predefined implementations of the
binary * operator:
C#
When overload resolution rules ( §12.6.4 ) are applied to this set of operators, the effect is
to select the first of the operators for which implicit conversions exist from the operand
types.
Example : For the operation b * s, where b is a byte and s is a short, overload
resolution selects operator *(int, int) as the best operator. Thus, the effect is that
b and s are converted to int, and the type of the result is int. Likewise, for the
operation i * d, where i is an int and d is a double, overload resolution selects
operator *(double, double) as the best operator. end ex ample
End o f informativ e text.
This subclause is informativ e.
Unary numeric promotion occurs for the operands of the predefined +, –, and ~ unary
operators. Unary numeric promotion simply consists of converting operands of type
sbyte, byte, short, ushort, or char to type int. Additionally, for the unary – operator,
unary numeric promotion converts operands of type uint to type long.
End o f informativ e text.
This subclause is informativ e.int operator  *(int x, int y);
uint operator  *(uint x, uint y);
long operator  *(long x, long y);
ulong operator  *(ulong x, ulong y);
float operator  *(float x, float y);
double operator  *(double x, double y);
decimal operator  <em>(decimal x, decimal y);
12.4.7.2 Unary numeric promotions
12.4.7.3 Binary numeric promotionsBinary numeric promotion occurs for the operands of the predefined +, –, <em>, /, %, &amp;,
|, ^, ==, !=, &gt;, &lt;, &gt;=, and &lt;= binary operators. Binary numeric promotion implicitly
converts both operands to a common type which, in case of the non-relational
operators, also becomes the result type of the operation. Binary numeric promotion
consists of applying the following rules, in the order they appear here:
If either operand is of type decimal, the other operand is converted to type
decimal, or a binding-time error occurs if the other operand is of type float or
double.
Otherwise, if either operand is of type double, the other operand is converted to
type double.
Otherwise, if either operand is of type float, the other operand is converted to
type float.
Otherwise, if either operand is of type ulong, the other operand is converted to
type ulong, or a binding-time error occurs if the other operand is of type sbyte,
short, int, or long.
Otherwise, if either operand is of type long, the other operand is converted to
type long.
Otherwise, if either operand is of type uint and the other operand is of type
sbyte, short, or int, both operands are converted to type long.
Otherwise, if either operand is of type uint, the other operand is converted to
type uint.
Otherwise, both operands are converted to type int.
Note: The first rule disallows any operations that mix the decimal type with the
double and float types. The rule follows from the fact that there are no implicit
conversions between the decimal type and the double and float types. end not e
Note: Also note that it is not possible for an operand to be of type ulong when the
other operand is of a signed integral type. The reason is that no integral type exists
that can represent the full range of ulong as well as the signed integral types. end
note
In both of the above cases, a cast expression can be used to explicitly convert one
operand to a type that is compatible with the other operand.
Example : In the following code
C#a binding-time error occurs because a decimal cannot be multiplied by a double.
The error is resolved by explicitly converting the second operand to decimal, as
follows:
C#
end ex ample
End o f informativ e text.
Lifted oper ators permit predefined and user-defined operators that operate on non-
nullable value types to also be used with nullable forms of those types. Lifted operators
are constructed from predefined and user-defined operators that meet certain
requirements, as described in the following:
For the unary operators +, ++, -, --, !, and ~, a lifted form of an operator exists
if the operand and result types are both non-nullable value types. The lifted form is
constructed by adding a single ? modifier to the operand and result types. The
lifted operator produces a null value if the operand is null. Otherwise, the lifted
operator unwraps the operand, applies the underlying operator, and wraps the
result.
For the binary operators +, -, <em>, /, %, &amp;, |, ^, &lt;&lt;, and &gt;&gt;, a lifted form of an
operator exists if the operand and result types are all non-nullable value types. The
lifted form is constructed by adding a single ? modifier to each operand and result
type. The lifted operator produces a null value if one or both operands are null
(an exception being the &amp; and | operators of the bool? type, as described in
§12.13.5 ). Otherwise, the lifted operator unwraps the operands, applies the
underlying operator, and wraps the result.
For the equality operators == and !=, a lifted form of an operator exists if the
operand types are both non-nullable value types and if the result type is bool. The
lifted form is constructed by adding a single ? modifier to each operand type. The
lifted operator considers two null values equal, and a null value unequal to anydecimal AddPercent (decimal x, double percent ) =&gt;
x * (1.0 + percent / 100.0);
decimal AddPercent (decimal x, double percent ) =&gt;
x * (decimal)(1.0 + percent / 100.0);
12.4.8 Lifted operatorsnon-null value. If both operands are non- null, the lifted operator unwraps the
operands and applies the underlying operator to produce the bool result.
For the relational operators &lt;, &gt;, &lt;=, and &gt;=, a lifted form of an operator exists if
the operand types are both non-nullable value types and if the result type is bool.
The lifted form is constructed by adding a single ? modifier to each operand type.
The lifted operator produces the value false if one or both operands are null.
Otherwise, the lifted operator unwraps the operands and applies the underlying
operator to produce the bool result.
A member lookup is the process whereby the meaning of a name in the context of a
type is determined. A member lookup can occur as part of evaluating a simple_name
(§12.8.4 ) or a member_ac cess (§12.8.7 ) in an expression. If the simple_name  or
member_ac cess occurs as the primary_expr ession  of an invocation_expr ession  (§12.8.9.2 ),
the member is said to be invoked.
If a member is a method or event, or if it is a constant, field or property of either a
delegate type ( §20) or the type dynamic (§8.2.4 ), then the member is said to be
invocable.
Member lookup considers not only the name of a member but also the number of type
parameters the member has and whether the member is accessible. For the purposes of
member lookup, generic methods and nested generic types have the number of type
parameters indicated in their respective declarations and all other members have zero
type parameters.
A member lookup of a name  N with K type arguments in a type  T is processed as
follows:
First, a set of accessible members named  N is determined:
If T is a type parameter, then the set is the union of the sets of accessible
members named  N in each of the types specified as a primary constraint or
secondary constraint ( §15.2.5 ) for T, along with the set of accessible members
named N in object.
Otherwise, the set consists of all accessible ( §7.5) members named  N in T,
including inherited members and the accessible members named  N in object. If
T is a constructed type, the set of members is obtained by substituting type12.5 Member lookup
12.5.1 Generalarguments as described in §15.3.3 . Members that include an override modifier
are excluded from the set.
Next, if K is zero, all nested types whose declarations include type parameters are
removed. If K is not zero, all members with a different number of type parameters
are removed. When K is zero, methods having type parameters are not removed,
since the type inference process ( §12.6.3 ) might be able to infer the type
arguments.
Next, if the member is invoked, all non-invocable members are removed from the
set.
Next, members that are hidden by other members are removed from the set. For
every member S.M in the set, where S is the type in which the member  M is
declared, the following rules are applied:
If M is a constant, field, property, event, or enumeration member, then all
members declared in a base type of S are removed from the set.
If M is a type declaration, then all non-types declared in a base type of  S are
removed from the set, and all type declarations with the same number of type
parameters as  M declared in a base type of  S are removed from the set.
If M is a method, then all non-method members declared in a base type of S
are removed from the set.
Next, interface members that are hidden by class members are removed from the
set. This step only has an effect if T is a type parameter and T has both an
effective base class other than object and a non-empty effective interface set
(§15.2.5 ). For every member S.M in the set, where S is the type in which the
member M is declared, the following rules are applied if S is a class declaration
other than object:
If M is a constant, field, property, event, enumeration member, or type
declaration, then all members declared in an interface declaration are removed
from the set.
If M is a method, then all non-method members declared in an interface
declaration are removed from the set, and all methods with the same signature
as M declared in an interface declaration are removed from the set.
Finally, having removed hidden members, the result of the lookup is determined:
If the set consists of a single member that is not a method, then this member is
the result of the lookup.
Otherwise, if the set contains only methods, then this group of methods is the
result of the lookup.
Otherwise, the lookup is ambiguous, and a binding-time error occurs.For member lookups in types other than type parameters and interfaces, and member
lookups in interfaces that are strictly single-inheritance (each interface in the inheritance
chain has exactly zero or one direct base interface), the effect of the lookup rules is
simply that derived members hide base members with the same name or signature.
Such single-inheritance lookups are never ambiguous. The ambiguities that can possibly
arise from member lookups in multiple-inheritance interfaces are described in §18.4.6 .
Note: This phase only accounts for one kind of ambiguity. If the member lookup
results in a method group, further uses of method group may fail due to ambiguity,
for example as described in §12.6.4.1  and §12.6.6.2 . end not e
For purposes of member lookup, a type  T is considered to have the following base
types:
If T is object or dynamic, then T has no base type.
If T is an enum_type , the base types of T are the class types System.Enum,
System.ValueType, and object.
If T is a struct_type , the base types of T are the class types System.ValueType and
object.
Note: A nullable_v alue_type  is a struct_type  (§8.3.1 ). end not e
If T is a class_type , the base types of T are the base classes of  T, including the
class type object.
If T is an interface_type , the base types of T are the base interfaces of T and the
class type object.
If T is an array_type , the base types of T are the class types System.Array and
object.
If T is a delegat e_type , the base types of T are the class types System.Delegate and
object.
Function members are members that contain executable statements. Function members
are always members of types and cannot be members of namespaces. C# defines the12.5.2 Base types
12.6 Function members
12.6.1 Generalfollowing categories of function members:
Methods
Properties
Events
Indexers
User-defined operators
Instance constructors
Static constructors
Finalizers
Except for finalizers and static constructors (which cannot be invoked explicitly), the
statements contained in function members are executed through function member
invocations. The actual syntax for writing a function member invocation depends on the
particular function member category.
The argument list ( §12.6.2 ) of a function member invocation provides actual values or
variable references for the parameters of the function member.
Invocations of generic methods may employ type inference to determine the set of type
arguments to pass to the method. This process is described in §12.6.3 .
Invocations of methods, indexers, operators, and instance constructors employ overload
resolution to determine which of a candidate set of function members to invoke. This
process is described in §12.6.4 .
Once a particular function member has been identified at binding-time, possibly
through overload resolution, the actual run-time process of invoking the function
member is described in §12.6.6 .
Note: The following table summarizes the processing that takes place in constructs
involving the six categories of function members that can be explicitly invoked. In
the table, e, x, y, and value indicate expressions classified as variables or values, T
indicates an expression classified as a type, F is the simple name of a method, and
P is the simple name of a property.
Constr uct Example Descr iption
Method
invocationF(x, y) Overload resolution is applied to select the best method F in
the containing class or struct. The method is invoked with the
argument list (x, y). If the method is not static, the
instance expression is this.
T.F(x, y)Overload resolution is applied to select the best method F in
the class or struct  T. A binding-time error occurs if themethod is not static. The method is invoked with the
argument list (x, y).
e.F(x, y)Overload resolution is applied to select the best method F in
the class, struct, or interface given by the type of e. A binding-
time error occurs if the method is static. The method is
invoked with the instance expression e and the argument list
(x, y).
Property
accessP The get accessor of the property P in the containing class or
struct is invoked. A compile-time error occurs if P is write-
only. If P is not static, the instance expression is this.
P = valueThe set accessor of the property P in the containing class or
struct is invoked with the argument list (value). A compile-
time error occurs if P is read-only. If P is not static, the
instance expression is this.
T.P The get accessor of the property P in the class or struct T is
invoked. A compile-time error occurs if P is not static or if P
is write-only.
T.P =
valueThe set accessor of the property P in the class or struct T is
invoked with the argument list (value). A compile-time error
occurs if P is not static or if P is read-only.
e.P The get accessor of the property P in the class, struct, or
interface given by the type of E is invoked with the instance
expression e. A binding-time error occurs if P is static or if
P is write-only.
e.P =
valueThe set accessor of the property P in the class, struct, or
interface given by the type of E is invoked with the instance
expression e and the argument list (value). A binding-time
error occurs if P is static or if P is read-only.
Event access E +=
valueThe add accessor of the event E in the containing class or
struct is invoked. If E is not static, the instance expression is
this.
E -=
valueThe remove accessor of the event E in the containing class or
struct is invoked. If E is not static, the instance expression is
this.
T.E +=
valueThe add accessor of the event E in the class or struct T is
invoked. A binding-time error occurs if E is not static.
T.E -=
valueThe remove accessor of the event E in the class or struct T is
invoked. A binding-time error occurs if E is not static.e.E +=
valueThe add accessor of the event E in the class, struct, or
interface given by the type of E is invoked with the instance
expression e. A binding-time error occurs if E is static.
e.E -=
valueThe remove accessor of the event E in the class, struct, or
interface given by the type of E is invoked with the instance
expression e. A binding-time error occurs if E is static.
Indexer access e[x, y] Overload resolution is applied to select the best indexer in the
class, struct, or interface given by the type of e. The get
accessor of the indexer is invoked with the instance expression
e and the argument list (x, y). A binding-time error occurs if
the indexer is write-only.
e[x, y] =
valueOverload resolution is applied to select the best indexer in the
class, struct, or interface given by the type of e. The set
accessor of the indexer is invoked with the instance expression
e and the argument list (x, y, value). A binding-time error
occurs if the indexer is read-only.
Operator
invocation-x Overload resolution is applied to select the best unary
operator in the class or struct given by the type of x. The
selected operator is invoked with the argument list (x).
x + y Overload resolution is applied to select the best binary
operator in the classes or structs given by the types of x and
y. The selected operator is invoked with the argument list
(x, y).
Instance
constructor
invocationnew T(x,
y)Overload resolution is applied to select the best instance
constructor in the class or struct  T. The instance constructor is
invoked with the argument list (x, y).
end not e
Every function member and delegate invocation includes an argument list, which
provides actual values or variable references for the parameters of the function member.
The syntax for specifying the argument list of a function member invocation depends on
the function member category:
For instance constructors, methods, indexers and delegates, the arguments are
specified as an argument_list , as described below. For indexers, when invoking the12.6.2 Argument lists
12.6.2.1 Generalset accessor, the argument list additionally includes the expression specified as the
right operand of the assignment operator.
Note: This additional argument is not used for overload resolution, just during
invocation of the set accessor. end not e
For properties, the argument list is empty when invoking the get accessor, and
consists of the expression specified as the right operand of the assignment
operator when invoking the set accessor.
For events, the argument list consists of the expression specified as the right
operand of the += or -= operator.
For user-defined operators, the argument list consists of the single operand of the
unary operator or the two operands of the binary operator.
The arguments of properties ( §15.7 ) and events ( §15.8 ) are always passed as value
parameters ( §15.6.2.2 ). The arguments of user-defined operators ( §15.10 ) are always
passed as value parameters ( §15.6.2.2 ) or input parameters ( §9.2.8 ). The arguments of
indexers ( §15.9 ) are always passed as value parameters ( §15.6.2.2 ), input parameters
(§9.2.8 ), or parameter arrays ( §15.6.2.6 ). Output and reference parameters are not
supported for these categories of function members.
The arguments of an instance constructor, method, indexer, or delegate invocation are
specified as an argument_list :
ANTLR
An argument_list  consists of one or more argument s, separated by commas. Each
argument consists of an optional argument_name  followed by an argument_v alue. Anargument_list
: argument ( ',' argument)</em>
;
argument
: argument_name? argument_value
;
argument_name
: identifier ':'
;
argument_value
: expression
| 'in' variable_reference
| 'ref' variable_reference
| 'out' variable_reference
;argument  with an argument_name  is referred to as a named ar gument , whereas an
argument  without an argument_name  is a positional ar gument .
The argument_v alue can take one of the following forms:
An expression , indicating that the argument is passed as a value parameter or is
transformed into an input parameter and then passed as that, as determined by
(§12.6.4.2  and described in §12.6.2.3 .
The keyword in followed by a variable_r eference (§9.5), indicating that the
argument is passed as an input parameter ( §15.6.2.3 ). A variable shall be definitely
assigned ( §9.4) before it can be passed as an input parameter.
The keyword ref followed by a variable_r eference (§9.5), indicating that the
argument is passed as a reference parameter ( §15.6.2.4 ). A variable shall be
definitely assigned ( §9.4) before it can be passed as a reference parameter.
The keyword out followed by a variable_r eference (§9.5), indicating that the
argument is passed as an output parameter ( §15.6.2.5 ). A variable is considered
definitely assigned ( §9.4) following a function member invocation in which the
variable is passed as an output parameter.
The form determines the paramet er-passing mode  of the argument: value, input ,
reference, or output , respectively. However, as mentioned above, an argument with value
passing mode, might be transformed into one with input passing mode.
Passing a volatile field ( §15.5.4 ) as an input, output, or reference parameter causes a
warning, since the field may not be treated as volatile by the invoked method.
For each argument in an argument list there has to be a corresponding parameter in the
function member or delegate being invoked.
The parameter list used in the following is determined as follows:
For virtual methods and indexers defined in classes, the parameter list is picked
from the first declaration or override of the function member found when starting
with the static type of the receiver, and searching through its base classes.
For partial methods, the parameter list of the defining partial method declaration is
used.
For all other function members and delegates there is only a single parameter list,
which is the one used.
The position of an argument or parameter is defined as the number of arguments or
parameters preceding it in the argument list or parameter list.12.6.2.2 Corresponding parametersThe corresponding parameters for function member arguments are established as
follows:
Arguments in the argument_list  of instance constructors, methods, indexers and
delegates:
A positional argument where a parameter occurs at the same position in the
parameter list corresponds to that parameter, unless the parameter is a
parameter array and the function member is invoked in its expanded form.
A positional argument of a function member with a parameter array invoked in
its expanded form, which occurs at or after the position of the parameter array
in the parameter list, corresponds to an element in the parameter array.
A named argument corresponds to the parameter of the same name in the
parameter list.
For indexers, when invoking the set accessor, the expression specified as the
right operand of the assignment operator corresponds to the implicit value
parameter of the set accessor declaration.
For properties, when invoking the get accessor there are no arguments. When
invoking the set accessor, the expression specified as the right operand of the
assignment operator corresponds to the implicit value parameter of the set
accessor declaration.
For user-defined unary operators (including conversions), the single operand
corresponds to the single parameter of the operator declaration.
For user-defined binary operators, the left operand corresponds to the first
parameter, and the right operand corresponds to the second parameter of the
operator declaration.
An unnamed argument corresponds to no parameter when it is after an out-of-
position named argument or a named argument that corresponds to a parameter
array.
Note: This prevents void M(bool a = true, bool b = true, bool c = true);
being invoked by M(c: false, valueB);. The first argument is used out-of-
position (the argument is used in first position, but the parameter named c is
in third position), so the following arguments should be named. In other
words, non-trailing named arguments are only allowed when the name and
the position result in finding the same corresponding parameter. end not e
During the run-time processing of a function member invocation ( §12.6.6 ), the
expressions or variable references of an argument list are evaluated in order, from left to
right, as follows:12.6.2.3 Run-time evaluation of argument listsFor a value argument, if the parameter’s passing mode is value
the argument expression is evaluated and an implicit conversion ( §10.2 ) to the
corresponding parameter type is performed. The resulting value becomes the
initial value of the value parameter in the function member invocation.
otherwise, the parameter’s passing mode is input. If the argument is a variable
reference and there exists an identity conversion ( §10.2.2 ) between the
argument’s type and the parameter’s type, the resulting storage location
becomes the storage location represented by the parameter in the function
member invocation. Otherwise, a storage location is created with the same type
as that of the corresponding parameter. The argument expression is evaluated
and an implicit conversion ( §10.2 ) to the corresponding parameter type is
performed. The resulting value is stored within that storage location. That
storage location is represented by the input parameter in the function member
invocation.
Example : Given the following declarations and method calls:
C#
In the M1(i) method call, i itself is passed as an input argument, because it
is classified as a variable and has the same type int as the input parameter.
In the M1(i + 5) method call, an unnamed int variable is created,
initialized with the argument’s value, and then passed as an input argument.
See §12.6.4.2  and §12.6.4.4 .
end ex ample
For an input, output, or reference argument, the variable reference is evaluated
and the resulting storage location becomes the storage location represented by
the parameter in the function member invocation. For an input or reference
argument, the variable shall be definitely assigned at the point of the method call.
If the variable reference is given as an output argument, or is an array element of a
reference_type , a run-time check is performed to ensure that the element type of
the array is identical to the type of the parameter. If this check fails, a
System.ArrayTypeMismatchException is thrown.static void M1(in int p1) { ... }
int i = 10;
M1(i);         // i is passed as an input argument
M1(i + 5);     // transformed to a temporary input argumentNote: this run-time check is required due to array covariance ( §17.6 ). end not e
Example : In the following code
C#
the second invocation of F causes a System.ArrayTypeMismatchException to be
thrown because the actual element type of b is string and not object.
end ex ample
Methods, indexers, and instance constructors may declare their right-most parameter to
be a parameter array ( §15.6.2.6 ). Such function members are invoked either in their
normal form or in their expanded form depending on which is applicable ( §12.6.4.2 ):
When a function member with a parameter array is invoked in its normal form, the
argument given for the parameter array shall be a single expression that is
implicitly convertible ( §10.2 ) to the parameter array type. In this case, the
parameter array acts precisely like a value parameter.
When a function member with a parameter array is invoked in its expanded form,
the invocation shall specify zero or more positional arguments for the parameter
array, where each argument is an expression that is implicitly convertible ( §10.2 ) to
the element type of the parameter array. In this case, the invocation creates an
instance of the parameter array type with a length corresponding to the number of
arguments, initializes the elements of the array instance with the given argument
values, and uses the newly created array instance as the actual argument.
The expressions of an argument list are always evaluated in textual order.
Example : Thus, the example
C#class Test
{
static void F(ref object x) {...}
static void Main()
{
object[] a = new object[10];
object[] b = new string[10];
F(ref a[0]); // Ok
F(ref b[1]); // ArrayTypeMismatchException
}
}produces the output
Console
end ex ample
When a function member with a parameter array is invoked in its expanded form with at
least one expanded argument, the invocation is processed as if an array creation
expression with an array initializer ( §12.8.16.5 ) was inserted around the expanded
arguments. An empty array is passed when there are no arguments for the parameter
array; it is unspecified whether the reference passed is to a newly allocated or existing
empty array.
Example : Given the declaration
C#
the following invocations of the expanded form of the method
C#
correspond exactly toclass Test
{
static void F(int x, int y = -1, int z = -2) =&gt;
Console.WriteLine( $&quot;x = {x}, y = {y}, z = {z}&quot;);
static void Main()
{
int i = 0;
F(i++, i++, i++);
F(z: i++, x: i++);
}
}
x = 0, y = 1, z = 2
x = 4, y = -1, z = 3
void F(int x, int y, params object[] args);
F(10, 20, 30, 40);
F(10, 20, 1, &quot;hello&quot;, 3.0);C#
end ex ample
When arguments are omitted from a function member with corresponding optional
parameters, the default arguments of the function member declaration are implicitly
passed. (This can involve the creation of a storage location, as described above.)
Note: Because these are always constant, their evaluation will not impact the
evaluation of the remaining arguments. end not e
When a generic method is called without specifying type arguments, a type infer ence
process attempts to infer type arguments for the call. The presence of type inference
allows a more convenient syntax to be used for calling a generic method, and allows the
programmer to avoid specifying redundant type information.
Example :
C#F(10, 20, new object[] { 30, 40 });
F(10, 20, new object[] { 1, &quot;hello&quot;, 3.0 });
12.6.3 Type inference
12.6.3.1 General
class Chooser
{
static Random rand = new Random();
public static T Choose<T>(T first, T second) =&gt;
rand.Next( 2) == 0 ? first : second;
}
class A
{
static void M()
{
int i = Chooser.Choose( 5, 213); // Calls Choose<int>
string s = Chooser.Choose( &quot;apple&quot;, &quot;banana&quot; ); // Calls<br />
Choose<string>
}
}Through type inference, the type arguments int and string are determined from
the arguments to the method.
end ex ample
Type inference occurs as part of the binding-time processing of a method invocation
(§12.8.9.2 ) and takes place before the overload resolution step of the invocation. When a
particular method group is specified in a method invocation, and no type arguments are
specified as part of the method invocation, type inference is applied to each generic
method in the method group. If type inference succeeds, then the inferred type
arguments are used to determine the types of arguments for subsequent overload
resolution. If overload resolution chooses a generic method as the one to invoke, then
the inferred type arguments are used as the type arguments for the invocation. If type
inference for a particular method fails, that method does not participate in overload
resolution. The failure of type inference, in and of itself, does not cause a binding-time
error. However, it often leads to a binding-time error when overload resolution then fails
to find any applicable methods.
If each supplied argument does not correspond to exactly one parameter in the method
(§12.6.2.2 ), or there is a non-optional parameter with no corresponding argument, then
inference immediately fails. Otherwise, assume that the generic method has the
following signature:
Tₑ M&lt;X₁...Xᵥ&gt;(T₁ p₁ ... Tₓ pₓ)
With a method call of the form M(E₁ ...Eₓ) the task of type inference is to find unique
type arguments S₁...Sᵥ for each of the type parameters X₁...Xᵥ so that the call
M&lt;S₁...Sᵥ&gt;(E₁...Eₓ) becomes valid.
The process of type inference is described below as an algorithm. A conformant
compiler may be implemented using an alternative approach, provided it reaches the
same result in all cases.
During the process of inference each type parameter  Xᵢ is either fixed to a particular
type Sᵢ or unfixed with an associated set of bounds.  Each of the bounds is some type  T.
Initially each type variable  Xᵢ is unfixed with an empty set of bounds.
Type inference takes place in phases. Each phase will try to infer type arguments for
more type variables based on the findings of the previous phase. The first phase makes
some initial inferences of bounds, whereas the second phase fixes type variables to
specific types and infers further bounds. The second phase may have to be repeated a
number of times.Note: Type inference is also used in other contexts including for conversion of
method groups ( §12.6.3.14 ) and finding the best common type of a set of
expressions ( §12.6.3.15 ). end not e
For each of the method arguments  Eᵢ:
If Eᵢ is an anonymous function, an explicit p aramet er type infer ence (§12.6.3.8 ) is
made from Eᵢ to Tᵢ
Otherwise, if  Eᵢ has a type  U and the corresponding parameter is a value
parameter ( §15.6.2.2 ) then a lower-bound infer ence (§12.6.3.10 ) is made from U
to Tᵢ.
Otherwise, if  Eᵢ has a type  U and the corresponding parameter is a reference
parameter ( §15.6.2.4 ), or output parameter ( §15.6.2.5 ) then an exact infer ence
(§12.6.3.9 ) is made from U to Tᵢ.
Otherwise, if  Eᵢ has a type  U and the corresponding parameter is an input
parameter ( §15.6.2.3 ) and Eᵢ is an input argument, then an exact infer ence
(§12.6.3.9 ) is made from U to Tᵢ.
Otherwise, if  Eᵢ has a type  U and the corresponding parameter is an input
parameter ( §15.6.2.3 ) then a lower bound infer ence (§12.6.3.10 ) is made from U
to Tᵢ.
Otherwise, no inference is made for this argument.
The second phase proceeds as follows:
All unfixed type variables  Xᵢ which do not depend on  (§12.6.3.6 ) any Xₑ are fixed
(§12.6.3.12 ).
If no such type variables exist, all unfixed type variables  Xᵢ are fixed for which all of
the following hold:
There is at least one type variable  Xₑ that depends on  Xᵢ
Xᵢ has a non-empty set of bounds
If no such type variables exist and there are still unfixed type variables, type
inference fails.
Otherwise, if no further unfixed type variables exist, type inference succeeds.
Otherwise, for all arguments  Eᵢ with corresponding parameter type  Tᵢ where the
output types  (§12.6.3.5 ) contain unfixed type variables  Xₑ but the input types12.6.3.2 The first phase
12.6.3.3 The second phase(§12.6.3.4 ) do not, an output type infer ence (§12.6.3.7 ) is made from Eᵢ to Tᵢ. Then
the second phase is repeated.
If E is a method group or implicitly typed anonymous function and T is a delegate type
or expression tree type then all the parameter types of  T are input types o f E with
type T.
If E is a method group or an anonymous function and  T is a delegate type or
expression tree type then the return type of  T is an output type o f E with type  T.
An unfixed type variable  Xᵢ depends dir ectly on  an unfixed type variable  Xₑ if for some
argument  Eᵥ with type  Tᵥ Xₑ occurs in an input type  of Eᵥ with type  Tᵥ and Xᵢ occurs
in an output type  of Eᵥ with type  Tᵥ.
Xₑ depends on  Xᵢ if Xₑ depends dir ectly on  Xᵢ or if Xᵢ depends dir ectly on  Xᵥ and Xᵥ
depends on  Xₑ. Thus “ depends on ” is the transitive but not reflexive closure of “ depends
directly on ”.
An output type infer ence is made from an expression  E to a type T in the following way:
If E is an anonymous function with inferred return type  U (§12.6.3.13 ) and T is a
delegate type or expression tree type with return type  Tₓ, then a lower-bound
inference (§12.6.3.10 ) is made from U to Tₓ.
Otherwise, if  E is a method group and  T is a delegate type or expression tree type
with parameter types T₁...Tᵥ and return type  Tₓ, and overload resolution of  E
with the types T₁...Tᵥ yields a single method with return type  U, then a lower-
bound infer ence is made from U to Tₓ.
Otherwise, if  E is an expression with type  U, then a lower-bound infer ence is made
from U to T.
Otherwise, no inferences are made.12.6.3.4 Input types
12.6.3.5 Output types
12.6.3.6 Dependence
12.6.3.7 Output type inferencesAn explicit p aramet er type infer ence is made from an expression  E to a type T in the
following way:
If E is an explicitly typed anonymous function with parameter types U₁...Uᵥ and
T is a delegate type or expression tree type with parameter types V₁...Vᵥ then for
each Uᵢ an exact infer ence (§12.6.3.9 ) is made from Uᵢ to the corresponding  Vᵢ.
An exact infer ence from a type U to a type V is made as follows:
If V is one of the unfixed Xᵢ then U is added to the set of exact bounds for  Xᵢ.
Otherwise, sets V₁...Vₑ and U₁...Uₑ are determined by checking if any of the
following cases apply:
V is an array type V₁[...] and U is an array type U₁[...] of the same rank
V is the type  V₁? and U is the type  U₁
V is a constructed type C&lt;V₁...Vₑ&gt; and U is a constructed type C&lt;U₁...Uₑ&gt;
If any of these cases apply then an exact infer ence is made from each  Uᵢ to the
corresponding  Vᵢ.
Otherwise, no inferences are made.
A lower-bound infer ence from a type U to a type V is made as follows:
If V is one of the unfixed Xᵢ then U is added to the set of lower bounds for  Xᵢ.
Otherwise, if  V is the type  V₁? and U is the type  U₁? then a lower bound inference
is made from  U₁ to V₁.
Otherwise, sets U₁...Uₑ and V₁...Vₑ are determined by checking if any of the
following cases apply:
V is an array type V₁[...]and U is an array type U₁[...]of the same rank
V is one of IEnumerable&lt;V₁&gt;, ICollection&lt;V₁&gt;, IReadOnlyList&lt;V₁&gt;&gt;,
IReadOnlyCollection&lt;V₁&gt; or IList&lt;V₁&gt; and U is a single-dimensional array type
U₁[]
V is a constructed class, struct, interface or delegate type C&lt;V₁...Vₑ&gt; and
there is a unique type C&lt;U₁...Uₑ&gt; such that  U (or, if U is a type parameter, its
effective base class or any member of its effective interface set) is identical to,12.6.3.8 Explicit parameter type inferences
12.6.3.9 Exact inferences
12.6.3.10 Lower-bound inferencesinherits from (directly or indirectly), or implements (directly or indirectly)
C&lt;U₁...Uₑ&gt;.
(The “uniqueness” restriction means that in the case interface C<T>{} class U:
C<X>, C<Y>{}, then no inference is made when inferring from  U to C<T>
because  U₁ could be  X or Y.)
If any of these cases apply then an inference is made from each  Uᵢ to the
corresponding  Vᵢ as follows:
If Uᵢ is not known to be a reference type then an exact infer ence is made
Otherwise, if  U is an array type then a lower-bound infer ence is made
Otherwise, if V is C&lt;V₁...Vₑ&gt; then inference depends on the i-th type
parameter of  C:
If it is covariant then a lower-bound infer ence is made.
If it is contravariant then an upper -bound infer ence is made.
If it is invariant then an exact infer ence is made.
Otherwise, no inferences are made.
An upper -bound infer ence from a type U to a type V is made as follows:
If V is one of the unfixed Xᵢ then U is added to the set of upper bounds for  Xᵢ.
Otherwise, sets V₁...Vₑ and U₁...Uₑ are determined by checking if any of the
following cases apply:
U is an array type U₁[...]and V is an array type V₁[...]of the same rank
U is one of IEnumerable&lt;Uₑ&gt;, ICollection&lt;Uₑ&gt;, IReadOnlyList&lt;Uₑ&gt;,
IReadOnlyCollection&lt;Uₑ&gt; or IList&lt;Uₑ&gt; and V is a single-dimensional array type
Vₑ[]
U is the type U1? and V is the type  V1?
U is constructed class, struct, interface or delegate type C&lt;U₁...Uₑ&gt; and V is a
class, struct, interface or delegate type which is identical to, inherits
from (directly or indirectly), or implements (directly or indirectly) a unique type
C&lt;V₁...Vₑ&gt;
(The “uniqueness” restriction means that given an interface C<T>{} class V<Z>:
C&lt;X<Z>&gt;, C&lt;Y<Z>&gt;{}, then no inference is made when inferring from C&lt;U₁&gt; to
V<Q>. Inferences are not made from  U₁ to either X<Q> or Y<Q>.)
If any of these cases apply then an inference is made from each  Uᵢ to the
corresponding  Vᵢ as follows:
If Uᵢ is not known to be a reference type then an exact infer ence is made
Otherwise, if  V is an array type then an upper -bound infer ence is made12.6.3.11 Upper-bound inferencesOtherwise, if  U is C&lt;U₁...Uₑ&gt; then inference depends on the  i-th type
parameter of  C:
If it is covariant then an upper -bound infer ence is made.
If it is contravariant then a lower-bound infer ence is made.
If it is invariant then an exact infer ence is made.
Otherwise, no inferences are made.
An unfixed type variable  Xᵢ with a set of bounds is fixed as follows:
The set of candidat e types  Uₑ starts out as the set of all types in the set of bounds
for Xᵢ.
Each bound for  Xᵢ is examined in turn: For each exact bound U of  Xᵢ all types  Uₑ
that are not identical to  U are removed from the candidate set. For each lower
bound U of Xᵢ all types  Uₑ to which there is not an implicit conversion from  U are
removed from the candidate set. For each upper-bound U of  Xᵢ all types  Uₑ from
which there is not an implicit conversion to  U are removed from the candidate set.
If among the remaining candidate types  Uₑ there is a unique type  V to which
there is an implicit conversion from all the other candidate types, then  Xᵢ is fixed
to V.
Otherwise, type inference fails.
The inferred return type of an anonymous function  F is used during type inference and
overload resolution. The inferred return type can only be determined for an anonymous
function where all parameter types are known, either because they are explicitly given,
provided through an anonymous function conversion or inferred during type inference
on an enclosing generic method invocation.
The inferr ed ef fectiv e return type  is determined as follows:
If the body of  F is an expression  that has a type, then the inferred effective return
type of  F is the type of that expression.
If the body of  F is a block  and the set of expressions in the block’s return
statements has a best common type  T (§12.6.3.15 ), then the inferred effective
return type of  F is T.
Otherwise, an effective return type cannot be inferred for  F.12.6.3.12 Fixing
12.6.3.13 Inferred return typeThe inferr ed return type  is determined as follows:
If F is async and the body of  F is either an expression classified as nothing ( §12.2 ),
or a block where no return statements have expressions, the inferred return type
is «TaskType» (§15.15.1 ).
If F is async and has an inferred effective return type  T, the inferred return type is
«TaskType»<T>»(§15.15.1 ).
If F is non-async and has an inferred effective return type  T, the inferred return
type is T.
Otherwise, a return type cannot be inferred for  F.
Example : As an example of type inference involving anonymous functions, consider
the Select extension method declared in the System.Linq.Enumerable class:
C#
Assuming the System.Linq namespace was imported with a using namespace
directive, and given a class Customer with a Name property of type string, the
Select method can be used to select the names of a list of customers:
C#
The extension method invocation ( §12.8.9.3 ) of Select is processed by rewriting the
invocation to a static method invocation:
C#namespace  System.Linq
{
public static class Enumerable
{
public static IEnumerable<TResult> Select&lt;TSource,TResult&gt;(
this IEnumerable<TSource> source,
Func&lt;TSource,TResult&gt; selector)
{
foreach (TSource element in source)
{
yield return selector (element);
}
}
}
}
List<Customer> customers = GetCustomerList();
IEnumerable&lt; string&gt; names = customers.Select(c =&gt; c.Name);Since type arguments were not explicitly specified, type inference is used to infer the
type arguments. First, the customers argument is related to the source parameter,
inferring TSource to be Customer. Then, using the anonymous function type
inference process described above, c is given type Customer, and the
expression  c.Name is related to the return type of the selector parameter, inferring
TResult to be string. Thus, the invocation is equivalent to
C#
and the result is of type IEnumerable<string>.
The following example demonstrates how anonymous function type inference
allows type information to “flow” between arguments in a generic method
invocation. Given the following method and invocation:
C#
type inference for the invocation proceeds as follows: First, the argument “1:15:30” is
related to the value parameter, inferring X to be string. Then, the parameter of the
first anonymous function, s, is given the inferred type string, and the expression
TimeSpan.Parse(s) is related to the return type of  f1, inferring Y to be
System.TimeSpan. Finally, the parameter of the second anonymous function, t, is
given the inferred type System.TimeSpan, and the expression  t.TotalHours is related
to the return type of  f2, inferring  Z to be double. Thus, the result of the invocation
is of type double.IEnumerable&lt; string&gt; names = Enumerable.Select(customers, c =&gt; c.Name);
Sequence.Select&lt;Customer, string&gt;(customers, (Customer c) =&gt; c.Name)
class A
{
static Z F&lt;X,Y,Z&gt;(X value, Func&lt;X,Y&gt; f1, Func&lt;Y,Z&gt; f2)
{
return f2(f1(value));
}
static void M()
{
double hours = F( &quot;1:15:30&quot; , s =&gt; TimeSpan.Parse(s), t =&gt;<br />
t.TotalHours);
}
}end ex ample
Similar to calls of generic methods, type inference shall also be applied when a method
group M containing a generic method is converted to a given delegate type  D (§10.8 ).
Given a method
Tₑ M&lt;X₁...Xᵥ&gt;(T₁ x₁ ... Tₑ xₑ)
and the method group  M being assigned to the delegate type  D the task of type
inference is to find type arguments S₁...Sᵥ so that the expression:
M&lt;S₁...Sᵥ&gt;
becomes compatible ( §20.2 ) with D.
Unlike the type inference algorithm for generic method calls, in this case, there are only
argument types , no argument expressions . In particular, there are no anonymous
functions and hence no need for multiple phases of inference.
Instead, all  Xᵢ are considered unfixed, and a lower-bound infer ence is made from each
argument type  Uₑ of D to the corresponding parameter type  Tₑ of M. If for any of
the Xᵢ no bounds were found, type inference fails. Otherwise, all  Xᵢ are fixed to
corresponding  Sᵢ, which are the result of type inference.
In some cases, a common type needs to be inferred for a set of expressions. In
particular, the element types of implicitly typed arrays and the return types of
anonymous functions with block  bodies are found in this way.
The best common type for a set of expressions E₁...Eᵥ is determined as follows:
A new unfixed type variable X is introduced.
For each expression Ei an output type infer ence (§12.6.3.7 ) is performed from it to
X.
X is fixed (§12.6.3.12 ), if possible, and the resulting type is the best common type.
Otherwise inference fails.
Note: Intuitively this inference is equivalent to calling a method void M<X>(X x₁ ...
X xᵥ) with the Eᵢ as arguments and inferring  X. end not e12.6.3.14 Type inference for conversion of method groups
12.6.3.15 Finding the best common type of a set of expressionsOverload resolution is a binding-time mechanism for selecting the best function
member to invoke given an argument list and a set of candidate function members.
Overload resolution selects the function member to invoke in the following distinct
contexts within C#:
Invocation of a method named in an invocation_expr ession  (§12.8.9 ).
Invocation of an instance constructor named in an object_cr eation_expr ession
(§12.8.16.2 ).
Invocation of an indexer accessor through an element_ac cess (§12.8.11 ).
Invocation of a predefined or user-defined operator referenced in an expression
(§12.4.4  and §12.4.5 ).
Each of these contexts defines the set of candidate function members and the list of
arguments in its own unique way. For instance, the set of candidates for a method
invocation does not include methods marked override ( §12.5 ), and methods in a base
class are not candidates if any method in a derived class is applicable ( §12.8.9.2 ).
Once the candidate function members and the argument list have been identified, the
selection of the best function member is the same in all cases:
First, the set of candidate function members is reduced to those function members
that are applicable with respect to the given argument list ( §12.6.4.2 ). If this
reduced set is empty, a compile-time error occurs.
Then, the best function member from the set of applicable candidate function
members is located. If the set contains only one function member, then that
function member is the best function member. Otherwise, the best function
member is the one function member that is better than all other function members
with respect to the given argument list, provided that each function member is
compared to all other function members using the rules in §12.6.4.3 . If there is not
exactly one function member that is better than all other function members, then
the function member invocation is ambiguous and a binding-time error occurs.
The following subclauses define the exact meanings of the terms applicable f unction
member  and better function member .12.6.4 Overload resolution
12.6.4.1 General
12.6.4.2 Applicable function memberA function member is said to be an applicable f unction member  with respect to an
argument list  A when all of the following are true:
Each argument in  A corresponds to a parameter in the function member
declaration as described in §12.6.2.2 , at most one argument corresponds to each
parameter, and any parameter to which no argument corresponds is an optional
parameter.
For each argument in  A, the parameter-passing mode of the argument is identical
to the parameter-passing mode of the corresponding parameter, and
for a value parameter or a parameter array, an implicit conversion ( §10.2 ) exists
from the argument expression to the type of the corresponding parameter, or
for a ref or out parameter, there is an identity conversion between the type of
the argument expression (if any) and the type of the corresponding parameter,
or
for an in parameter when the corresponding argument has the in modifier,
there is an identity conversion between the type of the argument expression (if
any) and the type of the corresponding parameter, or
for an in parameter when the corresponding argument omits the in modifier,
an implicit conversion ( §10.2 ) exists from the argument expression to the type of
the corresponding parameter.
For a function member that includes a parameter array, if the function member is
applicable by the above rules, it is said to be applicable in its normal for m. If a function
member that includes a parameter array is not applicable in its normal form, the
function member might instead be applicable in its expanded for m:
The expanded form is constructed by replacing the parameter array in the function
member declaration with zero or more value parameters of the element type of
the parameter array such that the number of arguments in the argument list A
matches the total number of parameters. If A has fewer arguments than the
number of fixed parameters in the function member declaration, the expanded
form of the function member cannot be constructed and is thus not applicable.
Otherwise, the expanded form is applicable if for each argument in A, one of the
following is true:
the parameter-passing mode of the argument is identical to the parameter-
passing mode of the corresponding parameter, and
for a fixed value parameter or a value parameter created by the expansion,
an implicit conversion ( §10.2 ) exists from the argument expression to the
type of the corresponding parameter, or
for an in, out, or ref parameter, the type of the argument expression is
identical to the type of the corresponding parameter.the parameter-passing mode of the argument is value, and the parameter-
passing mode of the corresponding parameter is input, and an implicit
conversion ( §10.2 ) exists from the argument expression to the type of the
corresponding parameter
When the implicit conversion from the argument type to the parameter type of an in
parameter is a dynamic implicit conversion ( §10.2.10 ), the results are undefined.
Example : Given the following declarations and method calls:
C#
end ex ample
A static method is only applicable if the method group results from a simple_name
or a member_ac cess through a type.
An instance method is only applicable if the method group results from a
simple_name , a member_ac cess through a variable or value, or a base_access.
If the method group results from a simple_name , an instance method is only
applicable if this access is permitted §12.8.13 .
When the method group results from a member_ac cess which could be via either
an instance or a type as described in §12.8.7.2 , both instance and static methods
are applicable.
A generic method whose type arguments (explicitly specified or inferred) do not all
satisfy their constraints is not applicable.public static void M1(int p1) { ... }
public static void M1(in int p1) { ... }
public static void M2(in int p1) { ... }
public static void Test()
{
int i = 10; uint ui = 34U;
M1(in i);   // M1(in int) is applicable
M1(in ui);  // no exact type match, so M1(in int) is not applicable
M1(i);      // M1(int) and M1(in int) are applicable
M1(i + 5);  // M1(int) and M1(in int) are applicable
M1(100u);   // no implicit conversion exists, so M1(int) is not<br />
applicable
M2(in i);   // M2(in int) is applicable
M2(i);      // M2(in int) is applicable
M2(i + 5);  // M2(in int) is applicable
}In the context of a method group conversion, there shall exist an identity
conversion ( §10.2.2 ) or an implicit reference conversion ( §10.2.8 ) from the method
return type to the delegate’s return type. Otherwise, the candidate method is not
applicable.
For the purposes of determining the better function member, a stripped-down
argument list  A is constructed containing just the argument expressions themselves in
the order they appear in the original argument list, and leaving out any out or ref
arguments.
Parameter lists for each of the candidate function members are constructed in the
following way:
The expanded form is used if the function member was applicable only in the
expanded form.
Optional parameters with no corresponding arguments are removed from the
parameter list
ref and out parameters are removed from the parameter list
The parameters are reordered so that they occur at the same position as the
corresponding argument in the argument list.
Given an argument list  A with a set of argument expressions {E₁, E₂, ..., Eᵥ} and
two applicable function members  Mᵥ and Mₓ with parameter types {P₁, P₂, ..., Pᵥ}
and {Q₁, Q₂, ..., Qᵥ}, Mᵥ is defined to be a better function member  than Mₓ if
for each argument, the implicit conversion from  Eᵥ to Qᵥ is not better than the
implicit conversion from  Eᵥ to Pᵥ, and
for at least one argument, the conversion from  Eᵥ to Pᵥ is better than the
conversion from  Eᵥ to Qᵥ.
In case the parameter type sequences  {P₁, P₂, ..., Pᵥ} and {Q₁, Q₂, ..., Qᵥ} are
equivalent (i.e., each  Pᵢ has an identity conversion to the corresponding  Qᵢ), the
following tie-breaking rules are applied, in order, to determine the better function
member.
If Mᵢ is a non-generic method and  Mₑ is a generic method, then  Mᵢ is better
than Mₑ.
Otherwise, if  Mᵢ is applicable in its normal form and  Mₑ has a params array and is
applicable only in its expanded form, then  Mᵢ is better than  Mₑ.12.6.4.3 Better function memberOtherwise, if both methods have params arrays and are applicable only in their
expanded forms, and if the params array of  Mᵢ has fewer elements than the
params array of  Mₑ, then Mᵢ is better than  Mₑ.
Otherwise, if  Mᵥ has more specific parameter types than  Mₓ, then Mᵥ is better
than Mₓ. Let {R1, R2, ..., Rn} and {S1, S2, ..., Sn} represent the
uninstantiated and unexpanded parameter types of  Mᵥ and Mₓ. Mᵥ’s parameter
types are more specific than  Mₓs if, for each parameter, Rx is not less specific
than Sx, and, for at least one parameter, Rx is more specific than  Sx:
A type parameter is less specific than a non-type parameter.
Recursively, a constructed type is more specific than another constructed
type (with the same number of type arguments) if at least one type argument is
more specific and no type argument is less specific than the corresponding type
argument in the other.
An array type is more specific than another array type (with the same number of
dimensions) if the element type of the first is more specific than the element
type of the second.
Otherwise if one member is a non-lifted operator and the other is a lifted operator,
the non-lifted one is better.
If neither function member was found to be better, and all parameters of  Mᵥ have
a corresponding argument whereas default arguments need to be substituted for
at least one optional parameter in  Mₓ, then Mᵥ is better than  Mₓ.
If for at least one parameter Mᵥ uses the better paramet er-passing choic e
(§12.6.4.4 ) than the corresponding parameter in Mₓ and none of the parameters in
Mₓ use the better parameter-passing choice than Mᵥ, Mᵥ is better than Mₓ.
Otherwise, no function member is better.
It is permitted to have corresponding parameters in two overloaded methods differ only
by parameter-passing mode provided one of the two parameters has value-passing
mode, as follows:
C#
Given int i = 10;, according to §12.6.4.2 , the calls M1(i) and M1(i + 5) result in both
overloads being applicable. In such cases, the method with the parameter-passing mode
of value is the better paramet er-passing mode choic e.12.6.4.4 Better parameter-passing mode
public static void M1(int p1) { ... }
public static void M1(in int p1) { ... }Note: No such choice need exist for arguments of input, output, or reference
passing modes, as those arguments only match the exact same parameter passing
modes. end not e
Given an implicit conversion C₁ that converts from an expression E to a type T₁, and an
implicit conversion C₂ that converts from an expression E to a type T₂, C₁ is a better
conversion than C₂ if one of the following holds:
E exactly matches T₁ and E does not exactly match T₂ (§12.6.4.6 )
E exactly matches both or neither of T₁ and T₂, and T₁ is a better conversion
target than T₂ (§12.6.4.7 )
E is a method group ( §12.2 ), T₁ is compatible ( §20.4 ) with the single best method
from the method group for conversion C₁, and T₂ is not compatible with the
single best method from the method group for conversion C₂
Given an expression E and a type T, E exactly mat ches T if one of the following holds:
E has a type S, and an identity conversion exists from S to T
E is an anonymous function, T is either a delegate type D or an expression tree
type Expression<D> and one of the following holds:
An inferred return type X exists for E in the context of the parameter list of D
(§12.6.3.12 ), and an identity conversion exists from X to the return type of D
E is an async lambda with no return value, and D has a return type which is a
non-generic «TaskType»
Either E is non-async and D has a return type Y or E is async and D has a
return type «TaskType»<Y>(§15.15.1 ), and one of the following holds:
The body of E is an expression that exactly matches Y
The body of E is a block where every return statement returns an expression
that exactly matches Y
Given two types T₁ and T₂, T₁ is a better conversion t arget than T₂ if one of the
following holds:12.6.4.5 Better conversion from expression
12.6.4.6 Exactly matching expression
12.6.4.7 Better conversion targetAn implicit conversion from T₁ to T₂ exists and no implicit conversion from T₂ to
T₁ exists
T₁ is «TaskType»&lt;S₁&gt;(§15.15.1 ), T₂ is «TaskType»&lt;S₂&gt;, and S₁ is a better
conversion target than S₂
T₁ is «TaskType»&lt;S₁&gt;(§15.15.1 ), T₂ is «TaskType»&lt;S₂&gt;, and T₁ is more specialized
than T₂
T₁ is S₁ or S₁? where S₁ is a signed integral type, and T₂ is S₂ or S₂? where S₂
is an unsigned integral type. Specifically:
S₁ is sbyte and S₂ is byte, ushort, uint, or ulong
S₁ is short and S₂ is ushort, uint, or ulong
S₁ is int and S₂ is uint, or ulong
S₁ is long and S₂ is ulong
Note: While signatures as declared shall be unique ( §8.6), it is possible that
substitution of type arguments results in identical signatures. In such a situation,
overload resolution will pick the most specific ( §12.6.4.3 ) of the original signatures
(before substitution of type arguments), if it exists, and otherwise report an error.
end not e
Example : The following examples show overloads that are valid and invalid
according to this rule:
C#12.6.4.8 Overloading in generic classes
public interface  I1<T> { ... }
public interface  I2<T> { ... }
public abstract  class G1<U>
{
public abstract  int F1(U u);           // Overload resolution for<br />
G<int>.F1
public abstract  int F1(int i);         // will pick non-generic
public abstract  void F2(I1<U> a);      // Valid overload
public abstract  void F2(I2<U> a);
}
abstract  class G2&lt;U,V&gt;
{
public abstract  void F3(U u, V v );     // Valid, but overload<br />
resolution for
public abstract  void F3(V v, U u );     // G2&lt;int,int&gt;.F3 will failend ex ample
Even though overload resolution of a dynamically bound operation takes place at run-
time, it is sometimes possible at compile-time to know the list of function members
from which an overload will be chosen:
For a delegate invocation ( §12.8.9.4 ), the list is a single function member with the
same parameter list as the delegat e_type  of the invocation
For a method invocation ( §12.8.9.2 ) on a type, or on a value whose static type is
not dynamic, the set of accessible methods in the method group is known at
compile-time.
For an object creation expression ( §12.8.16.2 ) the set of accessible constructors in
the type is known at compile-time.
For an indexer access ( §12.8.11.3 ) the set of accessible indexers in the receiver is
known at compile-time.
In these cases a limited compile-time check is performed on each member in the known
set of function members, to see if it can be known for certain never to be invoked at
run-time. For each function member  F a modified parameter and argument list are
constructed:
First, if F is a generic method and type arguments were provided, then those are
substituted for the type parameters in the parameter list. However, if type
arguments were not provided, no such substitution happens.
Then, any parameter whose type is open (i.e., contains a type parameter; see
§8.4.3 ) is elided, along with its corresponding parameter(s).
For F to pass the check, all of the following shall hold:    public abstract  void F4(U u, I1<V> v ); // Valid, but overload<br />
resolution for
public abstract  void F4(I1<V> v, U u ); // G2&lt;I1<int>,int&gt;.F4 will<br />
fail
public abstract  void F5(U u1, I1<V> v2 );   // Valid overload
public abstract  void F5(V v1, U u2 );
public abstract  void F6(ref U u);      // Valid overload
public abstract  void F6(out V v);
}
12.6.5 Compile-time checking of dynamic member
invocationThe modified parameter list for  F is applicable to the modified argument list in
terms of §12.6.4.2 .
All constructed types in the modified parameter list satisfy their constraints ( §8.4.5 ).
If the type parameters of  F were substituted in the step above, their constraints
are satisfied.
If F is a static method, the method group shall not have resulted from a
member_ac cess whose receiver is known at compile-time to be a variable or value.
If F is an instance method, the method group shall not have resulted from a
member_ac cess whose receiver is known at compile-time to be a type.
If no candidate passes this test, a compile-time error occurs.
This subclause describes the process that takes place at run-time to invoke a particular
function member. It is assumed that a binding-time process has already determined the
particular member to invoke, possibly by applying overload resolution to a set of
candidate function members.
For purposes of describing the invocation process, function members are divided into
two categories:
Static function members. These are static methods, static property accessors, and
user-defined operators. S tatic function members are always non-virtual.
Instance function members. These are instance methods, instance constructors,
instance property accessors, and indexer accessors. Instance function members are
either non-virtual or virtual, and are always invoked on a particular instance. The
instance is computed by an instance expression, and it becomes accessible within
the function member as this (§12.8.13 ). For an instance constructor, the instance
expression is taken to be the newly allocated object.
The run-time processing of a function member invocation consists of the following
steps, where M is the function member and, if M is an instance member, E is the
instance expression:
If M is a static function member:
The argument list is evaluated as described in §12.6.2 .
M is invoked.
Otherwise, if the type of  E is a value-type  V, and M is declared or overridden in  V:12.6.6 Function member invocation
12.6.6.1 GeneralE is evaluated. If this evaluation causes an exception, then no further steps are
executed. For an instance constructor, this evaluation consists of allocating
storage (typically from an execution stack) for the new object. In this case E is
classified as a variable.
If E is not classified as a variable, or if V is not a readonly struct type ( §16.2.2 ),
and E is one of:
an input parameter ( §15.6.2.3 ), or
a readonly field ( §15.5.3 ), or
a readonly reference variable or return ( §9.7),
then a temporary local variable of E’s type is created and the value of E is
assigned to that variable. E is then reclassified as a reference to that temporary
local variable. The temporary variable is accessible as this within M, but not in any
other way. Thus, only when E can be written is it possible for the caller to observe
the changes that M makes to this.
The argument list is evaluated as described in §12.6.2 .
M is invoked. The variable referenced by E becomes the variable referenced by
this.
Otherwise:
E is evaluated. If this evaluation causes an exception, then no further steps are
executed.
The argument list is evaluated as described in §12.6.2 .
If the type of  E is a value_type , a boxing conversion ( §10.2.9 ) is performed to
convert  E to a  class_type , and E is considered to be of that  class_type  in the
following steps. If the  value_type  is an  enum_type , the  class_type  is System.Enum;
otherwise, it is  System.ValueType.
The value of E is checked to be valid. If the value of E is null, a
System.NullReferenceException is thrown and no further steps are executed.
The function member implementation to invoke is determined:
If the binding-time type of  E is an interface, the function member to invoke
is the implementation of M provided by the run-time type of the instance
referenced by  E. This function member is determined by applying the
interface mapping rules ( §18.6.5 ) to determine the implementation of M
provided by the run-time type of the instance referenced by  E.
Otherwise, if  M is a virtual function member, the function member to invoke
is the implementation of  M provided by the run-time type of the instance
referenced by  E. This function member is determined by applying the rulesfor determining the most derived implementation ( §15.6.4 ) of M with respect
to the run-time type of the instance referenced by  E.
Otherwise, M is a non-virtual function member, and the function member to
invoke is M itself.
The function member implementation determined in the step above is invoked.
The object referenced by E becomes the object referenced by this.
The result of the invocation of an instance constructor ( §12.8.16.2 ) is the value created.
The result of the invocation of any other function member is the value, if any, returned
(§13.10.5 ) from its body.
A function member implemented in a value_type  can be invoked through a boxed
instance of that value_type  in the following situations:
When the function member is an override of a method inherited from type
class_type  and is invoked through an instance expression of that  class_type .
Note: The  class_type  will always be one
of System.Object, System.ValueType or System.Enum. end not e
When the function member is an implementation of an interface function member
and is invoked through an instance expression of an interface_type .
When the function member is invoked through a delegate.
In these situations, the boxed instance is considered to contain a variable of the
value_type , and this variable becomes the variable referenced by this within the function
member invocation.
Note: In particular, this means that when a function member is invoked on a boxed
instance, it is possible for the function member to modify the value contained in the
boxed instance. end not e
Deconstruction is a process whereby an expression gets turned into a tuple of individual
expressions. Deconstruction is used when the target of a simple assignment is a tuple
expression, in order to obtain values to assign to each of that tuple’s elements.12.6.6.2 Invocations on boxed instances
12.7 DeconstructionAn expression E is deconstr ucted to a tuple expression with n elements in the following
way:
If E is a tuple expression with n elements, the result of deconstruction is the
expression E itself.
Otherwise, if E has a tuple type (T1, ..., Tn) with n elements, then E is
evaluated into a temporary variable __v, and the result of deconstruction is the
expression (__v.Item1, ..., __v.Itemn).
Otherwise, if the expression E.Deconstruct(out var __v1, ..., out var __vn)
resolves at compile-time to a unique instance or extension method, that
expression is evaluated, and the result of deconstruction is the expression (__v1,
..., __vn). Such a method is referred to as a deconstr uctor.
Otherwise, E cannot be deconstructed.
Here, __v and __v1, ..., __vn refer to otherwise invisible and inaccessible temporary
variables.
Note: An expression of type dynamic cannot be deconstructed. end not e
Primary expressions include the simplest forms of expressions.
ANTLR12.8 Primary expressions
12.8.1 General
primary_expression
: primary_no_array_creation_expression
| array_creation_expression
;
primary_no_array_creation_expression
: literal
| interpolated_string_expression
| simple_name
| parenthesized_expression
| tuple_expression
| member_access
| null_conditional_member_access
| invocation_expression
| element_access
| null_conditional_element_access
| this_access
| base_accessNote: These grammar rules are not ANTLR-ready as they are part of a set of
mutually left-recursive rules ( primary_expression,
primary_no_array_creation_expression, member_access, invocation_expression,
element_access, post_increment_expression, post_decrement_expression,
pointer_member_access and pointer_element_access) which ANTLR does not handle.
Standard techniques can be used to transform the grammar to remove the mutual
left-recursion. This has not been done as not all parsing strategies require it (e.g. an
LALR parser would not) and doing so would obfuscate the structure and description.
end not e
point er_member_ac cess (§23.6.3 ) and point er_element_ac cess (§23.6.4 ) are only available
in unsafe code ( §23).
Primary expressions are divided between array_cr eation_expr ession s and
primary_no_arr ay_cr eation_expr ession s. Treating array_cr eation_expr ession  in this way,
rather than listing it along with the other simple expression forms, enables the grammar
to disallow potentially confusing code such as
C#
which would otherwise be interpreted as
C#    | post_increment_expression
| post_decrement_expression
| object_creation_expression
| delegate_creation_expression
| anonymous_object_creation_expression
| typeof_expression
| sizeof_expression
| checked_expression
| unchecked_expression
| default_value_expression
| nameof_expression<br />
| anonymous_method_expression
| pointer_member_access     // unsafe code support
| pointer_element_access    // unsafe code support
| stackalloc_expression
;
object o = new int[3][1];
object o = (new int[3])[1];A primary_expr ession  that consists of a literal (§6.4.5 ) is classified as a value.
An interpolat ed_str ing_expr ession  consists of $, $@, or @$, immediately followed by text
within &quot; characters. Within the quoted text there are zero or more interpolations
delimited by { and } characters, each of which encloses an expression  and optional
formatting specifications.
Interpolated string expressions have two forms; regular
(interpolat ed_regular_str ing_expr ession ) and verbatim
(interpolat ed_verbatim_str ing_expr ession ); which are lexically similar to, but differ
semantically from, the two forms of string literals ( §6.4.5.6 ).
ANTLR12.8.2 Literals
12.8.3 Interpolated string expressions
interpolated_string_expression
: interpolated_regular_string_expression
| interpolated_verbatim_string_expression
;
// interpolated regular string expressions
interpolated_regular_string_expression
: Interpolated_Regular_String_Start Interpolated_Regular_String_Mid?
('{' regular_interpolation '}' Interpolated_Regular_String_Mid?)</em>
Interpolated_Regular_String_End
;
regular_interpolation
: expression ( ',' interpolation_minimum_width)?
Regular_Interpolation_Format?
;
interpolation_minimum_width
: constant_expression
;
Interpolated_Regular_String_Start
: '$&quot;'
;
// the following three lexical rules are context sensitive, see details<br />
below
Interpolated_Regular_String_Mid
: Interpolated_Regular_String_Element+    ;
Regular_Interpolation_Format
: ':' Interpolated_Regular_String_Element+
;
Interpolated_Regular_String_End
: '&quot;'
;
fragment  Interpolated_Regular_String_Element
: Interpolated_Regular_String_Character
| Simple_Escape_Sequence
| Hexadecimal_Escape_Sequence
| Unicode_Escape_Sequence
| Open_Brace_Escape_Sequence
| Close_Brace_Escape_Sequence
;
fragment  Interpolated_Regular_String_Character
// Any character except &quot; (U+0022), \ (U+005C),
// { (U+007B), } (U+007D), and New_Line_Character.
: ~[&quot;\{}\u000D\u000A\u0085\u2028\u2029]
;
// interpolated verbatim string expressions
interpolated_verbatim_string_expression
: Interpolated_Verbatim_String_Start Interpolated_Verbatim_String_Mid?
('{' verbatim_interpolation '}' Interpolated_Verbatim_String_Mid?)</em>
Interpolated_Verbatim_String_End
;
verbatim_interpolation
: expression ( ',' interpolation_minimum_width)?
Verbatim_Interpolation_Format?
;
Interpolated_Verbatim_String_Start
: '$@&quot;'
| '@$&quot;'
;
// the following three lexical rules are context sensitive, see details<br />
below
Interpolated_Verbatim_String_Mid
: Interpolated_Verbatim_String_Element+
;
Verbatim_Interpolation_Format
: ':' Interpolated_Verbatim_String_Element+
;
Interpolated_Verbatim_String_EndSix of the lexical rules defined above are context sensitiv e as follows:
Rule Cont extual R equir ements
Interpolat ed_Regular_S tring_Mid Only recognised after an
Interpolat ed_Regular_S tring_S tart, between any following
interpolations, and before the corresponding
Interpolat ed_Regular_S tring_End .
Regular_Int erpolation_For mat Only recognised within a regular_int erpolation  and when
the starting colon (:) is not nested within any kind of
bracket (parentheses/braces/square).
Interpolat ed_Regular_S tring_End Only recognised after an
Interpolat ed_Regular_S tring_S tart and only if any
intervening tokens are either
Interpolat ed_Regular_S tring_Mid s or tokens that can be
part of regular_int erpolation s, including tokens for any
interpolat ed_regular_str ing_expr ession s contained within
such interpolations.
Interpolat ed_Verbatim_S tring_Mid
Verbatim_Int erpolation_For mat
Interpolat ed_Verbatim_S tring_EndRecognition of these three rules follows that of the
corresponding rules above with each mentioned regular
grammar rule replaced by the corresponding verbatim
one.    : '&quot;'
;
fragment  Interpolated_Verbatim_String_Element
: Interpolated_Verbatim_String_Character
| Quote_Escape_Sequence
| Open_Brace_Escape_Sequence
| Close_Brace_Escape_Sequence
;
fragment  Interpolated_Verbatim_String_Character
: ~[&quot;{}]    // Any character except &quot; (U+0022), { (U+007B) and }<br />
(U+007D)
;
// lexical fragments used by both regular and verbatim interpolated strings
fragment  Open_Brace_Escape_Sequence
: '{{'
;
fragment  Close_Brace_Escape_Sequence
: '}}'
;Note: The above rules are context sensitive as their definitions overlap with those of
other tokens in the language. end not e
Note: The above grammar is not ANTLR-ready due to the context sensitive lexical
rules. As with other lexer generators ANTLR supports context sensitive lexical rules,
for example using its lexical modes , but this is an implementation detail and
therefore not part of this specification. end not e
An interpolat ed_str ing_expr ession  is classified as a value. If it is immediately converted to
System.IFormattable or System.FormattableString with an implicit interpolated string
conversion ( §10.2.5 ), the interpolated string expression has that type. Otherwise, it has
the type string.
Note: The differences between the possible types an interpolat ed_str ing_expr ession
may be determined from the documentation for System.String (§C.2) and
System.FormattableString (§C.3). end not e
The meaning of an interpolation, both regular_int erpolation  and verbatim_int erpolation ,
is to format the value of the expression  as a string either according to the format
specified by the Regular_Int erpolation_For mat or Verbatim_Int erpolation_For mat, or
according to a default format for the type of expression . The formatted string is then
modified by the interpolation_minimum_width , if any, to produce the final string to be
interpolated into the interpolat ed_str ing_expr ession .
Note: How the default format for a type is determined is detailed in the
documentation for System.String (§C.2) and System.FormattableString (§C.3).
Descriptions of standard formats, which are identical for
Regular_Int erpolation_For mat and Verbatim_Int erpolation_For mat, may be found in
the documentation for System.IFormattable (§C.4) and in other types in the
standard library ( §C). end not e
In an interpolation_minimum_width  the constant_expr ession  shall have an implicit
conversion to int. Let the field width  be the absolute value of this constant_expr ession
and the alignment  be the sign (positive or negative) of the value of this
constant_expr ession :
If the value of field width is less than or equal to the length of the formatted string
the formatted string is not modified.
Otherwise the formatted string is padded with white space characters so that its
length is equal to field width:If the alignment is positive the formatted string is right-aligned by prepending
the padding,
Otherwise it is left-aligned by appending the padding.
The overall meaning of an interpolat ed_str ing_expr ession , including the above formatting
and padding of interpolations, is defined by a conversion of the expression to a method
invocation: if the type of the expression is System.IFormattable or
System.FormattableString that method is
System.Runtime.CompilerServices.FormattableStringFactory.Create (§C.3) which returns
a value of type System.FormattableString; otherwise the type shall be string and the
method is string.Format (§C.2) which returns a value of type string.
In both cases, the argument list of the call consists of a format str ing lit eral with format
speci fications  for each interpolation, and an argument for each expression
corresponding to the format specifications.
The format string literal is constructed as follows, where N is the number of
interpolations in the interpolat ed_str ing_expr ession . The format string literal consists of,
in order:
The characters of the Interpolat ed_Regular_S tring_S tart or
Interpolat ed_Verbatim_S tring_S tart
The characters of the Interpolat ed_Regular_S tring_Mid  or
Interpolat ed_Verbatim_S tring_Mid , if any
Then if N ≥ 1 for each number I from 0 to N-1:
A placeholder specification:
A left brace ( {) character
The decimal representation of I
Then, if the corresponding regular_int erpolation  or verbatim_int erpolation  has
a interpolation_minimum_width , a comma ( ,) followed by the decimal
representation of the value of the constant_expr ession
The characters of the Regular_Int erpolation_For mat or
Verbatim_Int erpolation_For mat, if any, of the corresponding
regular_int erpolation  or verbatim_int erpolation
A right brace ( }) character
The characters of the Interpolat ed_Regular_S tring_Mid  or
Interpolat ed_Verbatim_S tring_Mid  immediately following the corresponding
interpolation, if any
Finally the characters of the Interpolat ed_Regular_S tring_End  or
Interpolat ed_Verbatim_S tring_End .
The subsequent arguments are the expression s from the interpolations, if any, in order.When an interpolat ed_str ing_expr ession  contains multiple interpolations, the expressions
in those interpolations are evaluated in textual order from the left to right.
Example :
This example uses the following format specification features:
the X format specification which formats integers as uppercase hexadecimal,
the default format for a string value is the value itself,
positive alignment values that right-justify within the specified minimum field
width,
negative alignment values that left-justify within the specified minimum field
width,
defined constants for the interpolation_minimum_width , and
that {{ and }} are formatted as { and } respectively.
Given:
C#
Then:
Interpolat ed String Expr ession Equiv alent Meaning As string Value
$&quot;{text}&quot; string.Format(&quot;{0}&quot;, text) &quot;red&quot;
$&quot;{{text}}&quot; string.Format(&quot;{{text}}) &quot;{text}&quot;
$&quot;{ text , 4 }&quot; string.Format(&quot;{0,4}&quot;, text) &quot; red&quot;
$&quot;{ text , width }&quot; string.Format(&quot;{0,-4}&quot;, text) &quot;red &quot;
$&quot;{number:X}&quot; string.Format(&quot;{0:X}&quot;, number) &quot;E&quot;
$&quot;{text + '?'} {number % 3}&quot;string.Format(&quot;{0} {1}&quot;, text + '?', number %
3)&quot;red? 2&quot;
$&quot;{text + $&quot;[{number}]&quot;}&quot; string.Format(&quot;{0}&quot;, text + string.Format(&quot;
[{0}]&quot;, number))&quot;red[14]&quot;
$&quot;{(number==0?&quot;Zero&quot;:&quot;Non-
zero&quot;)}&quot;string.Format(&quot;{0}&quot;, (number==0?&quot;Zero&quot;:&quot;Non-
zero&quot;))&quot;Non-
zero&quot;string text = &quot;red&quot;;
int number = 14;
const int width = -4;end ex ample
A simple_name  consists of an identifier, optionally followed by a type argument list:
ANTLR
A simple_name  is either of the form  I or of the form I&lt;A₁, ..., Aₑ&gt;, where I is a
single identifier and I&lt;A₁, ..., Aₑ&gt; is an optional type_ar gument_list . When no
type_ar gument_list  is specified, consider  e to be zero. The simple_name  is evaluated and
classified as follows:
If e is zero and the simple_name  appears within a local variable declaration space
(§7.3) that directly contains a local variable, parameter or constant with name  I,
then the simple_name  refers to that local variable, parameter or constant and is
classified as a variable or value.
If e is zero and the simple_name  appears within a generic method declaration but
outside the attributes of its method_declar ation , and if that declaration includes a
type parameter with name  I, then the simple_name  refers to that type parameter.
Otherwise, for each instance type  T (§15.3.2 ), starting with the instance type of the
immediately enclosing type declaration and continuing with the instance type of
each enclosing class or struct declaration (if any):
If e is zero and the declaration of  T includes a type parameter with name  I,
then the simple_name  refers to that type parameter.
Otherwise, if a member lookup ( §12.5 ) of I in T with e type arguments
produces a match:
If T is the instance type of the immediately enclosing class or struct type and
the lookup identifies one or more methods, the result is a method group
with an associated instance expression of this. If a type argument list was
specified, it is used in calling a generic method ( §12.8.9.2 ).
Otherwise, if T is the instance type of the immediately enclosing class or
struct type, if the lookup identifies an instance member, and if the reference
occurs within the block  of an instance constructor, an instance method, or an
instance accessor ( §12.2.1 ), the result is the same as a member access
(§12.8.7 ) of the form this.I. This can only happen when e is zero.12.8.4 Simple names
simple_name
: identifier type_argument_list?
;Otherwise, the result is the same as a member access ( §12.8.7 ) of the form
T.I or T.I&lt;A₁, ..., Aₑ&gt;.
Otherwise, for each namespace  N, starting with the namespace in which the
simple_name  occurs, continuing with each enclosing namespace (if any), and
ending with the global namespace, the following steps are evaluated until an entity
is located:
If e is zero and  I is the name of a namespace in  N, then:
If the location where the simple_name  occurs is enclosed by a namespace
declaration for  N and the namespace declaration contains an
extern_alias_dir ective or using_alias_dir ective that associates the name  I with
a namespace or type, then the simple_name  is ambiguous and a compile-
time error occurs.
Otherwise, the simple_name  refers to the namespace named  I in N.
Otherwise, if N contains an accessible type having name  I and e type
parameters, then:
If e is zero and the location where the simple_name  occurs is enclosed by a
namespace declaration for N and the namespace declaration contains an
extern_alias_dir ective or using_alias_dir ective that associates the name  I with
a namespace or type, then the simple_name  is ambiguous and a compile-
time error occurs.
Otherwise, the namesp ace_or_type_name  refers to the type constructed with
the given type arguments.
Otherwise, if the location where the simple_name  occurs is enclosed by a
namespace declaration for  N:
If e is zero and the namespace declaration contains an extern_alias_dir ective
or using_alias_dir ective that associates the name  I with an imported
namespace or type, then the simple_name  refers to that namespace or type.
Otherwise, if the namespaces imported by the using_namesp ace_directives of
the namespace declaration contain exactly one type having name  I and
e type parameters, then the simple_name  refers to that type constructed
with the given type arguments.
Otherwise, if the namespaces imported by the using_namesp ace_directives of
the namespace declaration contain more than one type having name  I and
e type parameters, then the simple_name  is ambiguous and a compile-time
error occurs.
Note: This entire step is exactly parallel to the corresponding step in the
processing of a namesp ace_or_type_name  (§7.8). end not eOtherwise, if e is zero and I is the identifier _, the simple_name  is a simple
discard, which is a form of declaration expression ( §12.17 ).
Otherwise, the simple_name  is undefined and a compile-time error occurs.
A parenthesized_expr ession  consists of an expression  enclosed in parentheses.
ANTLR
A parenthesized_expr ession  is evaluated by evaluating the expression  within the
parentheses. If the expression  within the parentheses denotes a namespace or type, a
compile-time error occurs. Otherwise, the result of the parenthesized_expr ession  is the
result of the evaluation of the contained expression .
A tuple_expr ession  represents a tuple, and consists of two or more comma-separated
and optionally-named expression s enclosed in parentheses. A deconstr uction_expr ession
is a shorthand syntax for a tuple containing implicitly typed declaration expressions.
ANTLR12.8.5 Parenthesized expressions
parenthesized_expression
: '(' expression ')'
;
12.8.6 Tuple expressions
tuple_expression
: '(' tuple_element ( ',' tuple_element)+ ')'
| deconstruction_expression
;</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>tuple_element
: (identifier ':')? expression
;</p>
<p>deconstruction_expression
: 'var' deconstruction_tuple
;</p>
<p>deconstruction_tuple
: '(' deconstruction_element ( ',' deconstruction_element)+ ')'
;
deconstruction_element
: deconstruction_tupleA tuple_expr ession  is classified as a tuple.
A deconstr uction_expr ession  var (e1, ..., en) is shorthand for the tuple_expr ession
(var e1, ..., var en) and follows the same behavior. This applies recursively to any
nested deconstr uction_tuple s in the deconstr uction_expr ession . Each identifier nested
within a deconstr uction_expr ession  thus introduces a declaration expression ( §12.17 ). As a
result, a deconstr uction_expr ession  can only occur on the left side of a simple
assignment.
A tuple expression has a type if and only if each of its element expressions Ei has a type
Ti. The type shall be a tuple type of the same arity as the tuple expression, where each
element is given by the following:
If the tuple element in the corresponding position has a name Ni, then the tuple
type element shall be Ti Ni.
Otherwise, if Ei is of the form Ni or E.Ni or E?.Ni then the tuple type element
shall be Ti Ni, unless  any of the following holds:
Another element of the tuple expression has the name Ni, or
Another tuple element without a name has a tuple element expression of the
form Ni or E.Ni or E?.Ni, or
Ni is of the form ItemX, where X is a sequence of non- 0-initiated decimal
digits that could represent the position of a tuple element, and X does not
represent the position of the element.
Otherwise, the tuple type element shall be Ti.
A tuple expression is evaluated by evaluating each of its element expressions in order
from left to right.
A tuple value can be obtained from a tuple expression by converting it to a tuple type
(§10.2.13 ), by reclassifying it as a value ( §12.2.2 )) or by making it the target of a
deconstructing assignment ( §12.21.2 ).
Example :
C#    | identifier
;
(int i, string) t1 = (i: 1, &quot;One&quot;);
(long l, string) t2 = (l: 2, null);
var t3 = (i: 3, &quot;Three&quot;);          // (int i, string)
var t4 = (i: 4, null);             // Error: no typeIn this example, all four tuple expressions are valid. The first two, t1 and t2, do not
use the type of the tuple expression, but instead apply an implicit tuple conversion.
In the case of t2, the implicit tuple conversion relies on the implicit conversions
from 2 to long and from null to string. The third tuple expression has a type
(int i, string), and can therefore be reclassified as a value of that type. The
declaration of t4, on the other hand, is an error: The tuple expression has no type
because its second element has no type.
C#
This example shows that tuples can sometimes lead to multiple layers of
parentheses, especially when the tuple expression is the sole argument to a method
invocation.
end ex ample
A member_ac cess consists of a primary_expr ession , a predefined_type , or a
quali fied_alias_member , followed by a “ .” token, followed by an identi fier, optionally
followed by a type_ar gument_list .
ANTLR
The quali fied_alias_member  production is defined in §14.8 .if ((x, y).Equals(( 1, 2))) { ... };
12.8.7 Member access
12.8.7.1 General
member_access
: primary_expression '.' identifier type_argument_list?
| predefined_type '.' identifier type_argument_list?
| qualified_alias_member '.' identifier type_argument_list?
;
predefined_type
: 'bool' | 'byte' | 'char' | 'decimal'  | 'double'  | 'float' | 'int'
| 'long' | 'object'  | 'sbyte' | 'short' | 'string'  | 'uint' | 'ulong'
| 'ushort'
;A member_ac cess is either of the form E.I or of the form E.I&lt;A₁, ..., Aₑ&gt;, where E is
a primary_expr ession , predefined_type  or quali fied_alias_member , I is a single identifier,
and &lt;A₁, ..., Aₑ&gt; is an optional type_ar gument_list . When no type_ar gument_list  is
specified, consider e to be zero.
A member_ac cess with a primary_expr ession  of type dynamic is dynamically bound
(§12.3.3 ). In this case, the compiler classifies the member access as a property access of
type dynamic. The rules below to determine the meaning of the member_ac cess are then
applied at run-time, using the run-time type instead of the compile-time type of the
primary_expr ession . If this run-time classification leads to a method group, then the
member access shall be the primary_expr ession  of an invocation_expr ession .
The member_ac cess is evaluated and classified as follows:
If e is zero and E is a namespace and E contains a nested namespace with
name I, then the result is that namespace.
Otherwise, if E is a namespace and E contains an accessible type having name  I
and K type parameters, then the result is that type constructed with the given type
arguments.
If E is classified as a type, if E is not a type parameter, and if a member lookup
(§12.5 ) of I in E with K type parameters produces a match, then E.I is evaluated
and classified as follows:
Note: When the result of such a member lookup is a method group and K is
zero, the method group can contain methods having type parameters. This
allows such methods to be considered for type argument inferencing. end not e
If I identifies a type, then the result is that type constructed with any given type
arguments.
If I identifies one or more methods, then the result is a method group with no
associated instance expression.
If I identifies a static property, then the result is a property access with no
associated instance expression.
If I identifies a static field:
If the field is readonly and the reference occurs outside the static constructor
of the class or struct in which the field is declared, then the result is a value,
namely the value of the static field  I in E.
Otherwise, the result is a variable, namely the static field  I in E.
If I identifies a static event:If the reference occurs within the class or struct in which the event is
declared, and the event was declared without event_ac cessor_declar ations
(§15.8.1 ), then E.I is processed exactly as if  I were a static field.
Otherwise, the result is an event access with no associated instance
expression.
If I identifies a constant, then the result is a value, namely the value of that
constant.
If I identifies an enumeration member, then the result is a value, namely the
value of that enumeration member.
Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
If E is a property access, indexer access, variable, or value, the type of which is  T,
and a member lookup ( §12.5 ) of I in T with K type arguments produces a match,
then E.I is evaluated and classified as follows:
First, if E is a property or indexer access, then the value of the property or
indexer access is obtained ( §12.2.2 ) and E is reclassified as a value.
If I identifies one or more methods, then the result is a method group with an
associated instance expression of  E.
If I identifies an instance property, then the result is a property access with an
associated instance expression of  E and an associated type that is the type of
the property. If  T is a class type, the associated type is picked from the first
declaration or override of the property found when starting with  T, and
searching through its base classes.
If T is a class_type  and I identifies an instance field of that class_type :
If the value of E is null, then a System.NullReferenceException is thrown.
Otherwise, if the field is readonly and the reference occurs outside an
instance constructor of the class in which the field is declared, then the result
is a value, namely the value of the field  I in the object referenced by  E.
Otherwise, the result is a variable, namely the field  I in the object referenced
by E.
If T is a struct_type  and I identifies an instance field of that struct_type :
If E is a value, or if the field is readonly and the reference occurs outside an
instance constructor of the struct in which the field is declared, then the
result is a value, namely the value of the field  I in the struct instance given
by E.
Otherwise, the result is a variable, namely the field  I in the struct instance
given by  E.
If I identifies an instance event:If the reference occurs within the class or struct in which the event is
declared, and the event was declared without event_ac cessor_declar ations
(§15.8.1 ), and the reference does not occur as the left-hand side of a += or -
= operator, then E.I is processed exactly as if I was an instance field.
Otherwise, the result is an event access with an associated instance
expression of  E.
Otherwise, an attempt is made to process E.I as an extension method invocation
(§12.8.9.3 ). If this fails, E.I is an invalid member reference, and a binding-time
error occurs.
In a member access of the form E.I, if E is a single identifier, and if the meaning of  E
as a simple_name  (§12.8.4 ) is a constant, field, property, local variable, or parameter with
the same type as the meaning of E as a type_name  (§7.8.1 ), then both possible
meanings of  E are permitted. The member lookup of E.I is never ambiguous, since I
shall necessarily be a member of the type  E in both cases. In other words, the rule
simply permits access to the static members and nested types of  E where a compile-
time error would otherwise have occurred.
Example :
C#12.8.7.2 Identical simple names and type names
struct Color
{
public static readonly  Color White = new Color(...);
public static readonly  Color Black = new Color(...);
public Color Complement () =&gt; new Color(...);
}
class A
{
public «Color» Color;              // Field Color of type Color
void F()
{
Color = «Color».Black;         // Refers to Color.Black static<br />
member
Color = Color.Complement();  // Invokes Complement() on Color<br />
field
}
static void G()
{
«Color» c = «Color».White;       // Refers to Color.White static  For expository purposes only, within the A class, those occurrences of the Color
identifier that reference the Color type are delimited by «...», and those that
reference the Color field are not.
end ex ample
A null_c onditional_member_ac cess is a conditional version of member_ac cess (§12.8.7 )
and it is a binding time error if the result type is void. For a null conditional expression
where the result type may be void see ( §12.8.10 ).
A null_c onditional_member_ac cess consists of a primary_expr ession  followed by the two
tokens “ ?” and “.”, followed by an identi fier with an optional type_ar gument_list ,
followed by zero or more dependent_ac cesses.
ANTLR
A null_c onditional_member_ac cess expression E is of the form P?.A. The meaning of E
is determined as follows:
If the type of P is a nullable value type:
Let T be the type of P.Value.A.
If T is a type parameter that is not known to be either a reference type or a
non-nullable value type, a compile-time error occurs.member
}
}
12.8.8 Null Conditional Member Access
null_conditional_member_access
: primary_expression '?' '.' identifier type_argument_list?
dependent_access*
;</p>
<p>dependent_access
: '.' identifier type_argument_list?    // member access
| '[' argument_list ']'                 // element access
| '(' argument_list? ')'                // invocation
;
null_conditional_projection_initializer
: primary_expression '?' '.' identifier type_argument_list?
;If T is a non-nullable value type, then the type of E is T?, and the meaning of
E is the same as the meaning of:
C#
Except that P is evaluated only once.
Otherwise the type of E is T, and the meaning of E is the same as the meaning
of:
C#
Except that P is evaluated only once.
Otherwise:
Let T be the type of the expression P.A.
If T is a type parameter that is not known to be either a reference type or a
non-nullable value type, a compile-time error occurs.
If T is a non-nullable value type, then the type of E is T?, and the meaning of
E is the same as the meaning of:
C#
Except that P is evaluated only once.
Otherwise the type of E is T, and the meaning of E is the same as the meaning
of:
C#
Except that P is evaluated only once.
Note: In an expression of the form:((object)P == null) ? (T?) null : P.Value.A
((object)P == null) ? (T)null : P.Value.A
((object)P == null) ? (T?) null : P.A
((object)P == null) ? (T)null : P.AC#
then if P evaluates to null neither A₀ or A₁ are evaluated. The same is true if an
expression is a sequence of null_c onditional_member_ac cess or
null_c onditional_element_ac cess §12.8.12  operations.
end not e
A null_c onditional_pr ojection_initializer  is a restriction of null_c onditional_member_ac cess
and has the same semantics. It only occurs as a projection initializer in an anonymous
object creation expression ( §12.8.16.7 ).
An invocation_expr ession  is used to invoke a method.
ANTLR
An invocation_expr ession  is dynamically bound ( §12.3.3 ) if at least one of the following
holds:
The primary_expr ession  has compile-time type dynamic.
At least one argument of the optional argument_list  has compile-time type
dynamic.
In this case, the compiler classifies the invocation_expr ession  as a value of type dynamic.
The rules below to determine the meaning of the invocation_expr ession  are then applied
at run-time, using the run-time type instead of the compile-time type of those of the
primary_expr ession  and arguments that have the compile-time type dynamic. If the
primary_expr ession  does not have compile-time type dynamic, then the method
invocation undergoes a limited compile-time check as described in §12.6.5 .
The primary_expr ession  of an invocation_expr ession  shall be a method group or a value
of a delegat e_type . If the primary_expr ession  is a method group, theP?.A₀?.A₁
12.8.9 Invocation expressions
12.8.9.1 General
invocation_expression
: primary_expression '(' argument_list? ')'
;invocation_expr ession  is a method invocation ( §12.8.9.2 ). If the primary_expr ession  is a
value of a delegat e_type , the invocation_expr ession  is a delegate invocation ( §12.8.9.4 ). If
the primary_expr ession  is neither a method group nor a value of a delegat e_type , a
binding-time error occurs.
The optional argument_list  (§12.6.2 ) provides values or variable references for the
parameters of the method.
The result of evaluating an invocation_expr ession  is classified as follows:
If the invocation_expr ession  invokes a returns-no-value method ( §15.6.1 ) or a
returns-no-value delegate, the result is nothing. An expression that is classified as
nothing is permitted only in the context of a statement_expr ession  (§13.7 ) or as the
body of a lambda_expr ession  (§12.19 ). Otherwise, a binding-time error occurs.
Otherwise, if the invocation_expr ession  invokes a returns-by-ref method ( §15.6.1 ) or
a returns-by-ref delegate, the result is a variable with an associated type of the
return type of the method or delegate. If the invocation is of an instance method,
and the receiver is of a class type T, the associated type is picked from the first
declaration or override of the method found when starting with T and searching
through its base classes.
Otherwise, the invocation_expr ession  invokes a returns-by-value method ( §15.6.1 )
or returns-by-value delegate, and the result is a value, with an associated type of
the return type of the method or delegate. If the invocation is of an instance
method, and the receiver is of a class type  T, the associated type is picked from
the first declaration or override of the method found when starting with  T and
searching through its base classes.
For a method invocation, the primary_expr ession  of the invocation_expr ession  shall be a
method group. The method group identifies the one method to invoke or the set of
overloaded methods from which to choose a specific method to invoke. In the latter
case, determination of the specific method to invoke is based on the context provided
by the types of the arguments in the argument_list .
The binding-time processing of a method invocation of the form M(A), where M is a
method group (possibly including a type_ar gument_list ), and A is an optional
argument_list , consists of the following steps:
The set of candidate methods for the method invocation is constructed. For each
method  F associated with the method group  M:
If F is non-generic, F is a candidate when:12.8.9.2 Method invocationsM has no type argument list, and
F is applicable with respect to  A (§12.6.4.2 ).
If F is generic and M has no type argument list, F is a candidate when:
Type inference ( §12.6.3 ) succeeds, inferring a list of type arguments for the
call, and
Once the inferred type arguments are substituted for the corresponding
method type parameters, all constructed types in the parameter list of F
satisfy their constraints ( §8.4.5 ), and the parameter list of F is applicable with
respect to  A (§12.6.4.2 )
If F is generic and M includes a type argument list, F is a candidate when:
F has the same number of method type parameters as were supplied in the
type argument list, and
Once the type arguments are substituted for the corresponding method type
parameters, all constructed types in the parameter list of F satisfy their
constraints ( §8.4.5 ), and the parameter list of F is applicable with respect
to A (§12.6.4.2 ).
The set of candidate methods is reduced to contain only methods from the most
derived types: For each method  C.F in the set, where C is the type in which the
method  F is declared, all methods declared in a base type of C are removed from
the set. Furthermore, if C is a class type other than object, all methods declared in
an interface type are removed from the set.
Note: This latter rule only has an effect when the method group was the result
of a member lookup on a type parameter having an effective base class other
than object and a non-empty effective interface set. end not e
If the resulting set of candidate methods is empty, then further processing along
the following steps are abandoned, and instead an attempt is made to process the
invocation as an extension method invocation ( §12.8.9.3 ). If this fails, then no
applicable methods exist, and a binding-time error occurs.
The best method of the set of candidate methods is identified using the overload
resolution rules of §12.6.4 . If a single best method cannot be identified, the
method invocation is ambiguous, and a binding-time error occurs. When
performing overload resolution, the parameters of a generic method are
considered after substituting the type arguments (supplied or inferred) for the
corresponding method type parameters.
Once a method has been selected and validated at binding-time by the above steps, the
actual run-time invocation is processed according to the rules of function member
invocation described in §12.6.6 .Note: The intuitive effect of the resolution rules described above is as follows: T o
locate the particular method invoked by a method invocation, start with the type
indicated by the method invocation and proceed up the inheritance chain until at
least one applicable, accessible, non-override method declaration is found. Then
perform type inference and overload resolution on the set of applicable, accessible,
non-override methods declared in that type and invoke the method thus selected. If
no method was found, try instead to process the invocation as an extension-method
invocation. end not e
In a method invocation ( §12.6.6.2 ) of one of the forms
C#
if the normal processing of the invocation finds no applicable methods, an attempt is
made to process the construct as an extension method invocation. If «expr» or any of
the «args» has compile-time type dynamic, extension methods will not apply.
The objective is to find the best type_name  C, so that the corresponding static method
invocation can take place:
C#
An extension method Cᵢ.Mₑ is eligible  if:
Cᵢ is a non-generic, non-nested class
The name of  Mₑ is identi fier
Mₑ is accessible and applicable when applied to the arguments as a static method
as shown above
An implicit identity, reference or boxing conversion exists from expr to the type of
the first parameter of  Mₑ.12.8.9.3 Extension method invocations
«expr» . «identifier» ( )<br />
«expr» . «identifier» ( «args» )<br />
«expr» . «identifier» &lt; «typeargs» &gt; ( )<br />
«expr» . «identifier» &lt; «typeargs» &gt; ( «args» )
C . «identifier» ( «expr» )<br />
C . «identifier» ( «expr» , «args» )<br />
C . «identifier» &lt; «typeargs» &gt; ( «expr» )<br />
C . «identifier» &lt; «typeargs» &gt; ( «expr» , «args» )The search for  C proceeds as follows:
Starting with the closest enclosing namespace declaration, continuing with each
enclosing namespace declaration, and ending with the containing compilation unit,
successive attempts are made to find a candidate set of extension methods:
If the given namespace or compilation unit directly contains non-generic type
declarations  Cᵢ with eligible extension methods  Mₑ, then the set of those
extension methods is the candidate set.
If namespaces imported by using namespace directives in the given namespace
or compilation unit directly contain non-generic type declarations  Cᵢ with
eligible extension methods  Mₑ, then the set of those extension methods is the
candidate set.
If no candidate set is found in any enclosing namespace declaration or compilation
unit, a compile-time error occurs.
Otherwise, overload resolution is applied to the candidate set as described in
§12.6.4 . If no single best method is found, a compile-time error occurs.
C is the type within which the best method is declared as an extension method.
Using C as a target, the method call is then processed as a static method invocation
(§12.6.6 ).
Note: Unlike an instance method invocation, no exception is thrown when expr
evaluates to a null reference. Instead, this null value is passed to the extension
method as it would be via a regular static method invocation. It is up to the
extension method implementation to decide how to respond to such a call. end not e
The preceding rules mean that instance methods take precedence over extension
methods, that extension methods available in inner namespace declarations take
precedence over extension methods available in outer namespace declarations, and that
extension methods declared directly in a namespace take precedence over extension
methods imported into that same namespace with a using namespace directive.
Example :
C#
public static class E
{
public static void F(this object obj, int i) { }
public static void F(this object obj, string s) { }
}
class A { }In the example, B’s method takes precedence over the first extension method, and
C’s method takes precedence over both extension methods.
C#class B
{
public void F(int i) { }
}
class C
{
public void F(object obj) { }
}
class X
{
static void Test(A a, B b, C c )
{
a.F(1);            // E.F(object, int)
a.F(&quot;hello&quot;);      // E.F(object, string)
b.F(1);            // B.F(int)
b.F(&quot;hello&quot;);      // E.F(object, string)
c.F(1);            // C.F(object)
c.F(&quot;hello&quot;);      // C.F(object)
}
}
public static class C
{
public static void F(this int i) =&gt; Console.WriteLine( $&quot;C.F({i})&quot;);
public static void G(this int i) =&gt; Console.WriteLine( $&quot;C.G({i})&quot;);
public static void H(this int i) =&gt; Console.WriteLine( $&quot;C.H({i})&quot;);
}
namespace  N1
{
public static class D
{
public static void F(this int i) =&gt; 
Console.WriteLine( $&quot;D.F({i})&quot;);
public static void G(this int i) =&gt; 
Console.WriteLine( $&quot;D.G({i})&quot;);
}
}
namespace  N2
{
using N1;
public static class E
{The output of this example is:
Console
D.G takes precendece over C.G, and E.F takes precedence over both D.F and C.F.
end ex ample
For a delegate invocation, the primary_expr ession  of the invocation_expr ession  shall be a
value of a delegat e_type . Furthermore, considering the delegat e_type  to be a function
member with the same parameter list as the delegat e_type , the delegat e_type  shall be
applicable ( §12.6.4.2 ) with respect to the argument_list  of the invocation_expr ession .
The run-time processing of a delegate invocation of the form  D(A), where D is a
primary_expr ession  of a delegat e_type  and A is an optional argument_list , consists of the
following steps:
D is evaluated. If this evaluation causes an exception, no further steps are
executed.
The argument list A is evaluated. If this evaluation causes an exception, no further
steps are executed.
The value of D is checked to be valid. If the value of D is null, a
System.NullReferenceException is thrown and no further steps are executed.        public static void F(this int i) =&gt; 
Console.WriteLine( $&quot;E.F({i})&quot;);
}
class Test
{
static void Main(string[] args)
{
1.F();
2.G();
3.H();
}
}
}
E.F(1)
D.G(2)
C.H(3)
12.8.9.4 Delegate invocationsOtherwise, D is a reference to a delegate instance. Function member invocations
(§12.6.6 ) are performed on each of the callable entities in the invocation list of the
delegate. For callable entities consisting of an instance and instance method, the
instance for the invocation is the instance contained in the callable entity.
See §20.6  for details of multiple invocation lists without parameters.
A null_c onditional_in vocation_expr ession  is syntactically either a
null_c onditional_member_ac cess (§12.8.8 ) or null_c onditional_element_ac cess (§12.8.12 )
where the final dependent_ac cess is an invocation expression ( §12.8.9 ).
A null_c onditional_in vocation_expr ession  occurs within the context of a
statement_expr ession  (§13.7 ), anon ymous_f unction_body  (§12.19.1 ), or method_body
(§15.6.1 ).
Unlike the syntactically equivalent null_c onditional_member_ac cess or
null_c onditional_element_ac cess, a null_c onditional_in vocation_expr ession  may be
classified as nothing.
ANTLR
A null_c onditional_in vocation_expr ession  expression E is of the form P?A; where A is the
remainder of the syntactically equivalent null_c onditional_member_ac cess or
null_c onditional_element_ac cess, A will therefore start with . or [. Let PA signify the
concatention of P and A.
When E occurs as a statement_expr ession  the meaning of E is the same as the meaning
of the statement :
C#
except that P is evaluated only once.12.8.10 Null Conditional Invocation Expression
null_conditional_invocation_expression
: null_conditional_member_access '(' argument_list? ')'
| null_conditional_element_access '(' argument_list? ')'
;
if ((object)P != null) PAWhen E occurs as a anon ymous_f unction_body  or method_body  the meaning of E
depends on its classification:
If E is classified as nothing then its meaning is the same as the meaning of the
block :
C#
except that P is evaluated only once.
Otherwise the meaning of E is the same as the meaning of the block :
C#
and in turn the meaning of this block  depends on whether E is syntactically
equivalent to a null_c onditional_member_ac cess (§12.8.8 ) or
null_c onditional_element_ac cess (§12.8.12 ).
An element_ac cess consists of a primary_no_arr ay_cr eation_expr ession , followed by a
“[” token, followed by an argument_list , followed by a “ ]” token. The argument_list
consists of one or more argument s, separated by commas.
ANTLR
The argument_list  of an element_ac cess is not allowed to contain out or ref arguments.
An element_ac cess is dynamically bound ( §12.3.3 ) if at least one of the following holds:
The primary_no_arr ay_cr eation_expr ession  has compile-time type dynamic.
At least one expression of the argument_list  has compile-time type dynamic and
the primary_no_arr ay_cr eation_expr ession  does not have an array type.{ if ((object)P != null) PA; }
{ return E; }
12.8.11 Element access
12.8.11.1 General
element_access
: primary_no_array_creation_expression '[' argument_list ']'
;In this case, the compiler classifies the element_ac cess as a value of type dynamic. The
rules below to determine the meaning of the element_ac cess are then applied at run-
time, using the run-time type instead of the compile-time type of those of the
primary_no_arr ay_cr eation_expr ession  and argument_list  expressions which have the
compile-time type dynamic. If the primary_no_arr ay_cr eation_expr ession  does not have
compile-time type dynamic, then the element access undergoes a limited compile-time
check as described in §12.6.5 .
If the primary_no_arr ay_cr eation_expr ession  of an element_ac cess is a value of an
array_type , the element_ac cess is an array access ( §12.8.11.2 ). Otherwise, the
primary_no_arr ay_cr eation_expr ession  shall be a variable or value of a class, struct, or
interface type that has one or more indexer members, in which case the element_ac cess
is an indexer access ( §12.8.11.3 ).
For an array access, the primary_no_arr ay_cr eation_expr ession  of the element_ac cess shall
be a value of an array_type . Furthermore, the argument_list  of an array access is not
allowed to contain named arguments. The number of expressions in the argument_list
shall be the same as the rank of the array_type , and each expression shall be of type
int, uint, long, or ulong, or shall be implicitly convertible to one or more of these
types.
The result of evaluating an array access is a variable of the element type of the array,
namely the array element selected by the value(s) of the expression(s) in the
argument_list .
The run-time processing of an array access of the form P[A], where P is a
primary_no_arr ay_cr eation_expr ession  of an array_type  and A is an argument_list ,
consists of the following steps:
P is evaluated. If this evaluation causes an exception, no further steps are
executed.
The index expressions of the argument_list  are evaluated in order, from left to
right. Following evaluation of each index expression, an implicit conversion ( §10.2 )
to one of the following types is performed: int, uint, long, ulong. The first type
in this list for which an implicit conversion exists is chosen. For instance, if the
index expression is of type short then an implicit conversion to int is performed,
since implicit conversions from short to int and from short to long are possible.
If evaluation of an index expression or the subsequent implicit conversion causes12.8.11.2 Array accessan exception, then no further index expressions are evaluated and no further steps
are executed.
The value of P is checked to be valid. If the value of P is null, a
System.NullReferenceException is thrown and no further steps are executed.
The value of each expression in the argument_list  is checked against the actual
bounds of each dimension of the array instance referenced by  P. If one or more
values are out of range, a System.IndexOutOfRangeException is thrown and no
further steps are executed.
The location of the array element given by the index expression(s) is computed,
and this location becomes the result of the array access.
For an indexer access, the primary_no_arr ay_cr eation_expr ession  of the element_ac cess
shall be a variable or value of a class, struct, or interface type, and this type shall
implement one or more indexers that are applicable with respect to the argument_list  of
the element_ac cess.
The binding-time processing of an indexer access of the form P[A], where P is a
primary_no_arr ay_cr eation_expr ession  of a class, struct, or interface type  T, and A is an
argument_list , consists of the following steps:
The set of indexers provided by  T is constructed. The set consists of all indexers
declared in  T or a base type of  T that are not override declarations and are
accessible in the current context ( §7.5).
The set is reduced to those indexers that are applicable and not hidden by other
indexers. The following rules are applied to each indexer S.I in the set, where S is
the type in which the indexer I is declared:
If I is not applicable with respect to A (§12.6.4.2 ), then I is removed from the
set.
If I is applicable with respect to  A (§12.6.4.2 ), then all indexers declared in a
base type of  S are removed from the set.
If I is applicable with respect to  A (§12.6.4.2 ) and S is a class type other than
object, all indexers declared in an interface are removed from the set.
If the resulting set of candidate indexers is empty, then no applicable indexers
exist, and a binding-time error occurs.
The best indexer of the set of candidate indexers is identified using the overload
resolution rules of §12.6.4 . If a single best indexer cannot be identified, the indexer
access is ambiguous, and a binding-time error occurs.12.8.11.3 Indexer accessThe index expressions of the argument_list  are evaluated in order, from left to
right. The result of processing the indexer access is an expression classified as an
indexer access. The indexer access expression references the indexer determined in
the step above, and has an associated instance expression of  P and an associated
argument list of  A, and an associated type that is the type of the indexer. If  T is a
class type, the associated type is picked from the first declaration or override of the
indexer found when starting with  T and searching through its base classes.
Depending on the context in which it is used, an indexer access causes invocation of
either the get_ac cessor or the set_ac cessor of the indexer. If the indexer access is the
target of an assignment, the set_ac cessor is invoked to assign a new value ( §12.21.2 ). In
all other cases, the get_ac cessor is invoked to obtain the current value ( §12.2.2 ).
A null_c onditional_element_ac cess consists of a primary_no_arr ay_cr eation_expr ession
followed by the two tokens “ ?” and “[”, followed by an argument_list , followed by a “ ]”
token, followed by zero or more dependent_ac cesses.
ANTLR
A null_c onditional_element_ac cess is a conditional version of element_ac cess (§12.8.11 )
and it is a binding time error if the result type is void. For a null conditional expression
where the result type may be void see ( §12.8.10 ).
A null_c onditional_element_ac cess expression E is of the form P?[A]B; where B are the
dependent_ac cesses, if any. The meaning of E is determined as follows:
If the type of P is a nullable value type:
Let T be the type of the expression P.Value[A]B.
If T is a type parameter that is not known to be either a reference type or a
non-nullable value type, a compile-time error occurs.
If T is a non-nullable value type, then the type of E is T?, and the meaning of
E is the same as the meaning of:12.8.12 Null Conditional Element Access
null_conditional_element_access
: primary_no_array_creation_expression '?' '[' argument_list ']'
dependent_access*
;C#
Except that P is evaluated only once.
Otherwise the type of E is T, and the meaning of E is the same as the meaning
of:
C#
Except that P is evaluated only once.
Otherwise:
Let T be the type of the expression P[A]B.
If T is a type parameter that is not known to be either a reference type or a
non-nullable value type, a compile-time error occurs.
If T is a non-nullable value type, then the type of E is T?, and the meaning of
E is the same as the meaning of:
C#
Except that P is evaluated only once.
Otherwise the type of E is T, and the meaning of E is the same as the meaning
of:
C#
Except that P is evaluated only once.
Note: In an expression of the form:
C#((object)P == null) ? (T?) null : P.Value[A]B
((object)P == null) ? null : P.Value[A]B
((object)P == null) ? (T?) null : P[A]B
((object)P == null) ? null : P[A]Bif P evaluates to null neither A₀ or A₁ are evaluated. The same is true if an
expression is a sequence of null_c onditional_element_ac cess or
null_c onditional_member_ac cess §12.8.8  operations.
end not e
A this_ac cess consists of the keyword this.
ANTLR
A this_ac cess is permitted only in the block  of an instance constructor, an instance
method, an instance accessor ( §12.2.1 ), or a finalizer. It has one of the following
meanings:
When this is used in a primary_expr ession  within an instance constructor of a
class, it is classified as a value. The type of the value is the instance type ( §15.3.2 ) of
the class within which the usage occurs, and the value is a reference to the object
being constructed.
When this is used in a primary_expr ession  within an instance method or instance
accessor of a class, it is classified as a value. The type of the value is the instance
type ( §15.3.2 ) of the class within which the usage occurs, and the value is a
reference to the object for which the method or accessor was invoked.
When this is used in a primary_expr ession  within an instance constructor of a
struct, it is classified as a variable. The type of the variable is the instance type
(§15.3.2 ) of the struct within which the usage occurs, and the variable represents
the struct being constructed.
If the constructor declaration has no constructor initializer, the this variable
behaves exactly the same as an out parameter of the struct type. In particular,
this means that the variable shall be definitely assigned in every execution path
of the instance constructor.
Otherwise, the this variable behaves exactly the same as a ref parameter of
the struct type. In particular, this means that the variable is considered initially
assigned.P?[A₀]?[A₁]
12.8.13 This access
this_access
: 'this'
;When this is used in a primary_expr ession  within an instance method or instance
accessor of a struct, it is classified as a variable. The type of the variable is the
instance type ( §15.3.2 ) of the struct within which the usage occurs.
If the method or accessor is not an iterator ( §15.14 ) or async function ( §15.15 ),
the this variable represents the struct for which the method or accessor was
invoked.
If the struct is a readonly struct, the this variable behaves exactly the same
as an in parameter of the struct type
Otherwise the this variable behaves exactly the same as a ref parameter of
the struct type
If the method or accessor is an iterator or async function, the this variable
represents a copy of the struct for which the method or accessor was invoked,
and behaves exactly the same as a value parameter of the struct type.
Use of this in a primary_expr ession  in a context other than the ones listed above is a
compile-time error. In particular, it is not possible to refer to this in a static method, a
static property accessor, or in a variable_initializer  of a field declaration.
A base_access consists of the keyword base followed by either a “ .” token and an
identifier and optional type_ar gument_list  or an argument_list  enclosed in square
brackets:
ANTLR
A base_access is used to access base class members that are hidden by similarly named
members in the current class or struct. A base_access is permitted only in the block  of an
instance constructor, an instance method, an instance accessor ( §12.2.1 ), or a finalizer.
When base.I occurs in a class or struct, I shall denote a member of the base class of
that class or struct. Likewise, when base[E] occurs in a class, an applicable indexer shall
exist in the base class.
At binding-time, base_access expressions of the form base.I and base[E] are evaluated
exactly as if they were written ((B)this).I and ((B)this)[E], where B is the base class
of the class or struct in which the construct occurs. Thus, base.I and base[E]12.8.14 Base access
base_access
: 'base' '.' identifier type_argument_list?
| 'base' '[' argument_list ']'
;correspond to this.I and this[E], except this is viewed as an instance of the base
class.
When a base_access references a virtual function member (a method, property, or
indexer), the determination of which function member to invoke at run-time ( §12.6.6 ) is
changed. The function member that is invoked is determined by finding the most
derived implementation ( §15.6.4 ) of the function member with respect to  B (instead of
with respect to the run-time type of this, as would be usual in a non-base access).
Thus, within an override of a virtual function member, a base_access can be used to
invoke the inherited implementation of the function member. If the function member
referenced by a base_access is abstract, a binding-time error occurs.
Note: Unlike this, base is not an expression in itself. It is a keyword only used in the
context of a base_access or a constr uctor_initializer  (§15.11.2 ). end not e
ANTLR
The operand of a postfix increment or decrement operation shall be an expression
classified as a variable, a property access, or an indexer access. The result of the
operation is a value of the same type as the operand.
If the primary_expr ession  has the compile-time type dynamic then the operator is
dynamically bound ( §12.3.3 ), the post_incr ement_expr ession  or
post_decr ement_expr ession  has the compile-time type dynamic and the following rules
are applied at run-time using the run-time type of the primary_expr ession .
If the operand of a postfix increment or decrement operation is a property or indexer
access, the property or indexer shall have both a get and a set accessor. If this is not the
case, a binding-time error occurs.
Unary operator overload resolution ( §12.4.4 ) is applied to select a specific operator
implementation. Predefined ++ and -- operators exist for the following types: sbyte,
byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, and any12.8.15 Postfix increment and decrement operators
post_increment_expression
: primary_expression '++'
;
post_decrement_expression
: primary_expression '--'
;enum type. The predefined ++ operators return the value produced by adding  1 to the
operand, and the predefined -- operators return the value produced by subtracting  1
from the operand. In a checked context, if the result of this addition or subtraction is
outside the range of the result type and the result type is an integral type or enum type,
a System.OverflowException is thrown.
There shall be an implicit conversion from the return type of the selected unary operator
to the type of the primary_expr ession , otherwise a compile-time error occurs.
The run-time processing of a postfix increment or decrement operation of the form x++
or x-- consists of the following steps:
If x is classified as a variable:
x is evaluated to produce the variable.
The value of x is saved.
The saved value of x is converted to the operand type of the selected operator
and the operator is invoked with this value as its argument.
The value returned by the operator is converted to the type of  X and stored in
the location given by the earlier evaluation of x.
The saved value of x becomes the result of the operation.
If x is classified as a property or indexer access:
The instance expression (if x is not static) and the argument list (if x is an
indexer access) associated with x are evaluated, and the results are used in the
subsequent get and set accessor invocations.
The get accessor of x is invoked and the returned value is saved.
The saved value of x is converted to the operand type of the selected operator
and the operator is invoked with this value as its argument.
The value returned by the operator is converted to the type of x and the set
accessor of x is invoked with this value as its value argument.
The saved value of x becomes the result of the operation.
The ++ and -- operators also support prefix notation ( §12.9.6 ). Typically, the result of
x++ or x-- is the value of  X befor e the operation, whereas the result of ++x or --x is
the value of  X after the operation. In either case, x itself has the same value after the
operation.
An operator  ++ or operator  -- implementation can be invoked using either postfix or
prefix notation. It is not possible to have separate operator implementations for the two
notations.The new operator is used to create new instances of types.
There are three forms of new expressions:
Object creation expressions and anonymous object creation expressions are used
to create new instances of class types and value types.
Array creation expressions are used to create new instances of array types.
Delegate creation expressions are used to obtain instances of delegate types.
The new operator implies creation of an instance of a type, but does not necessarily
imply allocation of memory. In particular, instances of value types require no additional
memory beyond the variables in which they reside, and no allocations occur when new is
used to create instances of value types.
Note: Delegate creation expressions do not always create new instances. When the
expression is processed in the same way as a method group conversion ( §10.8 ) or an
anonymous function conversion ( §10.7 ) this may result in an existing delegate
instance being reused. end not e
An object_cr eation_expr ession  is used to create a new instance of a class_type  or a
value_type .
ANTLR
The type of an object_cr eation_expr ession  shall be a class_type , a value_type , or a
type_p aramet er. The type cannot be a tuple_type  or an abstract or static class_type .12.8.16 The new operator
12.8.16.1 General
12.8.16.2 Object creation expressions
object_creation_expression
: 'new' type '(' argument_list? ')' object_or_collection_initializer?
| 'new' type object_or_collection_initializer
;
object_or_collection_initializer
: object_initializer
| collection_initializer
;The optional argument_list  (§12.6.2 ) is permitted only if the type is a class_type  or a
struct_type .
An object creation expression can omit the constructor argument list and enclosing
parentheses provided it includes an object initializer or collection initializer. Omitting the
constructor argument list and enclosing parentheses is equivalent to specifying an
empty argument list.
Processing of an object creation expression that includes an object initializer or
collection initializer consists of first processing the instance constructor and then
processing the member or element initializations specified by the object initializer
(§12.8.16.3 ) or collection initializer ( §12.8.16.4 ).
If any of the arguments in the optional argument_list  has the compile-time type dynamic
then the object_cr eation_expr ession  is dynamically bound ( §12.3.3 ) and the following
rules are applied at run-time using the run-time type of those arguments of the
argument_list  that have the compile-time type dynamic. However, the object creation
undergoes a limited compile-time check as described in §12.6.5 .
The binding-time processing of an object_cr eation_expr ession  of the form new T(A),
where T is a class_type , or a value_type , and A is an optional argument_list , consists of
the following steps:
If T is a value_type  and A is not present:
The object_cr eation_expr ession  is a default constructor invocation. The result of
the object_cr eation_expr ession  is a value of type  T, namely the default value for
T as defined in §8.3.3 .
Otherwise, if  T is a type_p aramet er and A is not present:
If no value type constraint or constructor constraint ( §15.2.5 ) has been specified
for T, a binding-time error occurs.
The result of the object_cr eation_expr ession  is a value of the run-time type that
the type parameter has been bound to, namely the result of invoking the
default constructor of that type. The run-time type may be a reference type or a
value type.
Otherwise, if T is a class_type  or a struct_type :
If T is an abstract or static class_type , a compile-time error occurs.
The instance constructor to invoke is determined using the overload resolution
rules of §12.6.4 . The set of candidate instance constructors consists of all
accessible instance constructors declared in  T, which are applicable with respect
to A ( §12.6.4.2 ). If the set of candidate instance constructors is empty, or if asingle best instance constructor cannot be identified, a binding-time error
occurs.
The result of the object_cr eation_expr ession  is a value of type  T, namely the
value produced by invoking the instance constructor determined in the step
above.
Otherwise, the object_cr eation_expr ession  is invalid, and a binding-time error
occurs.
Even if the object_cr eation_expr ession  is dynamically bound, the compile-time type is still
T.
The run-time processing of an object_cr eation_expr ession  of the form new T(A), where T
is class_type  or a struct_type  and A is an optional argument_list , consists of the following
steps:
If T is a class_type :
A new instance of class  T is allocated. If there is not enough memory available
to allocate the new instance, a System.OutOfMemoryException is thrown and no
further steps are executed.
All fields of the new instance are initialized to their default values ( §9.3).
The instance constructor is invoked according to the rules of function member
invocation ( §12.6.6 ). A reference to the newly allocated instance is automatically
passed to the instance constructor and the instance can be accessed from
within that constructor as this.
If T is a struct_type :
An instance of type  T is created by allocating a temporary local variable. Since
an instance constructor of a struct_type  is required to definitely assign a value to
each field of the instance being created, no initialization of the temporary
variable is necessary.
The instance constructor is invoked according to the rules of function member
invocation ( §12.6.6 ). A reference to the newly allocated instance is automatically
passed to the instance constructor and the instance can be accessed from
within that constructor as this.
An object initializer  specifies values for zero or more fields, properties, or indexed
elements of an object.
ANTLR12.8.16.3 Object initializersAn object initializer consists of a sequence of member initializers, enclosed by { and }
tokens and separated by commas. Each member_initializer  shall designate a target for
the initialization. An identi fier shall name an accessible field or property of the object
being initialized, whereas an argument_list  enclosed in square brackets shall specify
arguments for an accessible indexer on the object being initialized. It is an error for an
object initializer to include more than one member initializer for the same field or
property.
Note: While an object initializer is not permitted to set the same field or property
more than once, there are no such restrictions for indexers. An object initializer may
contain multiple initializer targets referring to indexers, and may even use the same
indexer arguments multiple times. end not e
Each initializer_t arget is followed by an equals sign and either an expression, an object
initializer or a collection initializer. It is not possible for expressions within the object
initializer to refer to the newly created object it is initializing.
A member initializer that specifies an expression after the equals sign is processed in the
same way as an assignment ( §12.21.2 ) to the target.
A member initializer that specifies an object initializer after the equals sign is a nested
object initializer , i.e., an initialization of an embedded object. Instead of assigning a new
value to the field or property, the assignments in the nested object initializer are treatedobject_initializer
: '{' member_initializer_list? '}'
| '{' member_initializer_list ',' '}'
;
member_initializer_list
: member_initializer ( ',' member_initializer)*
;
member_initializer
: initializer_target '=' initializer_value
;
initializer_target
: identifier
| '[' argument_list ']'
;
initializer_value
: expression
| object_or_collection_initializer
;as assignments to members of the field or property. Nested object initializers cannot be
applied to properties with a value type, or to read-only fields with a value type.
A member initializer that specifies a collection initializer after the equals sign is an
initialization of an embedded collection. Instead of assigning a new collection to the
target field, property, or indexer, the elements given in the initializer are added to the
collection referenced by the target. The target shall be of a collection type that satisfies
the requirements specified in §12.8.16.4 .
When an initializer target refers to an indexer, the arguments to the indexer shall always
be evaluated exactly once. Thus, even if the arguments end up never getting used (e.g.,
because of an empty nested initializer), they are evaluated for their side effects.
Example : The following class represents a point with two coordinates:
C#
An instance of Point can be created and initialized as follows:
C#
This has the same effect as
C#
where __a is an otherwise invisible and inaccessible temporary variable.
The following class shows a rectangle created from two points, and the creation and
initialization of a Rectangle instance:
C#public class Point
{
public int X { get; set; }
public int Y { get; set; }
}
Point a = new Point { X = 0, Y = 1 };
Point __a = new Point();
__a.X = 0;
__a.Y = 1;
Point a = __a;An instance of Rectangle can be created and initialized as follows:
C#
This has the same effect as
C#
where __r, __p1 and __p2 are temporary variables that are otherwise invisible and
inaccessible.
If Rectangle’s constructor allocates the two embedded Point instances, they can be
used to initialize the embedded Point instances instead of assigning new instances:
C#public class Rectangle
{
public Point P1 { get; set; }
public Point P2 { get; set; }
}
Rectangle r = new Rectangle
{
P1 = new Point { X = 0, Y = 1 },
P2 = new Point { X = 2, Y = 3 }
};
Rectangle __r = new Rectangle();
Point __p1 = new Point();
__p1.X = 0;
__p1.Y = 1;
__r.P1 = __p1;
Point __p2 = new Point();
__p2.X = 2;
__p2.Y = 3;
__r.P2 = __p2;
Rectangle r = __r;
public class Rectangle
{
public Point P1 { get; } = new Point();
public Point P2 { get; } = new Point();
}the following construct can be used to initialize the embedded Point instances
instead of assigning new instances:
C#
This has the same effect as
C#
end ex ample
A collection initializer specifies the elements of a collection.
ANTLRRectangle r = new Rectangle
{
P1 = { X = 0, Y = 1 },
P2 = { X = 2, Y = 3 }
};
Rectangle __r = new Rectangle();
__r.P1.X = 0;
__r.P1.Y = 1;
__r.P2.X = 2;
__r.P2.Y = 3;
Rectangle r = __r;
12.8.16.4 Collection initializers
collection_initializer
: '{' element_initializer_list '}'
| '{' element_initializer_list ',' '}'
;
element_initializer_list
: element_initializer ( ',' element_initializer)*
;
element_initializer
: non_assignment_expression
| '{' expression_list '}'
;
expression_list
: expression
| expression_list ',' expression
;A collection initializer consists of a sequence of element initializers, enclosed by  {
and } tokens and separated by commas. Each element initializer specifies an element to
be added to the collection object being initialized, and consists of a list of expressions
enclosed by  { and } tokens and separated by commas. A single-expression element
initializer can be written without braces, but cannot then be an assignment expression,
to avoid ambiguity with member initializers. The non_assignment_expr ession  production
is defined in §12.22 .
Example : The following is an example of an object creation expression that includes
a collection initializer:
C#
end ex ample
The collection object to which a collection initializer is applied shall be of a type that
implements System.Collections.IEnumerable or a compile-time error occurs. For each
specified element in order from left to right, normal member lookup is applied to find a
member named Add. If the result of the member lookup is not a method group, a
compile-time error occurs. Otherwise, overload resolution is applied with the expression
list of the element initializer as the argument list, and the collection initializer invokes
the resulting method. Thus, the collection object shall contain an applicable instance or
extension method with the name Add for each element initializer.
Example :The following shows a class that represents a contact with a name and a list
of phone numbers, and the creation and initialization of a List<Contact>:
C#List<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
public class Contact
{
public string Name { get; set; }
public List<string> PhoneNumbers { get; } = new List<string>();
}
class A
{
static void M()
{
var contacts = new List<Contact>
{
new Contact
{which has the same effect as
C#
where __clist, __c1 and __c2 are temporary variables that are otherwise invisible
and inaccessible.
end ex ample
An array_cr eation_expr ession  is used to create a new instance of an array_type .
ANTLR
An array creation expression of the first form allocates an array instance of the type that
results from deleting each of the individual expressions from the expression list.                Name = &quot;Chris Smith&quot; ,
PhoneNumbers = { &quot;206-555-0101&quot; , &quot;425-882-8080&quot;  }
},
new Contact
{
Name = &quot;Bob Harris&quot; ,
PhoneNumbers = { &quot;650-555-0199&quot;  }
}
};
}
}
var __clist = new List<Contact>();
Contact __c1 = new Contact();
__c1.Name = &quot;Chris Smith&quot; ;
__c1.PhoneNumbers.Add( &quot;206-555-0101&quot; );
__c1.PhoneNumbers.Add( &quot;425-882-8080&quot; );
__clist.Add(__c1);
Contact __c2 = new Contact();
__c2.Name = &quot;Bob Harris&quot; ;
__c2.PhoneNumbers.Add( &quot;650-555-0199&quot; );
__clist.Add(__c2);
var contacts = __clist;
12.8.16.5 Array creation expressions
array_creation_expression
: 'new' non_array_type '[' expression_list ']' rank_specifier*
array_initializer?
| 'new' array_type array_initializer
| 'new' rank_specifier array_initializer
;Example : The array creation expression new int[10,20] produces an array instance
of type int[,], and the array creation expression new int[10][,] produces an array
instance of type int[][,]. end ex ample
Each expression in the expression list shall be of type int, uint, long, or ulong, or
implicitly convertible to one or more of these types. The value of each expression
determines the length of the corresponding dimension in the newly allocated array
instance. Since the length of an array dimension shall be nonnegative, it is a compile-
time error to have a constant expression with a negative value, in the expression list.
Except in an unsafe context ( §23.2 ), the layout of arrays is unspecified.
If an array creation expression of the first form includes an array initializer, each
expression in the expression list shall be a constant and the rank and dimension lengths
specified by the expression list shall match those of the array initializer.
In an array creation expression of the second or third form, the rank of the specified
array type or rank specifier shall match that of the array initializer. The individual
dimension lengths are inferred from the number of elements in each of the
corresponding nesting levels of the array initializer. Thus, the initializer expression in the
following declaration
C#
exactly corresponds to
C#
An array creation expression of the third form is referred to as an implicitly typed arr ay-
creation expr ession . It is similar to the second form, except that the element type of the
array is not explicitly given, but determined as the best common type ( §12.6.3.15 ) of the
set of expressions in the array initializer. For a multidimensional array, i.e., one where the
rank_speci fier contains at least one comma, this set comprises all expression s found in
nested array_initializer s.
Array initializers are described further in §17.7 .
The result of evaluating an array creation expression is classified as a value, namely a
reference to the newly allocated array instance. The run-time processing of an arrayvar a = new int[,] {{0, 1}, {2, 3}, {4, 5}};
var a = new int[3, 2] {{0, 1}, {2, 3}, {4, 5}};creation expression consists of the following steps:
The dimension length expressions of the expression_list  are evaluated in order,
from left to right. Following evaluation of each expression, an implicit conversion
(§10.2 ) to one of the following types is performed: int, uint, long, ulong. The
first type in this list for which an implicit conversion exists is chosen. If evaluation
of an expression or the subsequent implicit conversion causes an exception, then
no further expressions are evaluated and no further steps are executed.
The computed values for the dimension lengths are validated, as follows: If one or
more of the values are less than zero, a System.OverflowException is thrown and
no further steps are executed.
An array instance with the given dimension lengths is allocated. If there is not
enough memory available to allocate the new instance, a
System.OutOfMemoryException is thrown and no further steps are executed.
All elements of the new array instance are initialized to their default values ( §9.3).
If the array creation expression contains an array initializer, then each expression in
the array initializer is evaluated and assigned to its corresponding array element.
The evaluations and assignments are performed in the order the expressions are
written in the array initializer—in other words, elements are initialized in increasing
index order, with the rightmost dimension increasing first. If evaluation of a given
expression or the subsequent assignment to the corresponding array element
causes an exception, then no further elements are initialized (and the remaining
elements will thus have their default values).
An array creation expression permits instantiation of an array with elements of an array
type, but the elements of such an array shall be manually initialized.
Example : The statement
C#
creates a single-dimensional array with 100 elements of type int[]. The initial value
of each element is null. It is not possible for the same array creation expression to
also instantiate the sub-arrays, and the statement
C#int[][] a = new int[100][];
int[][] a = new int[100][5]; // Errorresults in a compile-time error. Instantiation of the sub-arrays can instead be
performed manually, as in
C#
end ex ample
Note: When an array of arrays has a “rectangular” shape, that is when the sub-arrays
are all of the same length, it is more efficient to use a multi-dimensional array. In the
example above, instantiation of the array of arrays creates 101 objects—one outer
array and 100 sub-arrays. In contrast,
C#
creates only a single object, a two-dimensional array, and accomplishes the
allocation in a single statement.
end not e
Example : The following are examples of implicitly typed array creation expressions:
C#
The last expression causes a compile-time error because neither int nor string is
implicitly convertible to the other, and so there is no best common type. An
explicitly typed array creation expression must be used in this case, for example
specifying the type to be object[]. Alternatively, one of the elements can be cast to
a common base type, which would then become the inferred element type.
end ex ampleint[][] a = new int[100][];
for (int i = 0; i &lt; 100; i++)
{
a[i] = new int[5];
}
int[,] a = new int[100, 5];
var a = new[] { 1, 10, 100, 1000 };                     // int[]
var b = new[] { 1, 1.5, 2, 2.5 };                       // double[]
var c = new[,] { { &quot;hello&quot;, null }, { &quot;world&quot;, &quot;!&quot; } }; // string[,]
var d = new[] { 1, &quot;one&quot;, 2, &quot;two&quot; };                   // ErrorImplicitly typed array creation expressions can be combined with anonymous object
initializers ( §12.8.16.7 ) to create anonymously typed data structures.
Example :
C#
end ex ample
A delegat e_creation_expr ession  is used to obtain an instance of a delegat e_type .
ANTLR
The argument of a delegate creation expression shall be a method group, an
anonymous function, or a value of either the compile-time type dynamic or a
delegat e_type . If the argument is a method group, it identifies the method and, for an
instance method, the object for which to create a delegate. If the argument is an
anonymous function it directly defines the parameters and method body of the delegate
target. If the argument is a value it identifies a delegate instance of which to create a
copy.
If the expression  has the compile-time type dynamic, the delegat e_creation_expr ession  is
dynamically bound ( §12.8.16.6 ), and the rules below are applied at run-time using the
run-time type of the expression . Otherwise, the rules are applied at compile-time.var contacts = new[]
{
new
{
Name = &quot;Chris Smith&quot; ,
PhoneNumbers = new[] { &quot;206-555-0101&quot; , &quot;425-882-8080&quot;  }
},
new 
{
Name = &quot;Bob Harris&quot; ,
PhoneNumbers = new[] { &quot;650-555-0199&quot;  }
}
};
12.8.16.6 Delegate creation expressions
delegate_creation_expression
: 'new' delegate_type '(' expression ')'
;The binding-time processing of a delegat e_creation_expr ession  of the form new D(E),
where D is a delegat e_type  and E is an expression , consists of the following steps:
If E is a method group, the delegate creation expression is processed in the same
way as a method group conversion ( §10.8 ) from E to D.
If E is an anonymous function, the delegate creation expression is processed in the
same way as an anonymous function conversion ( §10.7 ) from E to D.
If E is a value, E shall be compatible ( §20.2 ) with D, and the result is a reference to
a newly created delegate with a single-entry invocation list that invokes   E.
The run-time processing of a delegat e_creation_expr ession  of the form new D(E),
where D is a delegat e_type  and E is an expression , consists of the following steps:
If E is a method group, the delegate creation expression is evaluated as a method
group conversion ( §10.8 ) from E to D.
If E is an anonymous function, the delegate creation is evaluated as an
anonymous function conversion from  E to D (§10.7 ).
If E is a value of a delegat e_type :
E is evaluated. If this evaluation causes an exception, no further steps are
executed.
If the value of  E is null, a System.NullReferenceException is thrown and no
further steps are executed.
A new instance of the delegate type  D is allocated. If there is not enough
memory available to allocate the new instance, a System.OutOfMemoryException
is thrown and no further steps are executed.
The new delegate instance is initialized with a single-entry invocation list that
invokes  E.
The invocation list of a delegate is determined when the delegate is instantiated and
then remains constant for the entire lifetime of the delegate. In other words, it is not
possible to change the target callable entities of a delegate once it has been created.
Note: Remember, when two delegates are combined or one is removed from
another, a new delegate results; no existing delegate has its content changed. end
note
It is not possible to create a delegate that refers to a property, indexer, user-defined
operator, instance constructor, finalizer, or static constructor.Example : As described above, when a delegate is created from a method group, the
formal parameter list and return type of the delegate determine which of the
overloaded methods to select. In the example
C#
the A.f field is initialized with a delegate that refers to the second Square method
because that method exactly matches the formal parameter list and return type of
DoubleFunc. Had the second Square method not been present, a compile-time error
would have occurred.
end ex ample
An anon ymous_object_cr eation_expr ession  is used to create an object of an anonymous
type.
ANTLRdelegate  double DoubleFunc (double x);
class A
{
DoubleFunc f = new DoubleFunc(Square);
static float Square(float x) =&gt; x * x;
static double Square(double x) =&gt; x * x;
}
12.8.16.7 Anonymous object creation expressions
anonymous_object_creation_expression
: 'new' anonymous_object_initializer
;
anonymous_object_initializer
: '{' member_declarator_list? '}'
| '{' member_declarator_list ',' '}'
;
member_declarator_list
: member_declarator ( ',' member_declarator)*
;
member_declarator
: simple_name
| member_access
| null_conditional_projection_initializer
| base_accessAn anonymous object initializer declares an anonymous type and returns an instance of
that type. An anonymous type is a nameless class type that inherits directly from object.
The members of an anonymous type are a sequence of read-only properties inferred
from the anonymous object initializer used to create an instance of the type. Specifically,
an anonymous object initializer of the form
new { p₁ = e₁ , p₂ = e₂ , … pᵥ = eᵥ }
declares an anonymous type of the form
C#
where each «T x» is the type of the corresponding expression «ex». The expression used
in a member_declar ator shall have a type. Thus, it is a compile-time error for an
expression in a member_declar ator to be null or an anonymous function.
The names of an anonymous type and of the parameter to its Equals method are
automatically generated by the compiler and cannot be referenced in program text.
Within the same program, two anonymous object initializers that specify a sequence of
properties of the same names and compile-time types in the same order will produce
instances of the same anonymous type.    | identifier '=' expression
;
class __Anonymous1
{
private readonly  «T1» «f1»;
private readonly  «T2» «f2»;
...
private readonly  «Tn» «fn»;
public __Anonymous1(«T1» «a1», «T2» «a2»,..., «Tn» «an»)
{
«f1» = «a1»;
«f2» = «a2»;
...
«fn» = «an»;
}
public «T1» «p1» { get { return «f1»; } }
public «T2» «p2» { get { return «f2»; } }
...
public «Tn» «pn» { get { return «fn»; } }
public override  bool Equals(object __o) { ... }
public override  int GetHashCode () { ... }
}Example : In the example
C#
the assignment on the last line is permitted because p1 and p2 are of the same
anonymous type.
end ex ample
The Equals and GetHashcode methods on anonymous types override the methods
inherited from object, and are defined in terms of the Equals and GetHashcode of the
properties, so that two instances of the same anonymous type are equal if and only if all
their properties are equal.
A member declarator can be abbreviated to a simple name ( §12.8.4 ), a member access
(§12.8.7 ), a null conditional projection initializer §12.8.8  or a base access ( §12.8.14 ). This
is called a projection initializer  and is shorthand for a declaration of and assignment to
a property with the same name. Specifically, member declarators of the forms
«identifier», «expr» . «identifier» and «expr» ? . «identifier»
are precisely equivalent to the following, respectively:
«identifer» = «identifier», «identifier» = «expr» . «identifier» and «identifier»
= «expr» ? . «identifier»
Thus, in a projection initializer the identifier selects both the value and the field or
property to which the value is assigned. Intuitively, a projection initializer projects not
just a value, but also the name of the value.
The typeof operator is used to obtain the System.Type object for a type.
ANTLRvar p1 = new { Name = &quot;Lawnmower&quot; , Price = 495.00 };
var p2 = new { Name = &quot;Shovel&quot; , Price = 26.95 };
p1 = p2;
12.8.17 The typeof operator
typeof_expression
: 'typeof'  '(' type ')'
| 'typeof'  '(' unbound_type_name ')'
| 'typeof'  '(' 'void' ')'
;The first form of typeo f_expr ession  consists of a typeof keyword followed by a
parenthesized type. The result of an expression of this form is the System.Type object
for the indicated type. There is only one System.Type object for any given type. This
means that for a type  T, typeof(T) == typeof(T) is always true. The type cannot be
dynamic.
The second form of typeo f_expr ession  consists of a typeof keyword followed by a
parenthesized unbound_type_name .
Note: An unbound_type_name  is very similar to a type_name  (§7.8) except that an
unbound_type_name  contains gener ic_dimension_speci fiers where a type_name
contains type_ar gument_list s. end not e
When the operand of a typeo f_expr ession  is a sequence of tokens that satisfies the
grammars of both unbound_type_name  and type_name , namely when it contains neither
a gener ic_dimension_speci fier nor a type_ar gument_list , the sequence of tokens is
considered to be a type_name . The meaning of an unbound_type_name  is determined as
follows:
Convert the sequence of tokens to a type_name  by replacing each
gener ic_dimension_speci fier with a type_ar gument_list  having the same number of
commas and the keyword object as each type_ar gument .
Evaluate the resulting type_name , while ignoring all type parameter constraints.
The unbound_type_name  resolves to the unbound generic type associated with the
resulting constructed type ( §8.4).
The result of the typeo f_expr ession  is the System.Type object for the resulting unbound
generic type.unbound_type_name
: identifier generic_dimension_specifier?
| identifier '::' identifier generic_dimension_specifier?
| unbound_type_name '.' identifier generic_dimension_specifier?
;
generic_dimension_specifier
: '&lt;' comma* '&gt;'
;
comma
: ','
;The third form of typeo f_expr ession  consists of a typeof keyword followed by a
parenthesized void keyword. The result of an expression of this form is the System.Type
object that represents the absence of a type. The type object returned by typeof(void)
is distinct from the type object returned for any type.
Note: This special System.Type object is useful in class libraries that allow reflection
onto methods in the language, where those methods wish to have a way to
represent the return type of any method, including void methods, with an instance
of System.Type. end not e
The typeof operator can be used on a type parameter. The result is the System.Type
object for the run-time type that was bound to the type parameter. The typeof operator
can also be used on a constructed type or an unbound generic type ( §8.4.4 ). The
System.Type object for an unbound generic type is not the same as the System.Type
object of the instance type ( §15.3.2 ). The instance type is always a closed constructed
type at run-time so its System.Type object depends on the run-time type arguments in
use. The unbound generic type, on the other hand, has no type arguments, and yields
the same  System.Type object regardless of runtime type arguments.
Example : The example
C#
class X<T>
{
public static void PrintTypes ()
{
Type[] t =
{
typeof(int),
typeof(System.Int32),
typeof(string),
typeof(double[]),
typeof(void),
typeof(T),
typeof(X<T>),
typeof(X&lt;X<T>&gt;),
typeof(X&lt;&gt;)
};
for (int i = 0; i &lt; t.Length; i++)
{
Console.WriteLine(t[i]);
}
}
}
class Testproduces the following output:
Console
Note that int and System.Int32 are the same type. The result of typeof(X&lt;&gt;) does
not depend on the type argument but the result of typeof(X<T>) does.
end ex ample
The sizeof operator returns the number of 8-bit bytes occupied by a variable of a given
type. The type specified as an operand to sizeof shall be an unmanaged_type  (§8.8).
ANTLR
For certain predefined types the sizeof operator yields a constant int value as shown
in the table below:
Expression Result
sizeof(sbyte) 1
sizeof(byte) 1
sizeof(short) 2{
static void Main()
{
X<int>.PrintTypes();
}
}
System.Int32
System.Int32
System.String
System.Double[]
System.Void
System.Int32
X<code>1[System.Int32] X</code>1[X<code>1[System.Int32]] X</code>1[T]
12.8.18 The sizeof operator
sizeof_expression
: 'sizeof'  '(' unmanaged_type ')'
;Expression Result
sizeof(ushort) 2
sizeof(int) 4
sizeof(uint) 4
sizeof(long) 8
sizeof(ulong) 8
sizeof(char) 2
sizeof(float) 4
sizeof(double) 8
sizeof(bool) 1
sizeof(decimal) 16
For an enum type  T, the result of the expression sizeof(T) is a constant value equal to
the size of its underlying type, as given above. For all other operand types, the sizeof
operator is specified in §23.6.9 .
The checked and unchecked operators are used to control the overflow-checking
context for integral-type arithmetic operations and conversions.
ANTLR
The checked operator evaluates the contained expression in a checked context, and the
unchecked operator evaluates the contained expression in an unchecked context. A
check ed_expr ession  or uncheck ed_expr ession  corresponds exactly to a
parenthesized_expr ession  (§12.8.5 ), except that the contained expression is evaluated in
the given overflow checking context.12.8.19 The checked and unchecked operators
checked_expression
: 'checked'  '(' expression ')'
;
unchecked_expression
: 'unchecked'  '(' expression ')'
;The overflow checking context can also be controlled through the checked and
unchecked statements ( §13.12 ).
The following operations are affected by the overflow checking context established by
the checked and unchecked operators and statements:
The predefined ++ and -- operators ( §12.8.15  and §12.9.6 ), when the operand is of
an integral or enum type.
The predefined - unary operator ( §12.9.3 ), when the operand is of an integral type.
The predefined +, -, *, and / binary operators ( §12.10 ), when both operands are
of integral or enum types.
Explicit numeric conversions ( §10.3.2 ) from one integral or enum type to another
integral or enum type, or from float or double to an integral or enum type.
When one of the above operations produces a result that is too large to represent in the
destination type, the context in which the operation is performed controls the resulting
behavior:
In a checked context, if the operation is a constant expression ( §12.23 ), a compile-
time error occurs. Otherwise, when the operation is performed at run-time, a
System.OverflowException is thrown.
In an unchecked context, the result is truncated by discarding any high-order bits
that do not fit in the destination type.
For non-constant expressions ( §12.23 ) (expressions that are evaluated at run-time) that
are not enclosed by any checked or unchecked operators or statements, the default
overflow checking context is unchecked, unless external factors (such as compiler
switches and execution environment configuration) call for checked evaluation.
For constant expressions ( §12.23 ) (expressions that can be fully evaluated at compile-
time), the default overflow checking context is always checked. Unless a constant
expression is explicitly placed in an unchecked context, overflows that occur during the
compile-time evaluation of the expression always cause compile-time errors.
The body of an anonymous function is not affected by checked or unchecked contexts in
which the anonymous function occurs.
Example : In the following code
C#
class Test
{
static readonly  int x = 1000000;no compile-time errors are reported since neither of the expressions can be
evaluated at compile-time. At run-time, the F method throws a
System.OverflowException, and the G method returns –727379968 (the lower 32 bits
of the out-of-range result). The behavior of the H method depends on the default
overflow-checking context for the compilation, but it is either the same as F or the
same as  G.
end ex ample
Example : In the following code
C#
the overflows that occur when evaluating the constant expressions in  F and H
cause compile-time errors to be reported because the expressions are evaluated in a
checked context. An overflow also occurs when evaluating the constant expression
in G, but since the evaluation takes place in an unchecked context, the overflow is
not reported.
end ex ample
The checked and unchecked operators only affect the overflow checking context for
those operations that are textually contained within the “ (” and “)” tokens. The
operators have no effect on function members that are invoked as a result of evaluating
the contained expression.
Example : In the following code    static readonly  int y = 1000000;
static int F() =&gt; checked(x * y);    // Throws OverflowException
static int G() =&gt; unchecked (x * y);  // Returns -727379968
static int H() =&gt; x * y;             // Depends on default
}
class Test
{
const int x = 1000000;
const int y = 1000000;
static int F() =&gt; checked(x * y);    // Compile-time error, overflow
static int G() =&gt; unchecked (x * y);  // Returns -727379968
static int H() =&gt; x * y;             // Compile-time error, overflow
}C#
the use of checked in F does not affect the evaluation of x * y in Multiply, so
x * y is evaluated in the default overflow checking context.
end ex ample
The unchecked operator is convenient when writing constants of the signed integral
types in hexadecimal notation.
Example :
C#
Both of the hexadecimal constants above are of type uint. Because the constants
are outside the int range, without the unchecked operator, the casts to int would
produce compile-time errors.
end ex ample
Note: The checked and unchecked operators and statements allow programmers to
control certain aspects of some numeric calculations. However, the behavior of
some numeric operators depends on their operands’ data types. For example,
multiplying two decimals always results in an exception on overflow even within an
explicitly unchecked construct. Similarly, multiplying two floats never results in an
exception on overflow even within an explicitly checked construct. In addition, other
operators are never affected by the mode of checking, whether default or explicit.
end not eclass Test
{
static int Multiply (int x, int y) =&gt; x * y;
static int F() =&gt; checked(Multiply( 1000000, 1000000));
}
class Test
{
public const int AllBits = unchecked ((int)0xFFFFFFFF );
public const int HighBit = unchecked ((int)0x80000000 );
}
12.8.20 Default value expressionsA default value expression is used to obtain the default value ( §9.3) of a type.
ANTLR
A default_lit eral represents a default value ( §9.3). It does not have a type, but can be
converted to any type through a default literal conversion ( §10.2.16 ).
The result of a default_v alue_expr ession  is the default ( §9.3) of the explicit type in an
explictly_typed_default , or the target type of the conversion for a
default_v alue_expr ession .
A default_v alue_expr ession  is a constant expression ( §12.23 ) if the type is one of:
a reference type
a type parameter that is known to be a reference type ( §8.2);
one of the following value types: sbyte, byte, short, ushort, int, uint, long,
ulong, char, float, double, decimal, bool,; or
any enumeration type.
A stack allocation expression allocates a block of memory from the execution stack. The
execution st ack is an area of memory where local variables are stored. The execution
stack is not part of the managed heap. The memory used for local variable storage is
automatically recovered when the current function returns.
The safe context rules for a stack allocation expression are described in §16.4.12.7 .
ANTLRdefault_value_expression
: explictly_typed_default
| default_literal
;
explictly_typed_default
: 'default'  '(' type ')'
;
default_literal
: 'default'
;
12.8.21 Stack allocation
stackalloc_expression
: 'stackalloc'  unmanaged_type '[' expression ']'
| 'stackalloc'  unmanaged_type? '[' constant_expression? ']'A stackalloc_expr ession  is only permitted in two contexts:</p>
<ol>
<li>The initializing expression , E, of a local_v ariable_declar ation  (§13.6.2 ); and</li>
<li>The right operand expression , E, of a simple assignment ( §12.21.2 ) which itself
occurs as a expression_st atement  (§13.7 )
In both contexts the stackalloc_expr ession  is only permitted to occur as:
The whole of E; or
The second and/or third operands of a conditional_expr ession  (§12.18 ) which is
itself the whole of E.
The unmanaged_type  (§8.8) indicates the type of the items that will be stored in the
newly allocated location, and the expression  indicates the number of these items. T aken
together, these specify the required allocation size. The type of expression  shall be
implicitly convertible to the type int.
As the size of a stack allocation cannot be negative, it is a compile-time error to specify
the number of items as a constant_expr ession  that evaluates to a negative value.
At runtime if the number of items to be allocated is a negative value then the behavior
is undefined. If it is zero, then no allocation is made, and the value returned is
implementation-defined. If there is not enough memory available to allocate the items a
System.StackOverflowException is thrown.
When a stackalloc_initializer  is present:
If unmanaged_type  is omitted, it is inferred following the rules for best common
type ( §12.6.3.15 ) for the set of stackalloc_element_initializer s.
If constant_expr ession  is omitted it is inferred to be the number of
stackalloc_element_initializer s.      stackalloc_initializer
;
stackalloc_initializer
: '{' stackalloc_initializer_element_list '}'
;
stackalloc_initializer_element_list
: stackalloc_element_initializer ( ',' stackalloc_element_initializer)* 
','?
;</li>
</ol>
<p>stackalloc_element_initializer
: expression
;If constant_expr ession  is present it shall equal the number of
stackalloc_element_initializer s.
Each stackalloc_element_initializer  shall have an implicit conversion to unmanaged_type
(§10.2 ). The stackalloc_element_initializer s initialize elements in the allocated memory in
increasing order, starting with the element at index zero. In the absence of a
stackalloc_initializer , the content of the newly allocated memory is undefined.
The result of a stackalloc_expr ession  is an instance of type Span<T>, where T is the
unmanaged_type :
Span<T> (§C.3) is a ref struct type ( §16.2.3 ), which presents a block of memory, here
the block allocated by the stackalloc_expr ession , as an indexable collection of typed
(T) items.
The result’s Length property returns the number of items allocated.
The result’s indexer ( §15.9 ) returns a variable_r eference (§9.5) to an item of the
allocated block and is range checked.
Note: When occurring in unsafe code the result of a stackalloc_expr ession  may be of
a different type, see ( §23.9 ). end not e
Stack allocation initializers are not permitted in catch or finally blocks ( §13.11 ).
Note: There is no way to explicitly free memory allocated using stackalloc. end not e
All stack-allocated memory blocks created during the execution of a function member
are automatically discarded when that function member returns.
Except for the stackalloc operator, C# provides no predefined constructs for managing
non-garbage collected memory. Such services are typically provided by supporting class
libraries or imported directly from the underlying operating system.
Example :
C#
// Memory uninitialized
Span<int> span1 = stackalloc  int[3];
// Memory initialized
Span<int> span2 = stackalloc  int[3] { -10, -15, -30 };
// Type int is inferred
Span<int> span3 = stackalloc [] { 11, 12, 13 };
// Error; result is int*, not allowed in a safe context
var span4 = stackalloc [] { 11, 12, 13 };In the case of span8, stackalloc results in a Span<int>, which is converted by an
implicit operator to ReadOnlySpan<int>. Similarly, for span9, the resulting
Span<double> is converted to the user-defined type Widget<double> using the
conversion, as shown. end ex ample
A nameo f_expr ession  is used to obtain the name of a program entity as a constant string.
ANTLR
Because nameof is not a keyword, a nameo f_expr ession  is always syntactically ambiguous
with an invocation of the simple name nameof. For compatibility reasons, if a name
lookup ( §12.8.4 ) of the name nameof succeeds, the expression is treated as an// Error; no conversion from Span<int> to Span<long>
Span<long> span5 = stackalloc [] { 11, 12, 13 };
// Converts 11 and 13, and returns Span<long> 
Span<long> span6 = stackalloc [] { 11, 12L, 13 };
// Converts all and returns Span<long>
Span<long> span7 = stackalloc  long[] { 11, 12, 13 };
// Implicit conversion of Span<T>
ReadOnlySpan&lt; int&gt; span8 = stackalloc  int[] { 10, 22, 30 };
// Implicit conversion of Span<T>
Widget<double> span9 = stackalloc  double[] { 1.2, 5.6 };
public class Widget<T>
{
public static implicit  operator  Widget<T>(Span&lt; double&gt; sp) { return 
null; }
}
12.8.22 Nameof expressions
nameof_expression
: 'nameof'  '(' named_entity ')'
;</p>
<p>named_entity
: named_entity_target ( '.' identifier type_argument_list?)*
;</p>
<p>named_entity_target
: simple_name
| 'this'
| 'base'
| predefined_type 
| qualified_alias_member
;invocation_expr ession  — regardless of whether the invocation is valid. Otherwise it is a
nameo f_expr ession .
Simple name and member access lookups are performed on the named_entity  at
compile time, following the rules described in §12.8.4  and §12.8.7 . However, where the
lookup described in §12.8.4  and §12.8.7  results in an error because an instance member
was found in a static context, a nameo f_expr ession  produces no such error.
It is a compile-time error for a named_entity  designating a method group to have a
type_ar gument_list . It is a compile time error for a named_entity_t arget to have the type
dynamic.
A nameo f_expr ession  is a constant expression of type string, and has no effect at
runtime. Specifically, its named_entity  is not evaluated, and is ignored for the purposes
of definite assignment analysis ( §9.4.4.22 ). Its value is the last identifier of the
named_entity  before the optional final type_ar gument_list , transformed in the following
way:
The prefix “ @”, if used, is removed.
Each unicode_es cape_s equenc e is transformed into its corresponding Unicode
character.
Any formatting_char acters are removed.
These are the same transformations applied in §6.4.3  when testing equality between
identifiers.
Example : The following illustrates the results of various nameof expressions,
assuming a generic type List<T> declared within the System.Collections.Generic
namespace:
C#
using TestAlias = System.String;
class Program
{
static void Main()
{
var point = (x: 3, y: 4);
string n1 = nameof(System);                      // &quot;System&quot;
string n2 = nameof(System.Collections.Generic);  // &quot;Generic&quot;
string n3 = nameof(point);                       // &quot;point&quot;
string n4 = nameof(point.x);                     // &quot;x&quot;
string n5 = nameof(Program);                     // &quot;Program&quot;
string n6 = nameof(System.Int32);                // &quot;Int32&quot;
string n7 = nameof(TestAlias);                   // &quot;TestAlias&quot;Potentially surprising parts of this example are the resolution of
nameof(System.Collections.Generic) to just “Generic” instead of the full namespace,
and of nameof(TestAlias) to “T estAlias” rather than “S tring”. end ex ample
An anon ymous_method_expr ession  is one of two ways of defining an anonymous
function. These are further described in §12.19 .
The +, -, !, <del>, ++, --, cast, and await operators are called the unary operators.        string n8 = nameof(List<int>);                   // &quot;List&quot;
string n9 = nameof(Program.InstanceMethod);      // 
&quot;InstanceMethod&quot;
string n10 = nameof(Program.GenericMethod);      // 
&quot;GenericMethod&quot;
string n11 = nameof(Program.NestedClass);        // 
&quot;NestedClass&quot;
// Invalid
// string x1 = nameof(List&lt;&gt;);            // Empty type argument<br />
list
// string x2 = nameof(List<T>);           // T is not in scope
// string x3 = nameof(GenericMethod&lt;&gt;);   // Empty type argument<br />
list
// string x4 = nameof(GenericMethod<T>);  // T is not in scope
// string x5 = nameof(int);               // Keywords not<br />
permitted
// Type arguments not permitted for method group
// string x6 = nameof(GenericMethod<Program>);
}
void InstanceMethod () { }
void GenericMethod<T>()
{
string n1 = nameof(List<T>); // &quot;List&quot;
string n2 = nameof(T);       // &quot;T&quot;
}
class NestedClass  { }
}
12.8.23 Anonymous method expressions
12.9 Unary operators
12.9.1 GeneralANTLR
point er_indir ection_expr ession  (§23.6.2 ) and addressof_expr ession  (§23.6.5 ) are available
only in unsafe code ( §23).
If the operand of a unary_expr ession  has the compile-time type dynamic, it is
dynamically bound ( §12.3.3 ). In this case, the compile-time type of the unary_expr ession
is dynamic, and the resolution described below will take place at run-time using the run-
time type of the operand.
For an operation of the form  +x, unary operator overload resolution ( §12.4.4 ) is applied
to select a specific operator implementation. The operand is converted to the parameter
type of the selected operator, and the type of the result is the return type of the
operator. The predefined unary plus operators are:
C#
For each of these operators, the result is simply the value of the operand.
Lifted ( §12.4.8 ) forms of the unlifted predefined unary plus operators defined above are
also predefined.unary_expression
: primary_expression
| '+' unary_expression
| '-' unary_expression
| '!' unary_expression
| '</del>' unary_expression
| pre_increment_expression
| pre_decrement_expression
| cast_expression
| await_expression
| pointer_indirection_expression    // unsafe code support
| addressof_expression              // unsafe code support
;
12.9.2 Unary plus operator
int operator  +(int x);
uint operator  +(uint x);
long operator  +(long x);
ulong operator  +(ulong x);
float operator  +(float x);
double operator  +(double x);
decimal operator  +(decimal x);For an operation of the form  –x, unary operator overload resolution ( §12.4.4 ) is applied
to select a specific operator implementation. The operand is converted to the parameter
type of the selected operator, and the type of the result is the return type of the
operator. The predefined unary minus operators are:
Integer negation:
C#
The result is computed by subtracting  X from zero. If the value of  X is the smallest
representable value of the operand type (−2³¹ for int or −2⁶³ for long), then the
mathematical negation of  X is not representable within the operand type. If this
occurs within a checked context, a System.OverflowException is thrown; if it occurs
within an unchecked context, the result is the value of the operand and the
overflow is not reported.
If the operand of the negation operator is of type uint, it is converted to type
long, and the type of the result is long. An exception is the rule that permits the
int value −2147483648 (−2³¹) to be written as a decimal integer literal ( §6.4.5.3 ).
If the operand of the negation operator is of type ulong, a compile-time error
occurs. An exception is the rule that permits the long value −9223372036854775808
(−2⁶³) to be written as a decimal integer literal ( §6.4.5.3 )
Floating-point negation:
C#
The result is the value of  X with its sign inverted. If x is NaN, the result is also NaN.
Decimal negation:
C#12.9.3 Unary minus operator
int operator  –(int x);
long operator  –(long x);
float operator  –(float x);
double operator  –(double x);
decimal operator  –(decimal x);The result is computed by subtracting  X from zero. Decimal negation is equivalent
to using the unary minus operator of type System.Decimal.
Lifted ( §12.4.8 ) forms of the unlifted predefined unary minus operators defined above
are also predefined.
For an operation of the form !x, unary operator overload resolution ( §12.4.4 ) is applied
to select a specific operator implementation. The operand is converted to the parameter
type of the selected operator, and the type of the result is the return type of the
operator. Only one predefined logical negation operator exists:
C#
This operator computes the logical negation of the operand: If the operand is true, the
result is false. If the operand is false, the result is true.
Lifted ( §12.4.8 ) forms of the unlifted predefined logical negation operator defined above
are also predefined.
For an operation of the form ~x, unary operator overload resolution ( §12.4.4 ) is applied
to select a specific operator implementation. The operand is converted to the parameter
type of the selected operator, and the type of the result is the return type of the
operator. The predefined bitwise complement operators are:
C#
For each of these operators, the result of the operation is the bitwise complement of  x.
Every enumeration type  E implicitly provides the following bitwise complement
operator:
C#12.9.4 Logical negation operator
bool operator  !(bool x);
12.9.5 Bitwise complement operator
int operator  ~(int x);
uint operator  ~(uint x);
long operator  ~(long x);
ulong operator  ~(ulong x);The result of evaluating  <del>x, where  X is an expression of an enumeration type  E with an
underlying type  U, is exactly the same as evaluating (E)(</del>(U)x), except that the
conversion to  E is always performed as if in an unchecked context ( §12.8.19 ).
Lifted ( §12.4.8 ) forms of the unlifted predefined bitwise complement operators defined
above are also predefined.
ANTLR
The operand of a prefix increment or decrement operation shall be an expression
classified as a variable, a property access, or an indexer access. The result of the
operation is a value of the same type as the operand.
If the operand of a prefix increment or decrement operation is a property or indexer
access, the property or indexer shall have both a get and a set accessor. If this is not the
case, a binding-time error occurs.
Unary operator overload resolution ( §12.4.4 ) is applied to select a specific operator
implementation. Predefined ++ and -- operators exist for the following types: sbyte,
byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, and any
enum type. The predefined ++ operators return the value produced by adding  1 to the
operand, and the predefined -- operators return the value produced by subtracting  1
from the operand. In a checked context, if the result of this addition or subtraction is
outside the range of the result type and the result type is an integral type or enum type,
a System.OverflowException is thrown.
There shall be an implicit conversion from the return type of the selected unary operator
to the type of the unary_expr ession , otherwise a compile-time error occurs.E operator  ~(E x);
12.9.6 Prefix increment and decrement operators
pre_increment_expression
: '++' unary_expression
;
pre_decrement_expression
: '--' unary_expression
;The run-time processing of a prefix increment or decrement operation of the form ++x
or --x consists of the following steps:
If x is classified as a variable:
x is evaluated to produce the variable.
The value of x is converted to the operand type of the selected operator and
the operator is invoked with this value as its argument.
The value returned by the operator is converted to the type of x. The resulting
value is stored in the location given by the evaluation of  x.
and becomes the result of the operation.
If x is classified as a property or indexer access:
The instance expression (if x is not static) and the argument list (if x is an
indexer access) associated with x are evaluated, and the results are used in the
subsequent get and set accessor invocations.
The get accessor of  X is invoked.
The value returned by the get accessor is converted to the operand type of the
selected operator and operator is invoked with this value as its argument.
The value returned by the operator is converted to the type of x. The set
accessor of  X is invoked with this value as its value argument.
This value also becomes the result of the operation.
The ++ and -- operators also support postfix notation ( §12.8.15 ). Typically, the result of
x++ or x-- is the value of  X before the operation, whereas the result of ++x or --x is
the value of  X after the operation. In either case, x itself has the same value after the
operation.
An operator  ++ or operator  -- implementation can be invoked using either postfix or
prefix notation. It is not possible to have separate operator implementations for the two
notations.
Lifted ( §12.4.8 ) forms of the unlifted predefined prefix increment and decrement
operators defined above are also predefined.
A cast_expr ession  is used to convert explicitly an expression to a given type.
ANTLR12.9.7 Cast expressions
cast_expression
: '(' type ')' unary_expressionA cast_expr ession  of the form (T)E, where T is a type and E is a unary_expr ession ,
performs an explicit conversion ( §10.3 ) of the value of  E to type  T. If no explicit
conversion exists from  E to T, a binding-time error occurs. Otherwise, the result is the
value produced by the explicit conversion. The result is always classified as a value, even
if E denotes a variable.
The grammar for a cast_expr ession  leads to certain syntactic ambiguities.
Example : The expression (x)–y could either be interpreted as a cast_expr ession  (a
cast of –y to type  x) or as an additiv e_expr ession  combined with a
parenthesized_expr ession  (which computes the value x – y). end ex ample
To resolve cast_expr ession  ambiguities, the following rule exists: A sequence of one or
more tokens ( §6.4) enclosed in parentheses is considered the start of a cast_expr ession
only if at least one of the following are true:
The sequence of tokens is correct grammar for a type, but not for an expression.
The sequence of tokens is correct grammar for a type, and the token immediately
following the closing parentheses is the token “ ~”, the token “ !”, the token “ (”,
an identifier ( §6.4.3 ), a literal ( §6.4.5 ), or any keyword ( §6.4.4 ) except  as and is.
The term “correct grammar” above means only that the sequence of tokens shall
conform to the particular grammatical production. It specifically does not consider the
actual meaning of any constituent identifiers.
Example : If x and y are identifiers, then x.y is correct grammar for a type, even if
x.y doesn’t actually denote a type. end ex ample
Note: From the disambiguation rule, it follows that, if x and y are identifiers, (x)y,
(x)(y), and (x)(-y) are cast_expr ession s, but (x)-y is not, even if x identifies a
type. However, if x is a keyword that identifies a predefined type (such as int), then
all four forms are cast_expr ession s (because such a keyword could not possibly be an
expression by itself). end not e    ;
12.9.8 Await expressions
12.9.8.1 GeneralThe await operator is used to suspend evaluation of the enclosing async function until
the asynchronous operation represented by the operand has completed.
ANTLR
An await_expr ession  is only allowed in the body of an async function ( §15.15 ). Within the
nearest enclosing async function, an await_expr ession  shall not occur in these places:
Inside a nested (non-async) anonymous function
Inside the block of a lock_st atement
In an anonymous function conversion to an expression tree type ( §10.7.3 )
In an unsafe context
Note: An await_expr ession  cannot occur in most places within a query_expr ession ,
because those are syntactically transformed to use non-async lambda expressions.
end not e
Inside an async function, await shall not be used as an available_identi fier although the
verbatim identifier @await may be used. There is therefore no syntactic ambiguity
between await_expr ession s and various expressions involving identifiers. Outside of
async functions, await acts as a normal identifier.
The operand of an await_expr ession  is called the task. It represents an asynchronous
operation that may or may not be complete at the time the await_expr ession  is
evaluated. The purpose of the await operator is to suspend execution of the enclosing
async function until the awaited task is complete, and then obtain its outcome.
The task of an await_expr ession  is required to be await able. An expression  t is
awaitable if one of the following holds:
t is of compile-time type dynamic
t has an accessible instance or extension method called GetAwaiter with no
parameters and no type parameters, and a return type  A for which all of the
following hold:
A implements the interface
System.Runtime.CompilerServices.INotifyCompletion (hereafter known asawait_expression
: 'await' unary_expression
;
12.9.8.2 Awaitable expressionsINotifyCompletion for brevity)
A has an accessible, readable instance property IsCompleted of type bool
A has an accessible instance method GetResult with no parameters and no
type parameters
The purpose of the GetAwaiter method is to obtain an await er for the task. The type A
is called the await er type  for the await expression.
The purpose of the IsCompleted property is to determine if the task is already complete.
If so, there is no need to suspend evaluation.
The purpose of the INotifyCompletion.OnCompleted method is to sign up a
“continuation” to the task; i.e., a delegate (of type System.Action) that will be invoked
once the task is complete.
The purpose of the GetResult method is to obtain the outcome of the task once it is
complete. This outcome may be successful completion, possibly with a result value, or it
may be an exception which is thrown by the GetResult method.
The expression await t is classified the same way as the expression
(t).GetAwaiter().GetResult(). Thus, if the return type of GetResult is void, the
await_expr ession  is classified as nothing. If it has a non- void return type T, the
await_expr ession  is classified as a value of type  T.
At run-time, the expression await t is evaluated as follows:
An awaiter  a is obtained by evaluating the expression (t).GetAwaiter().
A bool b is obtained by evaluating the expression (a).IsCompleted.
If b is false then evaluation depends on whether  a implements the interface
System.Runtime.CompilerServices.ICriticalNotifyCompletion (hereafter known as
ICriticalNotifyCompletion for brevity). This check is done at binding time; i.e., at
run-time if a has the compile-time type dynamic, and at compile-time otherwise.
Let r denote the resumption delegate ( §15.15 ):
If a does not implement ICriticalNotifyCompletion, then the expression ((a)
as INotifyCompletion).OnCompleted(r) is evaluated.12.9.8.3 Classification of await expressions
12.9.8.4 Run-time evaluation of await expressionsIf a does implement ICriticalNotifyCompletion, then the expression ((a) as
ICriticalNotifyCompletion).UnsafeOnCompleted(r) is evaluated.
Evaluation is then suspended, and control is returned to the current caller of the
async function.
Either immediately after (if b was true), or upon later invocation of the
resumption delegate (if b was false), the expression (a).GetResult() is
evaluated. If it returns a value, that value is the result of the await_expr ession .
Otherwise, the result is nothing.
An awaiter’s implementation of the interface methods INotifyCompletion.OnCompleted
and ICriticalNotifyCompletion.UnsafeOnCompleted should cause the delegate r to be
invoked at most once. Otherwise, the behavior of the enclosing async function is
undefined.
The <em>, /, %, +, and – operators are called the arithmetic operators.
ANTLR
If an operand of an arithmetic operator has the compile-time type dynamic, then the
expression is dynamically bound ( §12.3.3 ). In this case, the compile-time type of the
expression is dynamic, and the resolution described below will take place at run-time
using the run-time type of those operands that have the compile-time type dynamic.12.10 Arithmetic operators
12.10.1 General
multiplicative_expression
: unary_expression
| multiplicative_expression '</em>' unary_expression
| multiplicative_expression '/' unary_expression
| multiplicative_expression '%' unary_expression
;
additive_expression
: multiplicative_expression
| additive_expression '+' multiplicative_expression
| additive_expression '-' multiplicative_expression
;
12.10.2 Multiplication operatorFor an operation of the form x * y, binary operator overload resolution ( §12.4.5 ) is
applied to select a specific operator implementation. The operands are converted to the
parameter types of the selected operator, and the type of the result is the return type of
the operator.
The predefined multiplication operators are listed below. The operators all compute the
product of  x and y.
Integer multiplication:
C#
In a checked context, if the product is outside the range of the result type, a
System.OverflowException is thrown. In an unchecked context, overflows are not
reported and any significant high-order bits outside the range of the result type
are discarded.
Floating-point multiplication:
C#
The product is computed according to the rules of IEC 60559 arithmetic. The
following table lists the results of all possible combinations of nonzero finite
values, zeros, infinities, and NaNs. In the table, x and y are positive finite values. z
is the result of x * y, rounded to the nearest representable value. If the magnitude
of the result is too large for the destination type, z is infinity. Because of rounding,
z may be zero even though neither x nor y is zero.
+y -y +0 -0 +∞ -∞ NaN
+x +z -z +0 -0 +∞ -∞ NaN
-x -z +z -0 +0 -∞ +∞ NaN
+0 +0 -0 +0 -0 NaN NaN NaN
-0 -0 +0 -0 +0 NaN NaN NaNint operator  *(int x, int y);
uint operator  *(uint x, uint y);
long operator  *(long x, long y);
ulong operator  *(ulong x, ulong y);
float operator  *(float x, float y);
double operator  *(double x, double y);+y -y +0 -0 +∞ -∞ NaN
+∞ +∞ -∞ NaN NaN +∞ -∞ NaN
-∞ -∞ +∞ NaN NaN -∞ +∞ NaN
NaN NaN NaN NaN NaN NaN NaN NaN
(Except were otherwise noted, in the floating-point tables in §12.10.2 –§12.10.6  the
use of “ +” means the value is positive; the use of “ -” means the value is negative;
and the lack of a sign means the value may be positive or negative or has no sign
(NaN).)
Decimal multiplication:
C#
If the magnitude of the resulting value is too large to represent in the decimal
format, a System.OverflowException is thrown. Because of rounding, the result may
be zero even though neither operand is zero. The scale of the result, before any
rounding, is the sum of the scales of the two operands. Decimal multiplication is
equivalent to using the multiplication operator of type System.Decimal.
Lifted ( §12.4.8 ) forms of the unlifted predefined multiplication operators defined above
are also predefined.
For an operation of the form x / y, binary operator overload resolution ( §12.4.5 ) is
applied to select a specific operator implementation. The operands are converted to the
parameter types of the selected operator, and the type of the result is the return type of
the operator.
The predefined division operators are listed below. The operators all compute the
quotient of x and y.
Integer division:
C#decimal operator  *(decimal x, decimal y);
12.10.3 Division operator
int operator  /(int x, int y);
uint operator  /(uint x, uint y);If the value of the right operand is zero, a System.DivideByZeroException is thrown.
The division rounds the result towards zero. Thus the absolute value of the result is
the largest possible integer that is less than or equal to the absolute value of the
quotient of the two operands. The result is zero or positive when the two operands
have the same sign and zero or negative when the two operands have opposite
signs.
If the left operand is the smallest representable int or long value and the right
operand is –1, an overflow occurs. In a checked context, this causes a
System.ArithmeticException (or a subclass thereof) to be thrown. In an unchecked
context, it is implementation-defined as to whether a System.ArithmeticException
(or a subclass thereof) is thrown or the overflow goes unreported with the
resulting value being that of the left operand.
Floating-point division:
C#
The quotient is computed according to the rules of IEC 60559 arithmetic. The
following table lists the results of all possible combinations of nonzero finite
values, zeros, infinities, and NaNs. In the table, x and y are positive finite values. z
is the result of x / y, rounded to the nearest representable value.
+y -y +0 -0 +∞ -∞ NaN
+x +z -z +∞ -∞ +0 -0 NaN
-x -z +z -∞ +∞ -0 +0 NaN
+0 +0 -0 NaN NaN +0 -0 NaN
-0 -0 +0 NaN NaN -0 +0 NaN
+∞ +∞ -∞ +∞ -∞ NaN NaN NaN
-∞ -∞ +∞ -∞ +∞ NaN NaN NaN
NaN NaN NaN NaN NaN NaN NaN NaNlong operator  /(long x, long y);
ulong operator  /(ulong x, ulong y);
float operator  /(float x, float y);
double operator  /(double x, double y);Decimal division:
C#
If the value of the right operand is zero, a System.DivideByZeroException is thrown.
If the magnitude of the resulting value is too large to represent in the decimal
format, a System.OverflowException is thrown. Because of rounding, the result may
be zero even though the first operand is not zero. The scale of the result, before
any rounding, is the closest scale to the preferred scale that will preserve a result
equal to the exact result. The preferred scale is the scale of  x less the scale of  y.
Decimal division is equivalent to using the division operator of type
System.Decimal.
Lifted ( §12.4.8 ) forms of the unlifted predefined division operators defined above are
also predefined.
For an operation of the form x % y, binary operator overload resolution ( §12.4.5 ) is
applied to select a specific operator implementation. The operands are converted to the
parameter types of the selected operator, and the type of the result is the return type of
the operator.
The predefined remainder operators are listed below. The operators all compute the
remainder of the division between x and y.
Integer remainder:
C#
The result of x % y is the value produced by x – (x / y) * y. If y is zero, a
System.DivideByZeroException is thrown.
If the left operand is the smallest int or long value and the right operand is –1, a
System.OverflowException is thrown if and only if x / y would throw an exception.decimal operator  /(decimal x, decimal y);
12.10.4 Remainder operator
int operator  %(int x, int y);
uint operator  %(uint x, uint y);
long operator  %(long x, long y);
ulong operator  %(ulong x, ulong y);Floating-point remainder:
C#
The following table lists the results of all possible combinations of nonzero finite
values, zeros, infinities, and NaNs. In the table, x and y are positive finite values. z
is the result of x % y and is computed as x – n * y, where n is the largest
possible integer that is less than or equal to  x / y. This method of computing the
remainder is analogous to that used for integer operands, but differs from the IEC
60559 definition (in which n is the integer closest to  x / y).
+y -y +0 -0 +∞ -∞ NaN
+x +z +z NaN NaN +x +x NaN
-x -z -z NaN NaN -x -x NaN
+0 +0 +0 NaN NaN +0 +0 NaN
-0 -0 -0 NaN NaN -0 -0 NaN
+∞ NaN NaN NaN NaN NaN NaN NaN
-∞ NaN NaN NaN NaN NaN NaN NaN
NaN NaN NaN NaN NaN NaN NaN NaN
Decimal remainder:
C#
If the value of the right operand is zero, a System.DivideByZeroException is thrown.
It is implementation-defined when a System.ArithmeticException (or a subclass
thereof) is thrown. A conforming implementation shall not throw an exception for
x % y in any case where x / y does not throw an exception. The scale of the
result, before any rounding, is the larger of the scales of the two operands, and the
sign of the result, if non-zero, is the same as that of  x.
Decimal remainder is equivalent to using the remainder operator of type
System.Decimal.float operator  %(float x, float y);
double operator  %(double x, double y);
decimal operator  %(decimal x, decimal y);Note: These rules ensure that for all types, the result never has the opposite
sign of the left operand. end not e
Lifted ( §12.4.8 ) forms of the unlifted predefined remainder operators defined above are
also predefined.
For an operation of the form x + y, binary operator overload resolution ( §12.4.5 ) is
applied to select a specific operator implementation. The operands are converted to the
parameter types of the selected operator, and the type of the result is the return type of
the operator.
The predefined addition operators are listed below. For numeric and enumeration types,
the predefined addition operators compute the sum of the two operands. When one or
both operands are of type string, the predefined addition operators concatenate the
string representation of the operands.
Integer addition:
C#
In a checked context, if the sum is outside the range of the result type, a
System.OverflowException is thrown. In an unchecked context, overflows are not
reported and any significant high-order bits outside the range of the result type
are discarded.
Floating-point addition:
C#
The sum is computed according to the rules of IEC 60559 arithmetic. The following
table lists the results of all possible combinations of nonzero finite values, zeros,
infinities, and NaNs. In the table, x and y are nonzero finite values, and z is the
result of x + y. If x and y have the same magnitude but opposite signs, z is12.10.5 Addition operator
int operator  +(int x, int y);
uint operator  +(uint x, uint y);
long operator  +(long x, long y);
ulong operator  +(ulong x, ulong y
float operator  +(float x, float y);
double operator  +(double x, double y);positive zero. If x + y is too large to represent in the destination type, z is an
infinity with the same sign as x + y.
y +0 -0 +∞ -∞ NaN
x z x x +∞ -∞ NaN
+0 y +0 +0 +∞ –∞ NaN
-0 y +0 -0 +∞ -∞ NaN
+∞ +∞ +∞ +∞ +∞ NaN NaN
-∞ -∞ -∞ -∞ NaN -∞ NaN
NaN NaN NaN NaN NaN NaN NaN
Decimal addition:
C#
If the magnitude of the resulting value is too large to represent in the decimal
format, a System.OverflowException is thrown. The scale of the result, before any
rounding, is the larger of the scales of the two operands.
Decimal addition is equivalent to using the addition operator of type
System.Decimal.
Enumeration addition. Every enumeration type implicitly provides the following
predefined operators, where E is the enum type, and U is the underlying type
of E:
C#
At run-time these operators are evaluated exactly as (E)((U)x + (U)y).
String concatenation:
C#decimal operator  +(decimal x, decimal y);
E operator  +(E x, U y);
E operator  +(U x, E y);These overloads of the binary  + operator perform string concatenation. If an
operand of string concatenation is null, an empty string is substituted. Otherwise,
any non- string operand is converted to its string representation by invoking the
virtual ToString method inherited from type object. If ToString returns null, an
empty string is substituted.
Example :
C#
The output shown in the comments is the typical result on a US-English
system. The precise output might depend on the regional settings of the
execution environment. The string-concatenation operator itself behaves the
same way in each case, but the ToString methods implicitly called during
execution might be affected by regional settings.
end ex ample
The result of the string concatenation operator is a string that consists of the
characters of the left operand followed by the characters of the right operand. The
string concatenation operator never returns a null value. Astring operator  +(string x, string y);
string operator  +(string x, object y);
string operator  +(object x, string y);
class Test
{
static void Main()
{
string s = null;
Console.WriteLine( &quot;s = &gt;&quot; + s + &quot;&lt;&quot;);  // Displays s = &gt;&lt;
int i = 1;
Console.WriteLine( &quot;i = &quot; + i);         // Displays i = 1
float f = 1.2300E+15 F;
Console.WriteLine( &quot;f = &quot; + f);         // Displays f =<br />
1.23E+15
decimal d = 2.900m;
Console.WriteLine( &quot;d = &quot; + d);         // Displays d =<br />
2.900
}
}System.OutOfMemoryException may be thrown if there is not enough memory
available to allocate the resulting string.
Delegate combination. Every delegate type implicitly provides the following
predefined operator, where D is the delegate type:
C#
If the first operand is null, the result of the operation is the value of the second
operand (even if that is also null). Otherwise, if the second operand is null, then
the result of the operation is the value of the first operand. Otherwise, the result of
the operation is a new delegate instance whose invocation list consists of the
elements in the invocation list of the first operand, followed by the elements in the
invocation list of the second operand. That is, the invocation list of the resulting
delegate is the concatenation of the invocation lists of the two operands.
Note: For examples of delegate combination, see §12.10.6  and §20.6 . Since
System.Delegate is not a delegate type, operator + is not defined for it. end
note
Lifted ( §12.4.8 ) forms of the unlifted predefined addition operators defined above are
also predefined.
For an operation of the form x – y, binary operator overload resolution ( §12.4.5 ) is
applied to select a specific operator implementation. The operands are converted to the
parameter types of the selected operator, and the type of the result is the return type of
the operator.
The predefined subtraction operators are listed below. The operators all subtract y
from x.
Integer subtraction:
C#D operator  +(D x, D y);
12.10.6 Subtraction operator
int operator  –(int x, int y);
uint operator  –(uint x, uint y);
long operator  –(long x, long y);
ulong operator  –(ulong x, ulong yIn a checked context, if the difference is outside the range of the result type, a
System.OverflowException is thrown. In an unchecked context, overflows are not
reported and any significant high-order bits outside the range of the result type
are discarded.
Floating-point subtraction:
C#
The difference is computed according to the rules of IEC 60559 arithmetic. The
following table lists the results of all possible combinations of nonzero finite
values, zeros, infinities, and NaNs. In the table, x and y are nonzero finite values,
and z is the result of x – y. If x and y are equal, z is positive zero. If  x – y is too
large to represent in the destination type, z is an infinity with the same sign as x –
y.
y +0 -0 +∞ -∞ NaN
x z x x -∞ +∞ NaN
+0 -y +0 +0 -∞ +∞ NaN
-0 -y -0 +0 -∞ +∞ NaN
+∞ +∞ +∞ +∞ NaN +∞ NaN
-∞ -∞ -∞ -∞ -∞ NaN NaN
NaN NaN NaN NaN NaN NaN NaN
(In the above table, the -y entries denote the negation  of y, not that the value is
negative.)
Decimal subtraction:
C#
If the magnitude of the resulting value is too large to represent in the decimal
format, a System.OverflowException is thrown. The scale of the result, before any
rounding, is the larger of the scales of the two operands.float operator  –(float x, float y);
double operator  –(double x, double y);
decimal operator  –(decimal x, decimal y);Decimal subtraction is equivalent to using the subtraction operator of type
System.Decimal.
Enumeration subtraction. Every enumeration type implicitly provides the following
predefined operator, where E is the enum type, and U is the underlying type of  E:
C#
This operator is evaluated exactly as (U)((U)x – (U)y). In other words, the
operator computes the difference between the ordinal values of  x and y, and the
type of the result is the underlying type of the enumeration.
C#
This operator is evaluated exactly as (E)((U)x – y). In other words, the operator
subtracts a value from the underlying type of the enumeration, yielding a value of
the enumeration.
Delegate removal. Every delegate type implicitly provides the following predefined
operator, where D is the delegate type:
C#
The semantics are as follows:
If the first operand is null, the result of the operation is null.
Otherwise, if the second operand is null, then the result of the operation is the
value of the first operand.
Otherwise, both operands represent non-empty invocation lists ( §20.2 ).
If the lists compare equal, as determined by the delegate equality operator
(§12.12.9 ), the result of the operation is null.
Otherwise, the result of the operation is a new invocation list consisting of
the first operand’s list with the second operand’s entries removed from it,
provided the second operand’s list is a sublist of the first’s. (T o determine
sublist equality, corresponding entries are compared as for the delegate
equality operator.) If the second operand’s list matches multiple sublists ofU operator  –(E x, E y);
E operator  –(E x, U y);
D operator  –(D x, D y);contiguous entries in the first operand’s list, the last matching sublist of
contiguous entries is removed.
Otherwise, the result of the operation is the value of the left operand.
Neither of the operands’ lists (if any) is changed in the process.
Example :
C#
end ex ample
Lifted ( §12.4.8 ) forms of the unlifted predefined subtraction operators defined above are
also predefined.
The &lt;&lt; and &gt;&gt; operators are used to perform bit-shifting operations.delegate  void D(int x);
class C
{
public static void M1(int i) { ... }
public static void M2(int i) { ... }
}
class Test
{
static void Main()
{
D cd1 = new D(C.M1);
D cd2 = new D(C.M2);
D list = null;
list = null - cd1;                             // null
list = (cd1 + cd2 + cd2 + cd1) - null;         // M1 + M2 +<br />
M2 + M1
list = (cd1 + cd2 + cd2 + cd1) - cd1;          // M1 + M2 +<br />
M2
list = (cd1 + cd2 + cd2 + cd1) - (cd1 + cd2);  // M2 + M1
list = (cd1 + cd2 + cd2 + cd1) - (cd2 + cd2);  // M1 + M1
list = (cd1 + cd2 + cd2 + cd1) - (cd2 + cd1);  // M1 + M2
list = (cd1 + cd2 + cd2 + cd1) - (cd1 + cd1);  // M1 + M2 +<br />
M2 + M1
list = (cd1 + cd2 + cd2 + cd1) - (cd1 + cd2 + cd2 + cd1);<br />
// null
}
}
12.11 Shift operatorsANTLR
If an operand of a shift_expr ession  has the compile-time type dynamic, then the
expression is dynamically bound ( §12.3.3 ). In this case, the compile-time type of the
expression is dynamic, and the resolution described below will take place at run-time
using the run-time type of those operands that have the compile-time type dynamic.
For an operation of the form x &lt;&lt; count or x &gt;&gt; count, binary operator overload
resolution ( §12.4.5 ) is applied to select a specific operator implementation. The
operands are converted to the parameter types of the selected operator, and the type of
the result is the return type of the operator.
When declaring an overloaded shift operator, the type of the first operand shall always
be the class or struct containing the operator declaration, and the type of the second
operand shall always be int.
The predefined shift operators are listed below.
Shift left:
C#
The &lt;&lt; operator shifts x left by a number of bits computed as described below.
The high-order bits outside the range of the result type of  x are discarded, the
remaining bits are shifted left, and the low-order empty bit positions are set to
zero.
Shift right:
C#shift_expression
: additive_expression
| shift_expression '&lt;&lt;' additive_expression
| shift_expression right_shift additive_expression
;
int operator  &lt;&lt;(int x, int count);
uint operator  &lt;&lt;(uint x, int count);
long operator  &lt;&lt;(long x, int count);
ulong operator  &lt;&lt;(ulong x, int count);
int operator  &gt;&gt;(int x, int count);
uint operator  &gt;&gt;(uint x, int count);The &gt;&gt; operator shifts x right by a number of bits computed as described below.
When x is of type int or long, the low-order bits of  x are discarded, the
remaining bits are shifted right, and the high-order empty bit positions are set to
zero if x is non-negative and set to one if x is negative.
When x is of type uint or ulong, the low-order bits of  x are discarded, the
remaining bits are shifted right, and the high-order empty bit positions are set to
zero.
For the predefined operators, the number of bits to shift is computed as follows:
When the type of  x is int or uint, the shift count is given by the low-order five
bits of count. In other words, the shift count is computed from count &amp; 0x1F.
When the type of  x is long or ulong, the shift count is given by the low-order six
bits of count. In other words, the shift count is computed from count &amp; 0x3F.
If the resulting shift count is zero, the shift operators simply return the value of  x.
Shift operations never cause overflows and produce the same results in checked and
unchecked contexts.
When the left operand of the &gt;&gt; operator is of a signed integral type, the operator
performs an arithmetic  shift right wherein the value of the most significant bit (the sign
bit) of the operand is propagated to the high-order empty bit positions. When the left
operand of the &gt;&gt; operator is of an unsigned integral type, the operator performs a
logical  shift right wherein high-order empty bit positions are always set to zero. T o
perform the opposite operation of that inferred from the operand type, explicit casts
can be used.
Example : If x is a variable of type int, the operation unchecked ((int)((uint)x &gt;&gt;
y)) performs a logical shift right of  x. end ex ample
Lifted ( §12.4.8 ) forms of the unlifted predefined shift operators defined above are also
predefined.long operator  &gt;&gt;(long x, int count);
ulong operator  &gt;&gt;(ulong x, int count);
12.12 Relational and type-testing operatorsThe ==, !=, &lt;, &gt;, &lt;=, &gt;=, is, and as operators are called the relational and type-
testing operators.
ANTLR
Note: Lookup for the right operand of the is operator must first test as a type, then
as an expression  which may span multiple tokens. In the case where the operand is
an expreesion , the pattern expression must have precedence at least as high as
shift_expr ession . end not e
The is operator is described in §12.12.12  and the as operator is described in §12.12.13 .
The ==, !=, &lt;, &gt;, &lt;= and &gt;= operators are comparison oper ators.
If a default_lit eral (§12.8.20 ) is used as an operand of a &lt;, &gt;, &lt;=, or &gt;= operator, a
compile-time error occurs. If a default_lit eral is used as both operands of a == or !=
operator, a compile-time error occurs. If a default_lit eral is used as the left operand of
the is or as operator, a compile-time error occurs.
If an operand of a comparison operator has the compile-time type dynamic, then the
expression is dynamically bound ( §12.3.3 ). In this case the compile-time type of the
expression is dynamic, and the resolution described below will take place at run-time
using the run-time type of those operands that have the compile-time type dynamic.
For an operation of the form x «op» y, where «op» is a comparison operator, overload
resolution ( §12.4.5 ) is applied to select a specific operator implementation. The12.12.1 General
relational_expression
: shift_expression
| relational_expression '&lt;' shift_expression
| relational_expression '&gt;' shift_expression
| relational_expression '&lt;=' shift_expression
| relational_expression '&gt;=' shift_expression
| relational_expression 'is' type
| relational_expression 'is' pattern
| relational_expression 'as' type
;
equality_expression
: relational_expression
| equality_expression '==' relational_expression
| equality_expression '!=' relational_expression
;operands are converted to the parameter types of the selected operator, and the type of
the result is the return type of the operator. If both operands of an equality_expr ession
are the null literal, then overload resolution is not performed and the expression
evaluates to a constant value of true or false according to whether the operator is ==
or !=.
The predefined comparison operators are described in the following subclauses. All
predefined comparison operators return a result of type bool, as described in the
following table.
Operation Result
x == y true if x is equal to y, false otherwise
x != y true if x is not equal to y, false otherwise
x &lt; y true if x is less than y, false otherwise
x &gt; y true if x is greater than y, false otherwise
x &lt;= y true if x is less than or equal to y, false otherwise
x &gt;= y true if x is greater than or equal to y, false otherwise
The predefined integer comparison operators are:
C#12.12.2 Integer comparison operators
bool operator  ==(int x, int y);
bool operator  ==(uint x, uint y);
bool operator  ==(long x, long y);
bool operator  ==(ulong x, ulong y);
bool operator  !=(int x, int y);
bool operator  !=(uint x, uint y);
bool operator  !=(long x, long y);
bool operator  !=(ulong x, ulong y);
bool operator  &lt;(int x, int y);
bool operator  &lt;(uint x, uint y);
bool operator  &lt;(long x, long y);
bool operator  &lt;(ulong x, ulong y);
bool operator  &gt;(int x, int y);
bool operator  &gt;(uint x, uint y);
bool operator  &gt;(long x, long y);
bool operator  &gt;(ulong x, ulong y);Each of these operators compares the numeric values of the two integer operands and
returns a bool value that indicates whether the particular relation is true or false.
Lifted ( §12.4.8 ) forms of the unlifted predefined integer comparison operators defined
above are also predefined.
The predefined floating-point comparison operators are:
C#
The operators compare the operands according to the rules of the IEC 60559 standard:
If either operand is NaN, the result is false for all operators except  !=, for which the
result is true. For any two operands, x != y always produces the same result as !
(x == y). However, when one or both operands are NaN, the &lt;, &gt;, &lt;=, and &gt;=
operators do not produce the same results as the logical negation of the opposite
operator.bool operator  &lt;=(int x, int y);
bool operator  &lt;=(uint x, uint y);
bool operator  &lt;=(long x, long y);
bool operator  &lt;=(ulong x, ulong y);
bool operator  &gt;=(int x, int y);
bool operator  &gt;=(uint x, uint y);
bool operator  &gt;=(long x, long y);
bool operator  &gt;=(ulong x, ulong y);
12.12.3 Floating-point comparison operators
bool operator  ==(float x, float y);
bool operator  ==(double x, double y);
bool operator  !=(float x, float y);
bool operator  !=(double x, double y);
bool operator  &lt;(float x, float y);
bool operator  &lt;(double x, double y);
bool operator  &gt;(float x, float y);
bool operator  &gt;(double x, double y);
bool operator  &lt;=(float x, float y);
bool operator  &lt;=(double x, double y);
bool operator  &gt;=(float x, float y);
bool operator  &gt;=(double x, double y);Example : If either of  x and y is NaN, then x &lt; y is false, but !(x &gt;= y) is true.
end ex ample
When neither operand is NaN, the operators compare the values of the two floating-
point operands with respect to the ordering
C#
where min and max are the smallest and largest positive finite values that can be
represented in the given floating-point format. Notable effects of this ordering are:
Negative and positive zeros are considered equal.
A negative infinity is considered less than all other values, but equal to another
negative infinity.
A positive infinity is considered greater than all other values, but equal to another
positive infinity.
Lifted ( §12.4.8 ) forms of the unlifted predefined floating-point comparison operators
defined above are also predefined.
The predefined decimal comparison operators are:
C#
Each of these operators compares the numeric values of the two decimal operands and
returns a bool value that indicates whether the particular relation is true or false. Each
decimal comparison is equivalent to using the corresponding relational or equality
operator of type System.Decimal.
Lifted ( §12.4.8 ) forms of the unlifted predefined decimal comparison operators defined
above are also predefined.–∞ &lt; –max &lt; ... &lt; –min &lt; – 0.0 == +0.0 &lt; +min &lt; ... &lt; +max &lt; +∞
12.12.4 Decimal comparison operators
bool operator  ==(decimal x, decimal y);
bool operator  !=(decimal x, decimal y);
bool operator  &lt;(decimal x, decimal y);
bool operator  &gt;(decimal x, decimal y);
bool operator  &lt;=(decimal x, decimal y);
bool operator  &gt;=(decimal x, decimal y);The predefined Boolean equality operators are:
C#
The result of == is true if both x and y are true or if both x and y are false.
Otherwise, the result is false.
The result of != is false if both x and y are true or if both x and y are false.
Otherwise, the result is true. When the operands are of type bool, the != operator
produces the same result as the ^ operator.
Lifted ( §12.4.8 ) forms of the unlifted predefined Boolean equality operators defined
above are also predefined.
Every enumeration type implicitly provides the following predefined comparison
operators
C#
The result of evaluating x «op» y, where x and y are expressions of an enumeration
type E with an underlying type  U, and «op» is one of the comparison operators, is
exactly the same as evaluating ((U)x) «op» ((U)y). In other words, the enumeration
type comparison operators simply compare the underlying integral values of the two
operands.
Lifted ( §12.4.8 ) forms of the unlifted predefined enumeration comparison operators
defined above are also predefined.12.12.5 Boolean equality operators
bool operator  ==(bool x, bool y);
bool operator  !=(bool x, bool y);
12.12.6 Enumeration comparison operators
bool operator  ==(E x, E y);
bool operator  !=(E x, E y);
bool operator  &lt;(E x, E y);
bool operator  &gt;(E x, E y);
bool operator  &lt;=(E x, E y);
bool operator  &gt;=(E x, E y);Every class type  C implicitly provides the following predefined reference type equality
operators:
C#
unless predefined equality operators otherwise exist for  C (for example, when  C is
string or System.Delegate).
The operators return the result of comparing the two references for equality or non-
equality. operator == returns true if and only if x and y refer to the same instance or
are both null, while operator != returns true if and only if operator == with the same
operands would return false.
In addition to normal applicability rules ( §12.6.4.2 ), the predefined reference type
equality operators require one of the following in order to be applicable:
Both operands are a value of a type known to be a reference_type  or the literal
null. Furthermore, an identity or explicit reference conversion ( §10.3.5 ) exists from
either operand to the type of the other operand.
One operand is the literal null, and the other operand is a value of type  T
where T is a type_p aramet er that is not known to be a value type, and does not
have the value type constraint.
If at runtime T is a non-nullable value type, the result of == is false and the
result of != is true.
If at runtime T is a nullable value type, the result is computed from the
HasValue property of the operand, as described in ( §12.12.10 ).
If at runtime T is a reference type, the result is true if the operand is null, and
false otherwise.
Unless one of these conditions is true, a binding-time error occurs.
Note: Notable implications of these rules are:
It is a binding-time error to use the predefined reference type equality
operators to compare two references that are known to be different at
binding-time. For example, if the binding-time types of the operands are two
class types, and if neither derives from the other, then it would be impossible12.12.7 Reference type equality operators
bool operator  ==(C x, C y);
bool operator  !=(C x, C y);for the two operands to reference the same object. Thus, the operation is
considered a binding-time error.
The predefined reference type equality operators do not permit value type
operands to be compared (except when type parameters are compared to
null, which is handled specially).
Operands of predefined reference type equality operators are never boxed. It
would be meaningless to perform such boxing operations, since references to
the newly allocated boxed instances would necessarily differ from all other
references.
For an operation of the form x == y or x != y, if any applicable user-defined
operator == or operator != exists, the operator overload resolution rules ( §12.4.5 )
will select that operator instead of the predefined reference type equality operator.
It is always possible to select the predefined reference type equality operator by
explicitly casting one or both of the operands to type object.
end not e
Example : The following example checks whether an argument of an unconstrained
type parameter type is null.
C#
The x == null construct is permitted even though  T could represent a non-nullable
value type, and the result is simply defined to be false when T is a non-nullable
value type.
end ex ample
For an operation of the form x == y or x != y, if any applicable operator == or
operator != exists, the operator overload resolution ( §12.4.5 ) rules will select thatclass C<T>
{
void F(T x)
{
if (x == null)
{
throw new ArgumentNullException();
}
...
}
}operator instead of the predefined reference type equality operator.
Note: It is always possible to select the predefined reference type equality operator
by explicitly casting both of the operands to type object. end not e
Example : The example
C#
produces the output
Console
The s and t variables refer to two distinct string instances containing the same
characters. The first comparison outputs True because the predefined string
equality operator ( §12.12.8 ) is selected when both operands are of type string. The
remaining comparisons all output False because the overload of operator == in the
string type is not applicable when either operand has a binding-time type of
object.
Note that the above technique is not meaningful for value types. The example
C#class Test
{
static void Main()
{
string s = &quot;Test&quot;;
string t = string.Copy(s);
Console.WriteLine(s == t);
Console.WriteLine(( object)s == t);
Console.WriteLine(s == ( object)t);
Console.WriteLine(( object)s == (object)t);
}
}
True
False
False
False
class Test
{
static void Main()
{outputs False because the casts create references to two separate instances of
boxed int values.
end ex ample
The predefined string equality operators are:
C#
Two string values are considered equal when one of the following is true:
Both values are null.
Both values are non- null references to string instances that have identical lengths
and identical characters in each character position.
The string equality operators compare string values rather than string references. When
two separate string instances contain the exact same sequence of characters, the values
of the strings are equal, but the references are different.
Note: As described in §12.12.7 , the reference type equality operators can be used to
compare string references instead of string values. end not e
The predefined delegate equality operators are:
C#
Two delegate instances are considered equal as follows:        int i = 123;
int j = 123;
Console.WriteLine(( object)i == (object)j);
}
}
12.12.8 String equality operators
bool operator  ==(string x, string y);
bool operator  !=(string x, string y);
12.12.9 Delegate equality operators
bool operator  ==(System.Delegate x, System.Delegate y);
bool operator  !=(System.Delegate x, System.Delegate y);If either of the delegate instances is null, they are equal if and only if both are
null.
If the delegates have different run-time type, they are never equal.
If both of the delegate instances have an invocation list ( §20.2 ), those instances are
equal if and only if their invocation lists are the same length, and each entry in
one’s invocation list is equal (as defined below) to the corresponding entry, in
order, in the other’s invocation list.
The following rules govern the equality of invocation list entries:
If two invocation list entries both refer to the same static method then the entries
are equal.
If two invocation list entries both refer to the same non-static method on the same
target object (as defined by the reference equality operators) then the entries are
equal.
Invocation list entries produced from evaluation of semantically identical
anonymous functions ( §12.19 ) with the same (possibly empty) set of captured
outer variable instances are permitted (but not required) to be equal.
If operator overload resolution resolves to either delegate equality operator, and the
binding-time types of both operands are delegate types as described in §20 rather than
System.Delegate, and there is no identity conversion between the binding-type operand
types, a binding-time error occurs.
Note: This rule prevents comparisons which can never consider non- null values as
equal due to being references to instances of different types of delegates. end not e
The == and != operators permit one operand to be a value of a nullable value type and
the other to be the null literal, even if no predefined or user-defined operator (in
unlifted or lifted form) exists for the operation.
For an operation of one of the forms
C#
where x is an expression of a nullable value type, if operator overload resolution
(§12.4.5 ) fails to find an applicable operator, the result is instead computed from the12.12.10 Equality operators between nullable value types
and the null literal
x == null    null == x    x != null    null != xHasValue property of  x. Specifically, the first two forms are translated into !x.HasValue,
and the last two forms are translated into x.HasValue.
The tuple equality operators are applied pairwise to the elements of the tuple operands
in lexical order.
If each operand x and y of a == or != operator is classified either as a tuple or as a
value with a tuple type ( §8.3.11 ), the operator is a tuple equality oper ator.
If an operand e is classified as a tuple, the elements e1...en shall be the results of
evaluating the element expressions of the tuple expression. Otherwise if e is a value of a
tuple type, the elements shall be t.Item1...t.Itemn where t is the result of evaluating
e.
The operands x and y of a tuple equality operator shall have the same arity, or a
compile time error occurs. For each pair of elements xi and yi, the same equality
operator shall apply, and shall yield a result of type bool, dynamic, a type that has an
implicit conversion to bool, or a type that defines the true and false operators.
The tuple equality operator x == y is evaluated as follows:
The left side operand x is evaluated.
The right side operand y is evaluated.
For each pair of elements xi and yi in lexical order:
The operator xi == yi is evaluated, and a result of type bool is obtained in the
following way:
If the comparison yielded a bool then that is the result.
Otherwise if the comparison yielded a dynamic then the operator false is
dynamically invoked on it, and the resulting bool value is negated with the !
operator.
Otherwise, if the type of the comparison has an implicit conversion to bool,
that conversion is applied.
Otherwise, if the type of the comparison has an operator false, that
operator is invoked and the resulting bool value is negated with the !
operator.
If the resulting bool is false, then no further evaluation occurs, and the result
of the tuple equality operator is false.12.12.11 Tuple equality operatorsIf all element comparisons yielded true, the result of the tuple equality operator is
true.
The tuple equality operator x != y is evaluated as follows:
The left side operand x is evaluated.
The right side operand y is evaluated.
For each pair of elements xi and yi in lexical order:
The operator xi != yi is evaluated, and a result of type bool is obtained in the
following way:
If the comparison yielded a bool then that is the result.
Otherwise if the comparison yielded a dynamic then the operator true is
dynamically invoked on it, and the resulting bool value is the result.
Otherwise, if the type of the comparison has an implicit conversion to bool,
that conversion is applied.
Otherwise, if the type of the comparison has an operator true, that operator
is invoked and the resulting bool value is the result.
If the resulting bool is true, then no further evaluation occurs, and the result of
the tuple equality operator is true.
If all element comparisons yielded false, the result of the tuple equality operator
is false.
There are two forms of the is operator. One is the is-type oper ator, which has a type on
the right-hand-side. The other is the is-pattern oper ator, which has a pattern on the
right-hand-side.
The is-type oper ator is used to check if the run-time type of an object is compatible with
a given type. The check is performed at runtime. The result of the operation  E is T,
where E is an expression and T is a type other than dynamic, is a Boolean value
indicating whether  E is non-null and can successfully be converted to type  T by a
reference conversion, a boxing conversion, an unboxing conversion, a wrapping
conversion, or an unwrapping conversion.
The operation is evaluated as follows:</p>
<ol>
<li>If E is an anonymous function or method group, a compile-time error occurs12.12.12 The is operator
12.12.12.1 The is-type operator2. If E is the null literal, or if the value of  E is null, the result is false.</li>
<li>Otherwise:</li>
<li>Let R be the runtime type of E.</li>
<li>Let D be derived from R as follows:</li>
<li>If R is a nullable value type, D is the underlying type of R.</li>
<li>Otherwise, D is R.</li>
<li>The result depends on  D and T as follows:</li>
<li>If T is a reference type, the result is true if:
D and T are the same type,
D is a reference type and an implicit reference conversion from  D to T exists,
or
Either: D is a value type and a boxing conversion from  D to T exists.
Or: D is a value type and T is an interface type implemented by D.</li>
<li>If T is a nullable value type, the result is true if D is the underlying type of  T.</li>
<li>If T is a non-nullable value type, the result is true if D and T are the same type.</li>
<li>Otherwise, the result is false.
User defined conversions are not considered by the is operator.
Note: As the is operator is evaluated at runtime, all type arguments have been
substituted and there are no open types ( §8.4.3 ) to consider. end not e
Note: The is operator can be understood in terms of compile-time types and
conversions as follows, where C is the compile-time type of E:
If the compile-time type of e is the same as T, or if an implicit reference
conversion ( §10.2.8 ), boxing conversion ( §10.2.9 ), wrapping conversion ( §10.6 ),
or an explicit unwrapping conversion ( §10.6 ) exists from the compile-time type
of E to T:
If C is of a non-nullable value type, the result of the operation is true.
Otherwise, the result of the operation is equivalent to evaluating E != null.
Otherwise, if an explicit reference conversion ( §10.3.5 ) or unboxing conversion
(§10.3.7 ) exists from C to T, or if C or T is an open type ( §8.4.3 ), then runtime
checks as above shall be peformed.
Otherwise, no reference, boxing, wrapping, or unwrapping conversion of E to
type T is possible, and the result of the operation is false. A compiler may
implement optimisations based on the compile-time type.end not e
The is-pattern oper ator is used to check if the value computed by an expression matches
a given pattern ( §11). The check is performed at runtime. The result of the is-pattern
operator is true if the value matches the pattern; otherwise it is false.
For an expression of the form E is P, where E is a relational expression of type T and
P is a pattern, it is a compile-time error if any of the following hold:
E does not designate a value or does not have a type.
The pattern P is not applicable ( §11.2 ) to the type T.
The as operator is used to explicitly convert a value to a given reference type or
nullable value type. Unlike a cast expression ( §12.9.7 ), the as operator never throws an
exception. Instead, if the indicated conversion is not possible, the resulting value is null.
In an operation of the form E as T, E shall be an expression and  T shall be a reference
type, a type parameter known to be a reference type, or a nullable value type.
Furthermore, at least one of the following shall be true, or otherwise a compile-time
error occurs:
An identity ( §10.2.2 ), implicit nullable ( §10.2.6 ), implicit reference ( §10.2.8 ), boxing
(§10.2.9 ), explicit nullable ( §10.3.4 ), explicit reference ( §10.3.5 ), or wrapping ( §8.3.12 )
conversion exists from  E to T.
The type of  E or T is an open type.
E is the null literal.
If the compile-time type of E is not dynamic, the operation  E as T produces the same
result as
C#
except that  E is only evaluated once. The compiler can be expected to optimize  E as T
to perform at most one runtime type check as opposed to the two runtime type checks
implied by the expansion above.12.12.12.2 The is-pattern operator
12.12.13 The as operator
E is T ? (T)(E) : (T) nullIf the compile-time type of  E is dynamic, unlike the cast operator the as operator is not
dynamically bound ( §12.3.3 ). Therefore the expansion in this case is:
C#
Note that some conversions, such as user defined conversions, are not possible with the
as operator and should instead be performed using cast expressions.
Example : In the example
C#
the type parameter  T of G is known to be a reference type, because it has the class
constraint. The type parameter  U of H is not however; hence the use of the as
operator in  H is disallowed.
end ex ample
The &amp;, ^, and | operators are called the logical operators.E is T ? (T)( object)(E) : (T) null
class X
{
public string F(object o)
{
return o as string;  // OK, string is a reference type
}
public T G<T>( object o)
where T : Attribute
{
return o as T;       // Ok, T has a class constraint
}
public U H<U>( object o)
{
return o as U;       // Error, U is unconstrained
}
}
12.13 Logical operators
12.13.1 GeneralANTLR
If an operand of a logical operator has the compile-time type dynamic, then the
expression is dynamically bound ( §12.3.3 ). In this case the compile-time type of the
expression is dynamic, and the resolution described below will take place at run-time
using the run-time type of those operands that have the compile-time type dynamic.
For an operation of the form x «op» y, where «op» is one of the logical operators,
overload resolution ( §12.4.5 ) is applied to select a specific operator implementation. The
operands are converted to the parameter types of the selected operator, and the type of
the result is the return type of the operator.
The predefined logical operators are described in the following subclauses.
The predefined integer logical operators are:
C#and_expression
: equality_expression
| and_expression '&amp;' equality_expression
;
exclusive_or_expression
: and_expression
| exclusive_or_expression '^' and_expression
;
inclusive_or_expression
: exclusive_or_expression
| inclusive_or_expression '|' exclusive_or_expression
;
12.13.2 Integer logical operators
int operator  &amp;(int x, int y);
uint operator  &amp;(uint x, uint y);
long operator  &amp;(long x, long y);
ulong operator  &amp;(ulong x, ulong y);
int operator  |(int x, int y);
uint operator  |(uint x, uint y);
long operator  |(long x, long y);
ulong operator  |(ulong x, ulong y);
int operator  ^(int x, int y);
uint operator  ^(uint x, uint y);The &amp; operator computes the bitwise logical AND of the two operands, the | operator
computes the bitwise logical OR of the two operands, and the ^ operator computes the
bitwise logical exclusive OR of the two operands. No overflows are possible from these
operations.
Lifted ( §12.4.8 ) forms of the unlifted predefined integer logical operators defined above
are also predefined.
Every enumeration type  E implicitly provides the following predefined logical operators:
C#
The result of evaluating x «op» y, where x and y are expressions of an enumeration
type E with an underlying type  U, and «op» is one of the logical operators, is exactly the
same as evaluating (E)((U)x «op» (U)y). In other words, the enumeration type logical
operators simply perform the logical operation on the underlying type of the two
operands.
Lifted ( §12.4.8 ) forms of the unlifted predefined enumeration logical operators defined
above are also predefined.
The predefined Boolean logical operators are:
C#
The result of x &amp; y is true if both x and y are true. Otherwise, the result is false.
The result of x | y is true if either x or y is true. Otherwise, the result is false.long operator  ^(long x, long y);
ulong operator  ^(ulong x, ulong y);
12.13.3 Enumeration logical operators
E operator  &amp;(E x, E y);
E operator  |(E x, E y);
E operator  ^(E x, E y);
12.13.4 Boolean logical operators
bool operator  &amp;(bool x, bool y);
bool operator  |(bool x, bool y);
bool operator  ^(bool x, bool y);The result of x ^ y is true if x is true and y is false, or x is false and y is true.
Otherwise, the result is false. When the operands are of type bool, the ^ operator
computes the same result as the != operator.
The nullable Boolean type bool? can represent three values, true, false, and null.
As with the other binary operators, lifted forms of the logical operators  &amp; and |
(§12.13.4 ) are also pre-defined:
C#
The semantics of the lifted  &amp; and | operators are defined by the following table:
x y x &amp; y x | y
true true true true
true false false true
true null null true
false true false true
false false false false
false null false null
null true null true
null false false null
null null null null
Note: The bool? type is conceptually similar to the three-valued type used for
Boolean expressions in SQL. The table above follows the same semantics as SQL,
whereas applying the rules of §12.4.8  to the &amp; and | operators would not. The rules
of §12.4.8  already provide SQL-like semantics for the lifted  ^ operator. end not e12.13.5 Nullable Boolean &amp; and | operators
bool? operator  &amp;(bool? x, bool? y);
bool? operator  |(bool? x, bool? y);
12.14 Conditional logical operatorsThe &amp;&amp; and || operators are called the conditional logical operators. They are also
called the “short-circuiting” logical operators.
ANTLR
The &amp;&amp; and || operators are conditional versions of the &amp; and | operators:
The operation x &amp;&amp; y corresponds to the operation x &amp; y, except that y is
evaluated only if x is not false.
The operation x || y corresponds to the operation x | y, except that y is
evaluated only if x is not true.
Note: The reason that short circuiting uses the ‘not true’ and ‘not false’ conditions is
to enable user-defined conditional operators to define when short circuiting applies.
User-defined types could be in a state where operator true returns false and
operator false returns false. In those cases, neither &amp;&amp; nor || would short circuit.
end not e
If an operand of a conditional logical operator has the compile-time type dynamic, then
the expression is dynamically bound ( §12.3.3 ). In this case the compile-time type of the
expression is dynamic, and the resolution described below will take place at run-time
using the run-time type of those operands that have the compile-time type dynamic.
An operation of the form x &amp;&amp; y or x || y is processed by applying overload
resolution ( §12.4.5 ) as if the operation was written x &amp; y or x | y. Then,
If overload resolution fails to find a single best operator, or if overload resolution
selects one of the predefined integer logical operators or nullable Boolean logical
operators ( §12.13.5 ), a binding-time error occurs.
Otherwise, if the selected operator is one of the predefined Boolean logical
operators ( §12.13.4 ), the operation is processed as described in §12.14.2 .12.14.1 General
conditional_and_expression
: inclusive_or_expression
| conditional_and_expression '&amp;&amp;' inclusive_or_expression
;
conditional_or_expression
: conditional_and_expression
| conditional_or_expression '||' conditional_and_expression
;Otherwise, the selected operator is a user-defined operator, and the operation is
processed as described in §12.14.3 .
It is not possible to directly overload the conditional logical operators. However,
because the conditional logical operators are evaluated in terms of the regular logical
operators, overloads of the regular logical operators are, with certain restrictions, also
considered overloads of the conditional logical operators. This is described further in
§12.14.3 .
When the operands of  &amp;&amp; or || are of type bool, or when the operands are of types
that do not define an applicable operator &amp; or operator |, but do define implicit
conversions to bool, the operation is processed as follows:
The operation x &amp;&amp; y is evaluated as x ? y : false. In other words, x is first
evaluated and converted to type bool. Then, if x is true, y is evaluated and
converted to type bool, and this becomes the result of the operation. Otherwise,
the result of the operation is false.
The operation x || y is evaluated as x ? true : y. In other words, x is first
evaluated and converted to type bool. Then, if x is true, the result of the
operation is true. Otherwise, y is evaluated and converted to type bool, and this
becomes the result of the operation.
When the operands of  &amp;&amp; or || are of types that declare an applicable user-defined
operator &amp; or operator |, both of the following shall be true, where  T is the type in
which the selected operator is declared:
The return type and the type of each parameter of the selected operator shall
be T. In other words, the operator shall compute the logical AND or the logical OR
of two operands of type  T, and shall return a result of type  T.
T shall contain declarations of operator true and operator false.
A binding-time error occurs if either of these requirements is not satisfied. Otherwise,
the &amp;&amp; or || operation is evaluated by combining the user-defined operator true or
operator false with the selected user-defined operator:
The operation x &amp;&amp; y is evaluated as T.false(x) ? x : T.&amp;(x, y), where
T.false(x) is an invocation of the operator false declared in  T, and T.&amp;(x, y) is12.14.2 Boolean conditional logical operators
12.14.3 User-defined conditional logical operatorsan invocation of the selected operator &amp;. In other words, x is first evaluated and
operator false is invoked on the result to determine if x is definitely false. Then, if
x is definitely false, the result of the operation is the value previously computed
for x. Otherwise, y is evaluated, and the selected operator &amp; is invoked on the
value previously computed for x and the value computed for y to produce the
result of the operation.
The operation x || y is evaluated as T.true(x) ? x : T.|(x, y), where T.true(x)
is an invocation of the operator true declared in  T, and T.|(x, y) is an
invocation of the selected operator |. In other words, x is first evaluated and
operator true is invoked on the result to determine if x is definitely true. Then, if
x is definitely true, the result of the operation is the value previously computed
for x. Otherwise, y is evaluated, and the selected operator | is invoked on the
value previously computed for x and the value computed for y to produce the
result of the operation.
In either of these operations, the expression given by x is only evaluated once, and the
expression given by y is either not evaluated or evaluated exactly once.
The ?? operator is called the null coalescing operator.
ANTLR
In a null coalescing expression of the form a ?? b, if a is non-null, the result is a;
otherwise, the result is  b. The operation evaluates b only if a is null.
The null coalescing operator is right-associative, meaning that operations are grouped
from right to left.
Example : An expression of the form a ?? b ?? c is evaluated as a  ?? (b ?? c). In
general terms, an expression of the form E1 ?? E2 ?? ... ?? EN returns the first of
the operands that is non- null, or null if all operands are null. end ex ample12.15 The null coalescing operator
null_coalescing_expression
: conditional_or_expression
| conditional_or_expression '??' null_coalescing_expression
| throw_expression
;The type of the expression a ?? b depends on which implicit conversions are available
on the operands. In order of preference, the type of a ?? b is A₀, A, or B, where A is
the type of  a (provided that  a has a type), B is the type of  b(provided that  b has a
type), and A₀ is the underlying type of  A if A is a nullable value type, or  A otherwise.
Specifically, a ?? b is processed as follows:
If A exists and is not a nullable value type or a reference type, a compile-time error
occurs.
Otherwise, if A exists and b is a dynamic expression, the result type is dynamic. At
run-time, a is first evaluated. If a is not null, a is converted to dynamic, and this
becomes the result. Otherwise, b is evaluated, and this becomes the result.
Otherwise, if A exists and is a nullable value type and an implicit conversion exists
from b to A₀, the result type is  A₀. At run-time, a is first evaluated. If a is not
null, a is unwrapped to type  A₀, and this becomes the result. Otherwise, b is
evaluated and converted to type  A₀, and this becomes the result.
Otherwise, if A exists and an implicit conversion exists from b to A, the result type
is A. At run-time, a is first evaluated. If a is not null, a becomes the result.
Otherwise, b is evaluated and converted to type  A, and this becomes the result.
Otherwise, if A exists and is a nullable value type, b has a type  B and an implicit
conversion exists from A₀ to B, the result type is  B. At run-time, a is first
evaluated. If a is not null, a is unwrapped to type  A₀ and converted to type  B,
and this becomes the result. Otherwise, b is evaluated and becomes the result.
Otherwise, if b has a type  B and an implicit conversion exists from  a to B, the
result type is  B. At run-time, a is first evaluated. If a is not null, a is converted to
type B, and this becomes the result. Otherwise, b is evaluated and becomes the
result.
Otherwise, a and b are incompatible, and a compile-time error occurs.
ANTLR
A throw_expr ession  throws the value produced by evaluating the
null_c oalescing_expr ession . The expression shall be implicitly convertible to12.16 The throw expression operator
throw_expression
: 'throw' null_coalescing_expression
;System.Exception, and the result of evaluating the expression is converted to
System.Exception before being thrown. The behavior at runtime of the evaluation of a
throw expr ession  is the same as specified for a throw statement  (§13.10.6 ).
A throw_expr ession  has no type. A throw_expr ession  is convertible to every type by an
implicit thr ow conversion.
A throw expr ession  shall only occur in the following syntactic contexts:
As the second or third operand of a ternary conditional operator ( ?:).
As the second operand of a null coalescing operator ( ??).
As the body of an expression-bodied lambda or member.
A declaration expression declares a local variable.
ANTLR
The simple_name  _ is also considered a declaration expression if simple name lookup
did not find an associated declaration ( §12.8.4 ). When used as a declaration expression,
_ is called a simple dis card. It is semantically equivalent to var _, but is permitted in
more places.
A declaration expression shall only occur in the following syntactic contexts:
As an out argument_v alue in an argument_list .
As a simple discard _ comprising the left side of a simple assignment ( §12.21.2 ).
As a tuple_element  in one or more recursively nested tuple_expr ession s, the
outermost of which comprises the left side of a deconstructing assignment. A
deconstr uction_expr ession  gives rise to declaration expressions in this position,
even though the declaration expressions are not syntactically present.
Note: This means that a declaration expression cannot be parenthesized. end not e12.17 Declaration expressions
declaration_expression
: local_variable_type identifier
;
local_variable_type
: type
| 'var'
;It is an error for an implicitly typed variable declared with a declar ation_expr ession  to be
referenced within the argument_list  where it is declared.
It is an error for a variable declared with a declar ation_expr ession  to be referenced within
the deconstructing assignment where it occurs.
A declaration expression that is a simple discard or where the local_v ariable_type  is the
identifier var is classified as an implicitly typed  variable. The expression has no type, and
the type of the local variable is inferred based on the syntactic context as follows:
In an argument_list  the inferred type of the variable is the declared type of the
corresponding parameter.
As the left side of a simple assignment, the inferred type of the variable is the type
of the right side of the assignment.
In a tuple_expr ession  on the left side of a simple assignment, the inferred type of
the variable is the type of the corresponding tuple element on the right side (after
deconstruction) of the assignment.
Otherwise, the declaration expression is classified as an explicitly typed  variable, and the
type of the expression as well as the declared variable shall be that given by the
local_v ariable_type .
A declaration expression with the identifier _ is a discard ( §9.2.9.1 ), and does not
introduce a name for the variable. A declaration expression with an identifier other than
_ introduces that name into the nearest enclosing local variable declaration space
(§7.3).
Example :
C#
The declaration of s1 shows both explicitly and implicitly typed declaration
expressions. The inferred type of b1 is bool because that is the type of the
corresponding out parameter in M1. The subsequent WriteLine is able to access i1
and b1, which have been introduced to the enclosing scope.string M(out int i, string s, out bool b) { ... }
var s1 = M( out int i1, &quot;One&quot;, out var b1);
Console.WriteLine( $&quot;{i1}, {b1}, {s1}&quot;);
// Error: i2 referenced within declaring argument list
var s2 = M( out var i2, M(out i2, &quot;Two&quot;, out bool b2), out b2);
var s3 = M( out int _, &quot;Three&quot;, out var _);The declaration of s2 shows an attempt to use i2 in the nested call to M, which is
disallowed, because the reference occurs within the argument list where i2 was
declared. On the other hand the reference to b2 in the final argument is allowed,
because it occurs after the end of the nested argument list where b2 was declared.
The declaration of s3 shows the use of both implicitly and explicitly typed
declaration expressions that are discards. Because discards do not declare a named
variable, the multiple occurrences of the identifier _ are allowed.
C#
This example shows the use of implicitly and explicitly typed declaration expressions
for both variables and discards in a deconstructing assignment. The simple_name  _
is equivalent to var _ when no declaration of _ is found.
C#
This examples shows the use of var _ to provide an implicitly typed discard when _
is not available, because it designates a variable in the enclosing scope.
end ex ample
The ?: operator is called the conditional operator. It is at times also called the ternary
operator.
ANTLR(int i1, int _, (var i2, var _), _) = ( 1, 2, (3, 4), 5);
void M1(out int i) { ... }
void M2(string _)
{
M1(out _);      // Error: <code>_</code> is a string
M1(out var _);
}
12.18 Conditional operator
conditional_expression
: null_coalescing_expression
| null_coalescing_expression '?' expression ':' expression
| null_coalescing_expression '?' 'ref' variable_reference ':'A throw expression ( §12.16 ) is not allowed in a conditional operator if ref is present.
A conditional expression of the form b ? x : y first evaluates the condition  b. Then, if
b is true, x is evaluated and becomes the result of the operation. Otherwise, y is
evaluated and becomes the result of the operation. A conditional expression never
evaluates both x and y.
The conditional operator is right-associative, meaning that operations are grouped from
right to left.
Example : An expression of the form a ? b : c ? d : e is evaluated as
a ? b : (c ? d : e). end ex ample
The first operand of the ?: operator shall be an expression that can be implicitly
converted to bool, or an expression of a type that implements operator true. If neither
of these requirements is satisfied, a compile-time error occurs.
If ref is present:
An identity conversion shall exist between the types of the two variable_r eferences,
and type of the result can be either type. If either type is dynamic, type inference
prefers dynamic (§8.7). If either type is a tuple type ( §8.3.11 ), type inference
includes the element names when the element names in the same ordinal position
match in both tuples.
The result is a variable reference, which is writeable if both variable_r eferences are
writeable.
Note: When ref is present, the conditional_expr ession  returns a variable reference,
which can be assigned to a reference variable using the = ref operator or passed as
a reference/input/output parameter. end not e
If ref is not present, the second and third operands, x and y, of the ?: operator
control the type of the conditional expression:
If x has type  X and y has type  Y then,
If an identity conversion exists between X and Y, then the result is the best
common type of a set of expressions ( §12.6.3.15 ). If either type is dynamic, type
inference prefers dynamic (§8.7). If either type is a tuple type ( §8.3.11 ), type      'ref' variable_reference
;inference includes the element names when the element names in the same
ordinal position match in both tuples.
Otherwise, if an implicit conversion ( §10.2 ) exists from X to Y, but not from Y
to X, then Y is the type of the conditional expression.
Otherwise, if an implicit enumeration conversion ( §10.2.4 ) exists from  X to Y,
then Y is the type of the conditional expression.
Otherwise, if an implicit enumeration conversion ( §10.2.4 ) exists from  Y to X,
then X is the type of the conditional expression.
Otherwise, if an implicit conversion ( §10.2 ) exists from Y to X, but not from X
to Y, then X is the type of the conditional expression.
Otherwise, no expression type can be determined, and a compile-time error
occurs.
If only one of  x and y has a type, and both  x and y are implicitly convertible to
that type, then that is the type of the conditional expression.
Otherwise, no expression type can be determined, and a compile-time error
occurs.
The run-time processing of a ref conditional expression of the form b ? ref x : ref y
consists of the following steps:
First, b is evaluated, and the bool value of b is determined:
If an implicit conversion from the type of b to bool exists, then this implicit
conversion is performed to produce a bool value.
Otherwise, the operator true defined by the type of b is invoked to produce a
bool value.
If the bool value produced by the step above is true, then x is evaluated and the
resulting variable reference becomes the result of the conditional expression.
Otherwise, y is evaluated and the resulting variable reference becomes the result
of the conditional expression.
The run-time processing of a conditional expression of the form b ? x : y consists of
the following steps:
First, b is evaluated, and the bool value of b is determined:
If an implicit conversion from the type of b to bool exists, then this implicit
conversion is performed to produce a bool value.
Otherwise, the operator true defined by the type of b is invoked to produce a
bool value.
If the bool value produced by the step above is true, then x is evaluated and
converted to the type of the conditional expression, and this becomes the result ofthe conditional expression.
Otherwise, y is evaluated and converted to the type of the conditional expression,
and this becomes the result of the conditional expression.
An anon ymous f unction  is an expression that represents an “in-line” method definition.
An anonymous function does not have a value or type in and of itself, but is convertible
to a compatible delegate or expression-tree type. The evaluation of an anonymous-
function conversion depends on the target type of the conversion: If it is a delegate
type, the conversion evaluates to a delegate value referencing the method that the
anonymous function defines. If it is an expression-tree type, the conversion evaluates to
an expression tree that represents the structure of the method as an object structure.
Note: For historical reasons, there are two syntactic flavors of anonymous functions,
namely lambda_expr ession s and anon ymous_method_expr ession s. For almost all
purposes, lambda_expr ession s are more concise and expressive than
anon ymous_method_expr ession s, which remain in the language for backwards
compatibility. end not e
ANTLR12.19 Anonymous function expressions
12.19.1 General
lambda_expression
: 'async'? anonymous_function_signature '=&gt;' anonymous_function_body
;
anonymous_method_expression
: 'async'? 'delegate'  explicit_anonymous_function_signature? block
;
anonymous_function_signature
: explicit_anonymous_function_signature
| implicit_anonymous_function_signature
;
explicit_anonymous_function_signature
: '(' explicit_anonymous_function_parameter_list? ')'
;
explicit_anonymous_function_parameter_list
: explicit_anonymous_function_parameter
(',' explicit_anonymous_function_parameter)*
;When recognising an anon ymous_f unction_body  if both the
null_c onditional_in vocation_expr ession  and expression  alternatives are applicable then
the former shall be chosen.
Note: The overlapping of, and priority between, alternatives here is solely for
descriptive convenience; the grammar rules could be elaborated to remove the
overlap. ANTLR, and other grammar systems, adopt the same convenience and so
anon ymous_f unction_body  has the specified semantics automatically. end not e
Note: When treated as an expression , a syntactic form such as x?.M() would be an
error if the result type of M is void (§12.8.12 ). But when treated as a
null_c onditional_in vocation_expr ession , the result type is permitted to be void. end
note
Example : The result type of List<T>.Reverse is void. In the following code, the body
of the anonymous expression is a null_c onditional_in vocation_expr ession , so it is notexplicit_anonymous_function_parameter
: anonymous_function_parameter_modifier? type identifier
;
anonymous_function_parameter_modifier
: 'ref'
| 'out'
| 'in'
;
implicit_anonymous_function_signature
: '(' implicit_anonymous_function_parameter_list? ')'
| implicit_anonymous_function_parameter
;
implicit_anonymous_function_parameter_list
: implicit_anonymous_function_parameter
(',' implicit_anonymous_function_parameter)*
;
implicit_anonymous_function_parameter
: identifier
;
anonymous_function_body
: null_conditional_invocation_expression
| expression
| 'ref' variable_reference
| block
;an error.
C#
end ex ample
The =&gt; operator has the same precedence as assignment ( =) and is right-associative.
An anonymous function with the async modifier is an async function and follows the
rules described in §15.15 .
The parameters of an anonymous function in the form of a lambda_expr ession  can be
explicitly or implicitly typed. In an explicitly typed parameter list, the type of each
parameter is explicitly stated. In an implicitly typed parameter list, the types of the
parameters are inferred from the context in which the anonymous function occurs—
specifically, when the anonymous function is converted to a compatible delegate type or
expression tree type, that type provides the parameter types ( §10.7 ).
In a lambda_expr ession  with a single, implicitly typed parameter, the parentheses may be
omitted from the parameter list. In other words, an anonymous function of the form
C#
can be abbreviated to
C#
The parameter list of an anonymous function in the form of an
anon ymous_method_expr ession  is optional. If given, the parameters shall be explicitly
typed. If not, the anonymous function is convertible to a delegate with any parameter
list not containing out parameters.
A block  body of an anonymous function is always reachable ( §13.2 ).
Example : Some examples of anonymous functions follow below:
C#Action&lt;List&lt; int&gt;&gt; a = x =&gt; x?.Reverse();
( «param» ) =&gt; «expr»
«param» =&gt; «expr»end ex ample
The behavior of lambda_expr ession s and anon ymous_method_expr ession s is the same
except for the following points:
anon ymous_method_expr ession s permit the parameter list to be omitted entirely,
yielding convertibility to delegate types of any list of value parameters.
lambda_expr ession s permit parameter types to be omitted and inferred whereas
anon ymous_method_expr ession s require parameter types to be explicitly stated.
The body of a lambda_expr ession  can be an expression or a block whereas the
body of an anon ymous_method_expr ession  shall be a block.
Only lambda_expr ession s have conversions to compatible expression tree types
(§8.6).
The anon ymous_f unction_signatur e of an anonymous function defines the names and
optionally the types of the formal parameters for the anonymous function. The scope of
the parameters of the anonymous function is the anon ymous_f unction_body  (§7.7).
Together with the parameter list (if given) the anonymous-method-body constitutes a
declaration space ( §7.3). It is thus a compile-time error for the name of a parameter of
the anonymous function to match the name of a local variable, local constant or
parameter whose scope includes the anon ymous_method_expr ession  or
lambda_expr ession .
If an anonymous function has an explicit_anon ymous_f unction_signatur e, then the set of
compatible delegate types and expression tree types is restricted to those that have the
same parameter types and modifiers in the same order ( §10.7 ). In contrast to method
group conversions ( §10.8 ), contra-variance of anonymous function parameter types is
not supported. If an anonymous function does not have anx =&gt; x + 1                             // Implicitly typed, expression<br />
body
x =&gt; { return x + 1; }                 // Implicitly typed, block body
(int x) =&gt; x + 1                       // Explicitly typed, expression<br />
body
(int x) =&gt; { return x + 1; }           // Explicitly typed, block body
(x, y) =&gt; x * y                        // Multiple parameters
() =&gt; Console.WriteLine()              // No parameters
async (t1,t2) =&gt; await t1 + await t2   // Async
delegate  (int x) { return x + 1; }     // Anonymous method expression
delegate  { return 1 + 1; }             // Parameter list omitted
12.19.2 Anonymous function signaturesanon ymous_f unction_signatur e, then the set of compatible delegate types and
expression tree types is restricted to those that have no out parameters.
Note that an anon ymous_f unction_signatur e cannot include attributes or a parameter
array. Nevertheless, an anon ymous_f unction_signatur e may be compatible with a
delegate type whose parameter list contains a parameter array.
Note also that conversion to an expression tree type, even if compatible, may still fail at
compile-time ( §8.6).
The body ( expression  or block ) of an anonymous function is subject to the following
rules:
If the anonymous function includes a signature, the parameters specified in the
signature are available in the body. If the anonymous function has no signature it
can be converted to a delegate type or expression type having parameters ( §10.7 ),
but the parameters cannot be accessed in the body.
Except for in, out, or ref parameters specified in the signature (if any) of the
nearest enclosing anonymous function, it is a compile-time error for the body to
access an in, out, or ref parameter.
Except for parameters specified in the signature (if any) of the nearest enclosing
anonymous function, it is a compile-time error for the body to access a parameter
of a ref struct type.
When the type of this is a struct type, it is a compile-time error for the body to
access this. This is true whether the access is explicit (as in this.x) or implicit (as
in x where x is an instance member of the struct). This rule simply prohibits such
access and does not affect whether member lookup results in a member of the
struct.
The body has access to the outer variables ( §12.19.6 ) of the anonymous function.
Access of an outer variable will reference the instance of the variable that is active
at the time the lambda_expr ession  or anon ymous_method_expr ession  is evaluated
(§12.19.7 ).
It is a compile-time error for the body to contain a goto statement, a break
statement, or a continue statement whose target is outside the body or within the
body of a contained anonymous function.
A return statement in the body returns control from an invocation of the nearest
enclosing anonymous function, not from the enclosing function member.12.19.3 Anonymous function bodiesIt is explicitly unspecified whether there is any way to execute the block of an
anonymous function other than through evaluation and invocation of the
lambda_expr ession  or anon ymous_method_expr ession . In particular, the compiler may
choose to implement an anonymous function by synthesizing one or more named
methods or types. The names of any such synthesized elements shall be of a form
reserved for compiler use ( §6.4.3 ).
Anonymous functions in an argument list participate in type inference and overload
resolution. R efer to §12.6.3  and §12.6.4  for the exact rules.
Example : The following example illustrates the effect of anonymous functions on
overload resolution.
C#
The ItemList<T> class has two Sum methods. Each takes a selector argument,
which extracts the value to sum over from a list item. The extracted value can be
either an int or a double and the resulting sum is likewise either an int or a
double.
The Sum methods could for example be used to compute sums from a list of detail
lines in an order.12.19.4 Overload resolution
class ItemList <T> : List<T>
{
public int Sum(Func&lt;T, int&gt; selector )
{
int sum = 0;
foreach (T item in this)
{
sum += selector(item);
}
return sum;
}
public double Sum(Func&lt;T, double&gt; selector )
{
double sum = 0;
foreach (T item in this)
{
sum += selector(item);
}
return sum;
}
}C#
In the first invocation of orderDetails.Sum, both Sum methods are applicable
because the anonymous function d =&gt; d.UnitCount is compatible with both
Func&lt;Detail,int&gt; and Func&lt;Detail,double&gt;. However, overload resolution picks the
first Sum method because the conversion to Func&lt;Detail,int&gt; is better than the
conversion to Func&lt;Detail,double&gt;.
In the second invocation of orderDetails.Sum, only the second Sum method is
applicable because the anonymous function d =&gt; d.UnitPrice * d.UnitCount
produces a value of type double. Thus, overload resolution picks the second Sum
method for that invocation.
end ex ample
An anonymous function cannot be a receiver, argument, or operand of a dynamically
bound operation.class Detail
{
public int UnitCount;
public double UnitPrice;
...
}
class A
{
void ComputeSums ()
{
ItemList<Detail> orderDetails = GetOrderDetails( ... );
int totalUnits = orderDetails.Sum(d =&gt; d.UnitCount);
double orderTotal = orderDetails.Sum(d =&gt; d.UnitPrice *<br />
d.UnitCount);
...
}
ItemList<Detail> GetOrderDetails ( ... )
{
...
}
}
12.19.5 Anonymous functions and dynamic binding
12.19.6 Outer variablesAny local variable, value parameter, or parameter array whose scope includes the
lambda_expr ession  or anon ymous_method_expr ession  is called an outer variable  of the
anonymous function. In an instance function member of a class, the this value is
considered a value parameter and is an outer variable of any anonymous function
contained within the function member.
When an outer variable is referenced by an anonymous function, the outer variable is
said to have been captur ed by the anonymous function. Ordinarily, the lifetime of a local
variable is limited to execution of the block or statement with which it is associated
(§9.2.9 ). However, the lifetime of a captured outer variable is extended at least until the
delegate or expression tree created from the anonymous function becomes eligible for
garbage collection.
Example : In the example
C#
the local variable  x is captured by the anonymous function, and the lifetime of  x is
extended at least until the delegate returned from  F becomes eligible for garbage
collection. Since each invocation of the anonymous function operates on the same
instance of  x, the output of the example is:12.19.6.1 General
12.19.6.2 Captured outer variables
delegate  int D();
class Test
{
static D F()
{
int x = 0;
D result = () =&gt; ++x;
return result;
}
static void Main()
{
D d = F();
Console.WriteLine(d());
Console.WriteLine(d());
Console.WriteLine(d());
}
}Console
end ex ample
When a local variable or a value parameter is captured by an anonymous function, the
local variable or parameter is no longer considered to be a fixed variable ( §23.4 ), but is
instead considered to be a moveable variable. However, captured outer variables cannot
be used in a fixed statement ( §23.7 ), so the address of a captured outer variable cannot
be taken.
Note: Unlike an uncaptured variable, a captured local variable can be simultaneously
exposed to multiple threads of execution. end not e
A local variable is considered to be instantiat ed when execution enters the scope of the
variable.
Example : For example, when the following method is invoked, the local variable  x is
instantiated and initialized three times—once for each iteration of the loop.
C#
However, moving the declaration of  x outside the loop results in a single
instantiation of  x:
C#1
2
3
12.19.6.3 Instantiation of local variables
static void F()
{
for (int i = 0; i &lt; 3; i++)
{
int x = i * 2 + 1;
...
}
}
static void F()
{
int x;
for (int i = 0; i &lt; 3; i++)end ex ample
When not captured, there is no way to observe exactly how often a local variable is
instantiated—because the lifetimes of the instantiations are disjoint, it is possible for
each instantation to simply use the same storage location. However, when an
anonymous function captures a local variable, the effects of instantiation become
apparent.
Example : The example
C#
produces the output:
Console    {
x = i * 2 + 1;
...
}
}
delegate  void D();
class Test
{
static D[] F()
{
D[] result = new D[3];
for (int i = 0; i &lt; 3; i++)
{
int x = i * 2 + 1;
result[i] = () =&gt; Console.WriteLine(x);
}
return result;
}
static void Main()
{
foreach (D d in F())
{
d();
}
}
}
1
3
5However, when the declaration of  x is moved outside the loop:
C#
the output is:
Console
Note that the compiler is permitted (but not required) to optimize the three
instantiations into a single delegate instance ( §10.7.2 ).
end ex ample
If a for-loop declares an iteration variable, that variable itself is considered to be
declared outside of the loop.
Example : Thus, if the example is changed to capture the iteration variable itself:
C#delegate  void D();
class Test
{
static D[] F()
{
D[] result = new D[3];
int x;
for (int i = 0; i &lt; 3; i++)
{
x = i * 2 + 1;
result[i] = () =&gt; Console.WriteLine(x);
}
return result;
}
static void Main()
{
foreach (D d in F())
{
d();
}
}
}
5
5
5only one instance of the iteration variable is captured, which produces the output:
Console
end ex ample
It is possible for anonymous function delegates to share some captured variables yet
have separate instances of others.
Example : For example, if  F is changed to
C#delegate  void D();
class Test
{
static D[] F()
{
D[] result = new D[3];
for (int i = 0; i &lt; 3; i++)
{
result[i] = () =&gt; Console.WriteLine(i);
}
return result;
}
static void Main()
{
foreach (D d in F())
{
d();
}
}
}
3
3
3
static D[] F()
{
D[] result = new D[3];
int x = 0;
for (int i = 0; i &lt; 3; i++)
{
int y = 0;
result[i] = () =&gt; Console.WriteLine( $&quot;{++x} {++y}&quot;);
}the three delegates capture the same instance of  x but separate instances of  y, and
the output is:
Console
end ex ample
Separate anonymous functions can capture the same instance of an outer variable.
Example : In the example:
C#
the two anonymous functions capture the same instance of the local variable  x, and
they can thus “communicate” through that variable. The output of the example is:
Console
end ex ample    return result;
}
1 1
2 1
3 1
delegate  void Setter(int value);
delegate  int Getter();
class Test
{
static void Main()
{
int x = 0;
Setter s = ( int value) =&gt; x = value;
Getter g = () =&gt; x;
s(5);
Console.WriteLine(g());
s(10);
Console.WriteLine(g());
}
}
5
10An anonymous function  F shall always be converted to a delegate type  D or an
expression-tree type  E, either directly or through the execution of a delegate creation
expression new D(F). This conversion determines the result of the anonymous function,
as described in  §10.7 .
This subclause is informativ e.
This subclause describes a possible implementation of anonymous function conversions
in terms of other C# constructs. The implementation described here is based on the
same principles used by a commercial C# compiler, but it is by no means a mandated
implementation, nor is it the only one possible. It only briefly mentions conversions to
expression trees, as their exact semantics are outside the scope of this specification.
The remainder of this subclause gives several examples of code that contains
anonymous functions with different characteristics. For each example, a corresponding
translation to code that uses only other C# constructs is provided. In the examples, the
identifier  D is assumed by represent the following delegate type:
C#
The simplest form of an anonymous function is one that captures no outer variables:
C#
This can be translated to a delegate instantiation that references a compiler generated
static method in which the code of the anonymous function is placed:
C#12.19.7 Evaluation of anonymous function expressions
12.19.8 Implementation Example
public delegate  void D();
delegate  void D();
class Test
{
static void F()
{
D d = () =&gt; Console.WriteLine( &quot;test&quot;);
}
}In the following example, the anonymous function references instance members of
this:
C#
This can be translated to a compiler generated instance method containing the code of
the anonymous function:
C#delegate  void D();
class Test
{
static void F()
{
D d = new D(__Method1);
}
static void __Method1()
{
Console.WriteLine( &quot;test&quot;);
}
}
delegate  void D();
class Test
{
int x;
void F()
{
D d = () =&gt; Console.WriteLine(x);
}
}
delegate  void D();
class Test
{
int x;
void F()
{
D d = new D(__Method1);
}
void __Method1()
{In this example, the anonymous function captures a local variable:
C#
The lifetime of the local variable must now be extended to at least the lifetime of the
anonymous function delegate. This can be achieved by “hoisting” the local variable into
a field of a compiler-generated class. Instantiation of the local variable ( §12.19.6.3 ) then
corresponds to creating an instance of the compiler generated class, and accessing the
local variable corresponds to accessing a field in the instance of the compiler generated
class. Furthermore, the anonymous function becomes an instance method of the
compiler-generated class:
C#       Console.WriteLine(x);
}
}
delegate  void D();
class Test
{
void F()
{
int y = 123;
D d = () =&gt; Console.WriteLine(y);
}
}
delegate  void D();
class Test
{
void F()
{
__Locals1 __locals1 = new __Locals1();
__locals1.y = 123;
D d = new D(__locals1.__Method1);
}
class __Locals1
{
public int y;
public void __Method1()
{
Console.WriteLine(y);
}Finally, the following anonymous function captures this as well as two local variables
with different lifetimes:
C#
Here, a compiler-generated class is created for each block in which locals are captured
such that the locals in the different blocks can have independent lifetimes. An instance
of __Locals2, the compiler generated class for the inner block, contains the local
variable z and a field that references an instance of __Locals1. An instance of
__Locals1, the compiler generated class for the outer block, contains the local variable
y and a field that references this of the enclosing function member. With these data
structures, it is possible to reach all captured outer variables through an instance of
__Local2, and the code of the anonymous function can thus be implemented as an
instance method of that class.
C#    }
}
delegate  void D();
class Test
{
int x;
void F()
{
int y = 123;
for (int i = 0; i &lt; 10; i++)
{
int z = i * 2;
D d = () =&gt; Console.WriteLine(x + y + z);
}
}
}
delegate  void D();
class Test
{
int x;
void F()
{
__Locals1 __locals1 = new __Locals1();
__locals1.__this = this;
__locals1.y = 123;The same technique applied here to capture local variables can also be used when
converting anonymous functions to expression trees: references to the compiler-
generated objects can be stored in the expression tree, and access to the local variables
can be represented as field accesses on these objects. The advantage of this approach is
that it allows the “lifted” local variables to be shared between delegates and expression
trees.
End o f informativ e text.
Quer y expr essions  provide a language-integrated syntax for queries that is similar to
relational and hierarchical query languages such as SQL and XQuery.
ANTLR        for (int i = 0; i &lt; 10; i++)
{
__Locals2 __locals2 = new __Locals2();
__locals2.__locals1 = __locals1;
__locals2.z = i * 2;
D d = new D(__locals2.__Method1);
}
}
class __Locals1
{
public Test __this;
public int y;
}
class __Locals2
{
public __Locals1 __locals1;
public int z;
public void __Method1()
{
Console.WriteLine(__locals1.__this.x + __locals1.y + z);
}
}
}
12.20 Query expressions
12.20.1 General
query_expression
: from_clause query_body
;from_clause
: 'from' type? identifier 'in' expression
;
query_body
: query_body_clauses? select_or_group_clause query_continuation?
;
query_body_clauses
: query_body_clause
| query_body_clauses query_body_clause
;
query_body_clause
: from_clause
| let_clause
| where_clause
| join_clause
| join_into_clause
| orderby_clause
;
let_clause
: 'let' identifier '=' expression
;
where_clause
: 'where' boolean_expression
;
join_clause
: 'join' type? identifier 'in' expression 'on' expression
'equals'  expression
;
join_into_clause
: 'join' type? identifier 'in' expression 'on' expression
'equals'  expression 'into' identifier
;
orderby_clause
: 'orderby'  orderings
;
orderings
: ordering ( ',' ordering)*
;
ordering
: expression ordering_direction?
;
ordering_direction
: 'ascending'A query expression begins with a from clause and ends with either a select or group
clause. The initial from clause may be followed by zero or more from, let, where, join
or orderby clauses. Each from clause is a generator introducing a range v ariable  that
ranges over the elements of a sequenc e. Each let clause introduces a range variable
representing a value computed by means of previous range variables. Each where clause
is a filter that excludes items from the result. Each join clause compares specified keys
of the source sequence with keys of another sequence, yielding matching pairs. Each
orderby clause reorders items according to specified criteria.The final select or group
clause specifies the shape of the result in terms of the range variables. Finally, an into
clause can be used to “splice” queries by treating the results of one query as a generator
in a subsequent query.
Query expressions use a number of contextual keywords ( §6.4.4 ): ascending, by,
descending, equals, from, group, into, join, let, on, orderby, select and where.
To avoid ambiguities that could arise from the use of these identifiers both as keywords
and simple names these identifiers are considered keywords anywhere within a query
expression, unless they are prefixed with “ @” (§6.4.4 ) in which case they are considered
identifiers. For this purpose, a query expression is any expression that starts with “ from
identi fier” followed by any token except “ ;”, “=” or “,”.    | 'descending'
;
select_or_group_clause
: select_clause
| group_clause
;
select_clause
: 'select'  expression
;
group_clause
: 'group' expression 'by' expression
;
query_continuation
: 'into' identifier query_body
;
12.20.2 Ambiguities in query expressions
12.20.3 Query expression translationThe C# language does not specify the execution semantics of query expressions. Rather,
query expressions are translated into invocations of methods that adhere to the query-
expression pattern ( §12.20.4 ). Specifically, query expressions are translated into
invocations of methods named Where, Select, SelectMany, Join, GroupJoin, OrderBy,
OrderByDescending, ThenBy, ThenByDescending, GroupBy, and Cast. These methods are
expected to have particular signatures and return types, as described in §12.20.4 . These
methods may be instance methods of the object being queried or extension methods
that are external to the object. These methods implement the actual execution of the
query.
The translation from query expressions to method invocations is a syntactic mapping
that occurs before any type binding or overload resolution has been performed.
Following translation of query expressions, the resulting method invocations are
processed as regular method invocations, and this may in turn uncover compile time
errors. These error conditions include, but are not limited to, methods that do not exist,
arguments of the wrong types, and generic methods where type inference fails.
A query expression is processed by repeatedly applying the following translations until
no further reductions are possible. The translations are listed in order of application:
each section assumes that the translations in the preceding sections have been
performed exhaustively, and once exhausted, a section will not later be revisited in the
processing of the same query expression.
It is a compile time error for a query expression to include an assignment to a range
variable, or the use of a range variable as an argument for a ref or out parameter.
Certain translations inject range variables with transparent identi fiers denoted by <em>.
These are described further in §12.20.3.8 .
A query expression with a continuation following its query body
C#
is translated into
C#12.20.3.1 General
12.20.3.2 Query expressions with continuations
from «x1» in «e1» «b1» into «x2» «b2»The translations in the following sections assume that queries have no continuations.
Example : The example:
C#
is translated into:
C#
the final translation of which is:
C#
end ex ample
A from clause that explicitly specifies a range variable type
C#
is translated into
C#from «x2» in ( from «x1» in «e1» «b1» ) «b2»
from c in customers
group c by c.Country into g
select new { Country = g.Key, CustCount = g.Count() }
from g in
(from c in customers
group c by c.Country )
select new { Country = g.Key, CustCount = g.Count() }
customers.
GroupBy(c =&gt; c.Country).
Select(g =&gt; new { Country = g.Key, CustCount = g.Count() })
12.20.3.3 Explicit range variable types
from «T» «x» in «e»A join clause that explicitly specifies a range variable type
C#
is translated into
C#
The translations in the following sections assume that queries have no explicit range
variable types.
Example : The example
C#
is translated into
C#
the final translation of which is
C#
end ex amplefrom «x» in ( «e» ) . Cast &lt; «T» &gt; ( )
join «T» «x» in «e» on «k1» equals «k2»
join «x» in ( «e» ) . Cast &lt; «T» &gt; ( ) on «k1» equals «k2»
from Customer c in customers
where c.City == &quot;London&quot;
select c
from c in (customers ).Cast<Customer>( )
where c.City == &quot;London&quot;
select c
customers.
Cast<Customer>().
Where(c =&gt; c.City == &quot;London&quot; )Note: Explicit range variable types are useful for querying collections that implement
the non-generic IEnumerable interface, but not the generic IEnumerable<T>
interface. In the example above, this would be the case if customers were of type
ArrayList. end not e
A query expression of the form
C#
is translated into
C#
Example : The example
C#
is translated into
C#
end ex ample
A degenerate query expression is one that trivially selects the elements of the source.
Note: Later phases of the translation ( §12.20.3.6  and §12.20.3.7 ) remove degenerate
queries introduced by other translation steps by replacing them with their source. It
is important, however, to ensure that the result of a query expression is never the
source object itself. Otherwise, returning the result of such a query might
inadvertently expose private data (e.g., an element array) to a caller. Therefore this
step protects degenerate queries written directly in source code by explicitly calling12.20.3.4 Degenerate query expressions
from «x» in «e» select «x»
( «e» ) . Select ( «x» =&gt; «x» )
from c in customers
select c
(customers).Select(c =&gt; c)Select on the source. It is then up to the implementers of Select and other query
operators to ensure that these methods never return the source object itself. end
note
A query expression with a second from clause followed by a select clause
C#
is translated into
C#
Example : The example
C#
is translated into
C#
end ex ample
A query expression with a second from clause followed by a query body Q containing a
non-empty set of query body clauses:
C#12.20.3.5 From, let, where, join and orderby clauses
from «x1» in «e1»<br />
from «x2» in «e2»<br />
select «v»
( «e1» ) . SelectMany( «x1» =&gt; «e2» , ( «x1» , «x2» ) =&gt; «v» )
from c in customers
from o in c.Orders
select new { c.Name, o.OrderID, o.Total }
(customers).
SelectMany(c =&gt; c.Orders,
(c,o) =&gt; new { c.Name, o.OrderID, o.Total }
)is translated into
C#
Example : The example
C#
is translated into
C#
the final translation of which is
C#
where x is a compiler generated identifier that is otherwise invisible and
inaccessible.
end ex amplefrom «x1» in «e1»
from «x2» in «e2»
Q
from * in («e1») . SelectMany( «x1» =&gt; «e2» ,
( «x1» , «x2» ) =&gt; new { «x1» , «x2» } )
Q
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
from * in (customers).
SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o })
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
customers.
SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o }).
OrderByDescending(x =&gt; x.o.Total).
Select(x =&gt; new { x.c.Name, x.o.OrderID, x.o.Total })A let expression along with its preceding from clause:
C#
is translated into
C#
Example : The example
C#
is translated into
C#
the final translation of which is
C#
where x is a compiler generated identifier that is otherwise invisible and
inaccessible.from «x» in «e»<br />
let «y» = «f»<br />
...
from * in ( «e» ) . Select ( «x» =&gt; new { «x» , «y» = «f» } )<br />
...
from o in orders
let t = o.Details.Sum(d =&gt; d.UnitPrice * d.Quantity)
where t &gt;= 1000
select new { o.OrderID, Total = t }
from * in (orders).Select(
o =&gt; new { o, t = o.Details.Sum(d =&gt; d.UnitPrice * d.Quantity) })
where t &gt;= 1000
select new { o.OrderID, Total = t }
orders
.Select(o =&gt; new { o, t = o.Details.Sum(d =&gt; d.UnitPrice *<br />
d.Quantity) })
.Where(x =&gt; x.t &gt;= 1000)
.Select(x =&gt; new { x.o.OrderID, Total = x.t })end ex ample
A where expression along with its preceding from clause:
C#
is translated into
C#
A join clause immediately followed by a select clause
C#
is translated into
C#
Example : The example
C#
is translated into
C#from «x» in «e»<br />
where «f»<br />
...
from «x» in ( «e» ) . Where ( «x» =&gt; «f» )<br />
...
from «x1» in «e1»<br />
join «x2» in «e2» on «k1» equals «k2»<br />
select «v»
( «e1» ) . Join( «e2» , «x1» =&gt; «k1» , «x2» =&gt; «k2» , ( «x1» , «x2» ) =&gt; «v»<br />
)
from c in customersh
join o in orders on c.CustomerID equals o.CustomerID
select new { c.Name, o.OrderDate, o.Total }end ex ample
A join clause followed by a query body clause:
C#
is translated into
C#
A join-into clause immediately followed by a select clause
C#
is translated into
C#
A join into clause followed by a query body clause
C#(customers).Join(
orders,
c =&gt; c.CustomerID, o =&gt; o.CustomerID,
(c, o) =&gt; new { c.Name, o.OrderDate, o.Total })
from «x1» in «e1»<br />
join «x2» in «e2» on «k1» equals «k2»<br />
...
from * in ( «e1» ) . Join(<br />
«e2» , «x1» =&gt; «k1» , «x2» =&gt; «k2» ,
( «x1» , «x2» ) =&gt; new { «x1» , «x2» })<br />
...
from «x1» in «e1»<br />
join «x2» in «e2» on «k1» equals «k2» into «g»<br />
select «v»
( «e1» ) . GroupJoin( «e2» , «x1» =&gt; «k1» , «x2» =&gt; «k2» ,
( «x1» , «g» ) =&gt; «v» )
from «x1» in «e1»<br />
join «x2» in «e2» on «k1» equals «k2» into <em>g»  is translated into
C#
Example : The example
C#
is translated into
C#
the final translation of which is
C#...
from * in ( «e1» ) . GroupJoin(<br />
«e2» , «x1» =&gt; «k1» , «x2» =&gt; «k2» , ( «x1» , «g» ) =&gt; new { «x1» , «g»<br />
})
...
from c in customers
join o in orders on c.CustomerID equals o.CustomerID into co
let n = co.Count()
where n &gt;= 10
select new { c.Name, OrderCount = n }
from * in (customers).GroupJoin(
orders,
c =&gt; c.CustomerID,
o =&gt; o.CustomerID,
(c, co) =&gt; new { c, co })
let n = co.Count()
where n &gt;= 10
select new { c.Name, OrderCount = n }
customers
.GroupJoin(
orders,
c =&gt; c.CustomerID,
o =&gt; o.CustomerID,
(c, co) =&gt; new { c, co })
.Select(x =&gt; new { x, n = x.co.Count() })
.Where(y =&gt; y.n &gt;= 10)
.Select(y =&gt; new { y.x.c.Name, OrderCount = y.n })where x and y are compiler generated identifiers that are otherwise invisible and
inaccessible.
end ex ample
An orderby clause and its preceding from clause:
C#
is translated into
C#
If an ordering clause specifies a descending direction indicator, an invocation of
OrderByDescending or ThenByDescending is produced instead.
Example : The example
C#
has the final translation
C#
end ex amplefrom «x» in «e»<br />
orderby «k1» , «k2» , ... , «kn»<br />
...
from «x» in ( «e» ) .
OrderBy ( «x» =&gt; «k1» ) .
ThenBy ( «x» =&gt; «k2» ) .
... .
ThenBy ( «x» =&gt; «kn» )
...
from o in orders
orderby o.Customer.Name, o.Total descending
select o
(orders)
.OrderBy(o =&gt; o.Customer.Name)
.ThenByDescending(o =&gt; o.Total)The following translations assume that there are no let, where, join or orderby
clauses, and no more than the one initial from clause in each query expression.
A query expression of the form
C#
is translated into
C#
except when «v» is the identifier «x», the translation is simply
C#
Example : The example
C#
is simply translated into
C#
end ex ample
A group clause12.20.3.6 Select clauses
from «x» in «e» select «v»
( «e» ) . Select ( «x» =&gt; «v» )
( «e» )
from c in customers.Where(c =&gt; c.City == &quot;London&quot; )
select c
(customers).Where(c =&gt; c.City == &quot;London&quot; )
12.20.3.7 Group clausesC#
is translated into
C#
except when «v» is the identifier «x», the translation is
C#
Example : The example
C#
is translated into
C#
end ex ample
Certain translations inject range variables with transp arent identi fiers denoted by  <em>.
Transparent identifiers exist only as an intermediate step in the query-expression
translation process.
When a query translation injects a transparent identifier, further translation steps
propagate the transparent identifier into anonymous functions and anonymous object
initializers. In those contexts, transparent identifiers have the following behavior:
When a transparent identifier occurs as a parameter in an anonymous function, the
members of the associated anonymous type are automatically in scope in the bodyfrom «x» in «e» group «v» by «k»
( «e» ) . GroupBy ( «x» =&gt; «k» , «x» =&gt; «v» )
( «e» ) . GroupBy ( «x» =&gt; «k» )
from c in customers
group c.Name by c.Country
(customers).GroupBy(c =&gt; c.Country, c =&gt; c.Name)
12.20.3.8 Transparent identifiersof the anonymous function.
When a member with a transparent identifier is in scope, the members of that
member are in scope as well.
When a transparent identifier occurs as a member declarator in an anonymous
object initializer, it introduces a member with a transparent identifier.
In the translation steps described above, transparent identifiers are always introduced
together with anonymous types, with the intent of capturing multiple range variables as
members of a single object. An implementation of C# is permitted to use a different
mechanism than anonymous types to group together multiple range variables. The
following translation examples assume that anonymous types are used, and shows one
possible translation of transparent identifiers.
Example : The example
C#
is translated into
C#
which is further translated into
C#
which, when transparent identifiers are erased, is equivalent to
C#from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.Total }
from * in (customers).SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o })
orderby o.Total descending
select new { c.Name, o.Total }
customers
.SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o })
.OrderByDescending(</em> =&gt; o.Total)
.Select(* =&gt; new { c.Name, o.Total })
customers
.SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o })where x is a compiler generated identifier that is otherwise invisible and
inaccessible.
The example
C#
is translated into
C#
which is further reduced to
C#
the final translation of which is
C#    .OrderByDescending(x =&gt; x.o.Total)
.Select(x =&gt; new { x.c.Name, x.o.Total })
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
from * in (customers).Join(
orders,
c =&gt; c.CustomerID,
o =&gt; o.CustomerID,
(c, o) =&gt; new { c, o })
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
customers
.Join(orders, c =&gt; c.CustomerID,
o =&gt; o.CustomerID, (c, o) =&gt; new { c, o })
.Join(details, * =&gt; o.OrderID, d =&gt; d.OrderID, (</em>, d) =&gt; new { <em>, d 
})
.Join(products, * =&gt; d.ProductID, p =&gt; p.ProductID,
(</em>, p) =&gt; new { c.Name, o.OrderDate, p.ProductName })
customers
.Join(orders, c =&gt; c.CustomerID,
o =&gt; o.CustomerID, (c, o) =&gt; new { c, o })where x and y are compiler-generated identifiers that are otherwise invisible and
inaccessible. end ex ample
The Quer y-expr ession p attern establishes a pattern of methods that types can
implement to support query expressions.
A generic type C<T> supports the query-expression-pattern if its public member
methods and the publicly accessible extension methods could be replaced by the
following class definition. The members and accessible extenson methods is referred to
as the “shape” of a generic type C<T>. A generic type is used in order to illustrate the
proper relationships between parameter and return types, but it is possible to
implement the pattern for non-generic types as well.
C#    .Join(details, x =&gt; x.o.OrderID, d =&gt; d.OrderID, (x, d) =&gt; new { x, 
d })
.Join(products, y =&gt; y.d.ProductID, p =&gt; p.ProductID,
(y, p) =&gt; new { y.x.c.Name, y.x.o.OrderDate, p.ProductName })
12.20.4 The query-expression pattern
delegate  R Func&lt;T1,R&gt;(T1 arg1);
delegate  R Func&lt;T1,T2,R&gt;(T1 arg1, T2 arg2);
class C
{
public C<T> Cast<T>() { ... }
}
class C<T> : C
{
public C<T> Where(Func&lt;T,bool&gt; predicate ) { ... }
public C<U> Select<U>(Func&lt;T,U&gt; selector) { ... }
public C<V> SelectMany&lt;U,V&gt;(Func&lt;T,C<U>&gt; selector,
Func&lt;T,U,V&gt; resultSelector) { ... }
public C<V> Join&lt;U,K,V&gt;(C<U> inner, Func&lt;T,K&gt; outerKeySelector,
Func&lt;U,K&gt; innerKeySelector, Func&lt;T,U,V&gt; resultSelector) { ... }
public C<V> GroupJoin&lt;U,K,V&gt;(C<U> inner, Func&lt;T,K&gt; outerKeySelector,
Func&lt;U,K&gt; innerKeySelector, Func&lt;T,C<U>,V&gt; resultSelector) { ... }
public O<T> OrderBy<K>(Func&lt;T,K&gt; keySelector) { ... }
public O<T> OrderByDescending<K>(Func&lt;T,K&gt; keySelector) { ... }
public C&lt;G&lt;K,T&gt;&gt; GroupBy<K>(Func&lt;T,K&gt; keySelector) { ... }
public C&lt;G&lt;K,E&gt;&gt; GroupBy&lt;K,E&gt;(Func&lt;T,K&gt; keySelector,
Func&lt;T,E&gt; elementSelector) { ... }
}
class O<T> : C<T>
{The methods above use the generic delegate types Func&lt;T1, R&gt; and Func&lt;T1, T2, R&gt;,
but they could equally well have used other delegate or expression-tree types with the
same relationships in parameter and return types.
Note: The recommended relationship between C<T> and O<T> that ensures that the
ThenBy and ThenByDescending methods are available only on the result of an
OrderBy or OrderByDescending. end not e
Note: The recommended shape of the result of GroupBy—a sequence of sequences,
where each inner sequence has an additional Key property. end not e
Note: Because query expressions are translated to method invocations by means of
a syntactic mapping, types have considerable flexibility in how they implement any
or all of the query-expression pattern. For example, the methods of the pattern can
be implemented as instance methods or as extension methods because the two
have the same invocation syntax, and the methods can request delegates or
expression trees because anonymous functions are convertible to both. T ypes
implementing only some of the query expression pattern support only query
expression translations that map to the methods that type supports. end not e
Note: The System.Linq namespace provides an implementation of the query-
expression pattern for any type that implements the
System.Collections.Generic.IEnumerable<T> interface. end not e
All but one of the assignment operators assigns a new value to a variable, a property, an
event, or an indexer element. The exception, = ref, assigns a variable reference ( §9.5) to
a reference variable ( §9.7).    public O<T> ThenBy<K>(Func&lt;T,K&gt; keySelector) { ... }
public O<T> ThenByDescending<K>(Func&lt;T,K&gt; keySelector) { ... }
}
class G&lt;K,T&gt; : C<T>
{
public K Key { get; }
}
12.21 Assignment operators
12.21.1 GeneralANTLR
The left operand of an assignment shall be an expression classified as a variable, or,
except for = ref, a property access, an indexer access, an event access or a tuple. A
declaration expression is not directly permitted as a left operand, but may occur as a
step in the evaluation of a deconstructing assignment.
The = operator is called the simple assignment oper ator. It assigns the value or values
of the right operand to the variable, property, indexer element or tuple elements given
by the left operand. The left operand of the simple assignment operator shall not be an
event access (except as described in §15.8.2 ). The simple assignment operator is
described in §12.21.2 .
The operator = ref is called the ref assignment oper ator. It makes the right operand,
which shall be a variable_r eference (§9.5), the referent of the reference variable
designated by the left operand. The ref assignment operator is described in §12.21.3 .
The assignment operators other than the = and = ref operators are called the
compound assignment oper ators. These operators perform the indicated operation on
the two operands, and then assign the resulting value to the variable, property, or
indexer element given by the left operand. The compound assignment operators are
described in §12.21.4 .
The += and -= operators with an event access expression as the left operand are called
the event assignment oper ators. No other assignment operator is valid with an event
access as the left operand. The event assignment operators are described in §12.21.5 .
The assignment operators are right-associative, meaning that operations are grouped
from right to left.
Example : An expression of the form a = b = c is evaluated as a = (b = c). end
exampleassignment
: unary_expression assignment_operator expression
;
assignment_operator
: '=' 'ref'? | '+=' | '-=' | '</em>=' | '/=' | '%=' | '&amp;=' | '|=' | '^=' | 
'&lt;&lt;='
| right_shift_assignment
;
12.21.2 Simple assignmentThe = operator is called the simple assignment operator.
If the left operand of a simple assignment is of the form E.P or E[Ei] where E has the
compile-time type dynamic, then the assignment is dynamically bound ( §12.3.3 ). In this
case, the compile-time type of the assignment expression is dynamic, and the resolution
described below will take place at run-time based on the run-time type of  E. If the left
operand is of the form E[Ei] where at least one element of Ei has the compile-time
type dynamic, and the compile-time type of E is not an array, the resulting indexer
access is dynamically bound, but with limited compile-time checking ( §12.6.5 ).
A simple assignment where the left operand is classified as a tuple is also called a
deconstr ucting assignment . If any of the tuple elements of the left operand has an
element name, a compile-time error occurs. If any of the tuple elements of the left
operand is a declar ation_expr ession  and any other element is not a
declar ation_expr ession  or a simple discard, a compile-time error occurs.
The type of a simple assignment x = y is the type of an assignment to x of y, which is
recursively determined as follows:
If x is a tuple expression (x1, ..., xn), and y can be deconstructed to a tuple
expression (y1, ..., yn) with n elements ( §12.7 ), and each assignment to xi of
yi has the type Ti, then the assignment has the type (T1, ..., Tn).
Otherwise, if x is classified as a variable, the variable is not readonly, x has a type
T, and y has an implicit conversion to T, then the assignment has the type T.
Otherwise, if x is classified as an implicitly typed variable (i.e. an implicitly typed
declaration expression) and y has a type T, then the inferred type of the variable
is T, and the assignment has the type T.
Otherwise, if x is classified as a property or indexer access, the property or indexer
has an accessible set accessor, x has a type T, and y has an implicit conversion to
T, then the assignment has the type T.
Otherwise the assignment is not valid and a binding-time error occurs.
The run-time processing of a simple assignment of the form x = y with type T is
performed as an assignment to x of y with type T, which consists of the following
recursive steps:
x is evaluated if it wasn’t already.
If x is classified as a variable, y is evaluated and, if required, converted to T
through an implicit conversion ( §10.2 ).
If the variable given by x is an array element of a reference_type , a run-time
check is performed to ensure that the value computed for y is compatible withthe array instance of which x is an element. The check succeeds if y is null, or
if an implicit reference conversion ( §10.2.8 ) exists from the type of the instance
referenced by  y to the actual element type of the array instance containing  x.
Otherwise, a System.ArrayTypeMismatchException is thrown.
The value resulting from the evaluation and conversion of  y is stored into the
location given by the evaluation of  x, and is yielded as a result of the
assignment.
If x is classified as a property or indexer access:
y is evaluated and, if required, converted to T through an implicit conversion
(§10.2 ).
The set accessor of  x is invoked with the value resulting from the evaluation
and conversion of  y as its value argument.
The value resulting from the evaluation and conversion of  y is yielded as the
result of the assignment.
If x is classified as a tuple (x1, ..., xn) with arity n:
y is deconstructed with n elements to a tuple expression e.
a result tuple t is created by converting e to T using an implicit tuple
conversion.
for each xi in order from left to right, an assignment to xi of t.Itemi is
performed, except that the xi are not evaluated again.
t is yielded as the result of the assignment.
Note: if the compile time type of  x is dynamic and there is an implicit conversion
from the compile time type of  y to dynamic, no runtime resolution is required. end
note
Note: The array co-variance rules ( §17.6 ) permit a value of an array type A[] to be a
reference to an instance of an array type B[], provided an implicit reference
conversion exists from B to A. Because of these rules, assignment to an array
element of a reference_type  requires a run-time check to ensure that the value being
assigned is compatible with the array instance. In the example
C#
string[] sa = new string[10];
object[] oa = sa;
oa[0] = null;              // OK
oa[1] = &quot;Hello&quot;;           // OK
oa[2] = new ArrayList();   // ArrayTypeMismatchExceptionthe last assignment causes a System.ArrayTypeMismatchException to be thrown
because a reference to an ArrayList cannot be stored in an element of a string[].
end not e
When a property or indexer declared in a struct_type  is the target of an assignment, the
instance expression associated with the property or indexer access shall be classified as
a variable. If the instance expression is classified as a value, a binding-time error occurs.
Note: Because of §12.8.7 , the same rule also applies to fields. end not e
Example : Given the declarations:
C#
struct Point
{
int x, y;
public Point(int x, int y)
{
this.x = x;
this.y = y;
}
public int X
{
get { return x; }
set { x = value; }
}
public int Y {
get { return y; }
set { y = value; }
}
}
struct Rectangle
{
Point a, b;
public Rectangle (Point a, Point b )
{
this.a = a;
this.b = b;
}
public Point A
{
get { return a; }in the example
C#
the assignments to p.X, p.Y, r.A, and r.B are permitted because p and r are
variables. However, in the example
C#
the assignments are all invalid, since r.A and r.B are not variables.
end ex ample
The = ref operator is known as the ref assignment  operator.
The left operand shall be an expression that binds to a reference variable ( §9.7), a
reference parameter (other than this), an output parameter, or an input parameter. The
right operand shall be an expression that yields a variable_r eference designating a value
of the same type as the left operand.        set { a = value; }
}
public Point B
{
get { return b; }
set { b = value; }
}
}
Point p = new Point();
p.X = 100;
p.Y = 100;
Rectangle r = new Rectangle();
r.A = new Point(10, 10);
r.B = p;
Rectangle r = new Rectangle();
r.A.X = 10;
r.A.Y = 10;
r.B.X = 100;
r.B.Y = 100;
12.21.3 Ref assignmentIt is a compile time error if the ref-safe-context ( §9.7.2 ) of the left operand is wider than
the ref-safe-context of the right operand.
The right operand shall be definitely assigned at the point of the ref assignment.
When the left operand binds to an out parameter, it is an error if that out parameter
has not been definitely assigned at the beginning of the ref assignment operator.
If the left operand is a writeable ref (i.e., it designates anything other than a ref
readonly local or in parameter), then the right operand shall be a writeable
variable_r eference. If the right operand variable is writeable, the left operand may be a
writeable or read-only ref.
The operation makes the left operand an alias of the right operand variable. The alias
may be made read-only even if the right operand variable is writeable.
The ref assignment operator yields a variable_r eference of the assigned type. It is
writeable if the left operand is writeable.
The ref assignment operator shall not read the storage location referenced by the right
operand.
Example : Here are some examples of using = ref:
C#
end ex amplepublic static int M1() { ... }
public static ref int M2() { ... }
public static ref uint M2u() { ... }
public static ref readonly  int M3() { ... }
public static void Test()
{
int v = 42;
ref int r1 = ref v; // OK, r1 refers to v, which has value 42
r1 = ref M1();      // Error; M1 returns a value, not a reference
r1 = ref M2();      // OK; makes an alias
r1 = ref M2u();     // Error; lhs and rhs have different types
r1 = ref M3();    // error; M3 returns a ref readonly, which r1 cannot<br />
honor
ref readonly  int r2 = ref v; // OK; make readonly alias to ref
r2 = ref M2();      // OK; makes an alias, adding read-only protection
r2 = ref M3();      // OK; makes an alias and honors the read-only
r2 = ref (r1 = ref M2());  // OK; r1 is an alias to a writable variable,
// r2 is an alias (with read-only access) to the same<br />
variable
}Note: When reading code using an = ref operator, it can be tempting to read the
ref part as being part of the operand. This is particularly confusing when the
operand is a conditional ?: expression. For example, when reading ref int a = ref
b ? ref x : ref y; it’s important to read this as = ref being the operator, and b ?
ref x : ref y being the right operand: ref int a = ref (b ? ref x : ref y);.
Importantly, the expression ref b is not part of that statement, even though it
might appear so at first glance. end not e
If the left operand of a compound assignment is of the form E.P or E[Ei] where E has
the compile-time type dynamic, then the assignment is dynamically bound ( §12.3.3 ). In
this case, the compile-time type of the assignment expression is dynamic, and the
resolution described below will take place at run-time based on the run-time type of  E.
If the left operand is of the form E[Ei] where at least one element of Ei has the
compile-time type dynamic, and the compile-time type of E is not an array, the resulting
indexer access is dynamically bound, but with limited compile-time checking ( §12.6.5 ).
An operation of the form x «op»= y is processed by applying binary operator overload
resolution ( §12.4.5 ) as if the operation was written x «op» y. Then,
If the return type of the selected operator is implicitly convertible to the type of  x,
the operation is evaluated as x = x «op» y, except that x is evaluated only once.
Otherwise, if the selected operator is a predefined operator, if the return type of
the selected operator is explicitly convertible to the type of  x , and if y is implicitly
convertible to the type of  x  or the operator is a shift operator, then the operation
is evaluated as x = (T)(x «op» y), where T is the type of  x, except that x is
evaluated only once.
Otherwise, the compound assignment is invalid, and a binding-time error occurs.
The term “evaluated only once” means that in the evaluation of x «op» y, the results of
any constituent expressions of x are temporarily saved and then reused when
performing the assignment to  x.
Example : In the assignment A()[B()] += C(), where A is a method returning int[],
and B and C are methods returning int, the methods are invoked only once, in the
order A, B, C. end ex ample12.21.4 Compound assignmentWhen the left operand of a compound assignment is a property access or indexer
access, the property or indexer shall have both a get accessor and a set accessor. If this
is not the case, a binding-time error occurs.
The second rule above permits x «op»= y to be evaluated as x = (T)(x «op» y) in
certain contexts. The rule exists such that the predefined operators can be used as
compound operators when the left operand is of type sbyte, byte, short, ushort, or
char. Even when both arguments are of one of those types, the predefined operators
produce a result of type int, as described in §12.4.7.3 . Thus, without a cast it would not
be possible to assign the result to the left operand.
The intuitive effect of the rule for predefined operators is simply that x «op»= y is
permitted if both of x «op» y and x = y are permitted.
Example : In the following code
C#
the intuitive reason for each error is that a corresponding simple assignment would
also have been an error.
end ex ample
Note: This also means that compound assignment operations support lifted
operators. Since a compound assignment x «op»= y is evaluated as either
x = x «op» y or x = (T)(x «op» y), the rules of evaluation implicitly cover lifted
operators. end not e
If the left operand of a += or -= operator is classified as an event access, then the
expression is evaluated as follows:
The instance expression, if any, of the event access is evaluated.byte b = 0;
char ch = '\0';
int i = 0;
b += 1;           // OK
b += 1000;        // Error, b = 1000 not permitted
b += i;           // Error, b = i not permitted
b += (byte)i;     // OK
ch += 1;          // Error, ch = 1 not permitted
ch += (char)1;    // OK
12.21.5 Event assignmentThe right operand of the += or -= operator is evaluated, and, if required,
converted to the type of the left operand through an implicit conversion ( §10.2 ).
An event accessor of the event is invoked, with an argument list consisting of the
value computed in the previous step. If the operator was +=, the add accessor is
invoked; if the operator was -=, the remove accessor is invoked.
An event assignment expression does not yield a value. Thus, an event assignment
expression is valid only in the context of a statement_expr ession  (§13.7 ).
An expression  is either a non_assignment_expr ession  or an assignment .
ANTLR
A constant expression is an expression that shall be fully evaluated at compile-time.
ANTLR
A constant expression shall either have the value null or one of the following types:
sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double,
decimal, bool, string;
an enumeration type; or
a default value expression ( §12.8.20 ) for a reference type.12.22 Expression
expression
: non_assignment_expression
| assignment
;
non_assignment_expression
: declaration_expression
| conditional_expression
| lambda_expression
| query_expression
;
12.23 Constant expressions
constant_expression
: expression
;Only the following constructs are permitted in constant expressions:
Literals (including the null literal).
References to const members of class and struct types.
References to members of enumeration types.
References to local constants.
Parenthesized subexpressions, which are themselves constant expressions.
Cast expressions.
checked and unchecked expressions.
nameof expressions.
The predefined +, –, !, and ~ unary operators.
The predefined +, –, *, /, %, &lt;&lt;, &gt;&gt;, &amp;, |, ^, &amp;&amp;, ||, ==, !=, &lt;, &gt;, &lt;=, and &gt;=
binary operators.
The ?: conditional operator.
sizeof expressions, provided the unmanaged-type is one of the types specified in
§23.6.9  for which sizeof returns a constant value.
Default value expressions, provided the type is one of the types listed above.
The following conversions are permitted in constant expressions:
Identity conversions
Numeric conversions
Enumeration conversions
Constant expression conversions
Implicit and explicit reference conversions, provided the source of the conversions
is a constant expression that evaluates to the null value.
Note: Other conversions including boxing, unboxing, and implicit reference
conversions of non- null values are not permitted in constant expressions. end not e
Example : In the following code
C#
class C
{
const object i = 5;         // error: boxing conversion not<br />
permitted
const object str = &quot;hello&quot;; // error: implicit reference conversion
}the initialization of i is an error because a boxing conversion is required. The
initialization of str is an error because an implicit reference conversion from a non-
null value is required.
end ex ample
Whenever an expression fulfills the requirements listed above, the expression is
evaluated at compile-time. This is true even if the expression is a subexpression of a
larger expression that contains non-constant constructs.
The compile-time evaluation of constant expressions uses the same rules as run-time
evaluation of non-constant expressions, except that where run-time evaluation would
have thrown an exception, compile-time evaluation causes a compile-time error to
occur.
Unless a constant expression is explicitly placed in an unchecked context, overflows that
occur in integral-type arithmetic operations and conversions during the compile-time
evaluation of the expression always cause compile-time errors ( §12.8.19 ).
Constant expressions are required in the contexts listed below and this is indicated in
the grammar by using constant_expr ession . In these contexts, a compile-time error
occurs if an expression cannot be fully evaluated at compile-time.
Constant declarations ( §15.4 )
Enumeration member declarations ( §19.4 )
Default arguments of formal parameter lists ( §15.6.2 )
case labels of a switch statement ( §13.8.3 ).
goto case statements ( §13.10.4 )
Dimension lengths in an array creation expression ( §12.8.16.5 ) that includes an
initializer.
Attributes ( §22)
In a constant_p attern (§11.2.3 )
An implicit constant expression conversion ( §10.2.11 ) permits a constant expression of
type int to be converted to sbyte, byte, short, ushort, uint, or ulong, provided the
value of the constant expression is within the range of the destination type.
A boolean_expr ession  is an expression that yields a result of type bool; either directly or
through application of operator true in certain contexts as specified in the following:12.24 Boolean expressionsANTLR
The controlling conditional expression of an if_statement  (§13.8.2 ), while_st atement
(§13.9.2 ), do_st atement  (§13.9.3 ), or for_st atement  (§13.9.4 ) is a boolean_expr ession . The
controlling conditional expression of the ?: operator ( §12.18 ) follows the same rules as
a boolean_expr ession , but for reasons of operator precedence is classified as a
null_c oalescing_expr ession .
A boolean_expr ession  E is required to be able to produce a value of type bool, as
follows:
If E is implicitly convertible to bool then at run-time that implicit conversion is
applied.
Otherwise, unary operator overload resolution ( §12.4.4 ) is used to find a unique
best implementation of operator true on E, and that implementation is applied at
run-time.
If no such operator is found, a binding-time error occurs.boolean_expression
: expression
;
６ Collaborat e with us on
GitHub
The source for this content can
be found on GitHub, where you
can also create and review
issues and pull requests. For
more information, see our
contributor guide .C# Standar d documentation
feedb ack
C# Standard documentation is an
open source project. Select a link to
provide feedback:
 Open a documentation issue
 Provide product feedback13 Statemen ts
Article •06/08/2023
C# provides a variety of statements.
Note: Most of these statements will be familiar to developers who have
programmed in C and C++. end not e
ANTLR
unsafe_st atement  (§23.2 ) and fixed_st atement  (§23.7 ) are only available in unsafe code
(§23).
The embedded_st atement  nonterminal is used for statements that appear within other
statements. The use of embedded_st atement  rather than statement  excludes the use of
declaration statements and labeled statements in these contexts.
Example : The code
C#13.1 General
statement
: labeled_statement
| declaration_statement
| embedded_statement
;
embedded_statement
: block
| empty_statement
| expression_statement
| selection_statement
| iteration_statement
| jump_statement
| try_statement
| checked_statement
| unchecked_statement
| lock_statement
| using_statement
| yield_statement
| unsafe_statement   // unsafe code support
| fixed_statement    // unsafe code support
;results in a compile-time error because an if statement requires an
embedded_st atement  rather than a statement  for its if branch. If this code were
permitted, then the variable  i would be declared, but it could never be used. Note,
however, that by placing i’s declaration in a block, the example is valid.
end ex ample
Every statement has an end point . In intuitive terms, the end point of a statement is the
location that immediately follows the statement. The execution rules for composite
statements (statements that contain embedded statements) specify the action that is
taken when control reaches the end point of an embedded statement.
Example : When control reaches the end point of a statement in a block, control is
transferred to the next statement in the block. end ex ample
If a statement can possibly be reached by execution, the statement is said to be
reachable . Conversely, if there is no possibility that a statement will be executed, the
statement is said to be unreachable .
Example : In the following code
C#
the second invocation of Console.WriteLine is unreachable because there is no
possibility that the statement will be executed.void F(bool b)
{
if (b)
int i = 44;
}
13.2 End points and reachability
void F()
{
Console.WriteLine( &quot;reachable&quot; );
goto Label;
Console.WriteLine( &quot;unreachable&quot; );
Label:
Console.WriteLine( &quot;reachable&quot; );
}end ex ample
A warning is reported if a statement other than throw_statement , block , or
empty_st atement  is unreachable. It is specifically not an error for a statement to be
unreachable.
Note: To determine whether a particular statement or end point is reachable, the
compiler performs flow analysis according to the reachability rules defined for each
statement. The flow analysis takes into account the values of constant expressions
(§12.23 ) that control the behavior of statements, but the possible values of non-
constant expressions are not considered. In other words, for purposes of control
flow analysis, a non-constant expression of a given type is considered to have any
possible value of that type.
In the example
C#
the Boolean expression of the if statement is a constant expression because both
operands of the == operator are constants. As the constant expression is evaluated
at compile-time, producing the value false, the Console.WriteLine invocation is
considered unreachable. However, if i is changed to be a local variable
C#
the Console.WriteLine invocation is considered reachable, even though, in reality, it
will never be executed.
end not evoid F()
{
const int i = 1;
if (i == 2)
Console.WriteLine( &quot;unreachable&quot; );
}
void F()
{
int i = 1;
if (i == 2)
Console.WriteLine( &quot;reachable&quot; );
}The block  of a function member or an anonymous function is always considered
reachable. By successively evaluating the reachability rules of each statement in a block,
the reachability of any given statement can be determined.
Example : In the following code
C#
the reachability of the second Console.WriteLine is determined as follows:
The first Console.WriteLine expression statement is reachable because the
block of the F method is reachable ( §13.3 ).
The end point of the first Console.WriteLine expression statement is reachable
because that statement is reachable ( §13.7  and §13.3 ).
The if statement is reachable because the end point of the first
Console.WriteLine expression statement is reachable ( §13.7  and §13.3 ).
The second Console.WriteLine expression statement is reachable because the
Boolean expression of the if statement does not have the constant value
false.
end ex ample
There are two situations in which it is a compile-time error for the end point of a
statement to be reachable:
Because the switch statement does not permit a switch section to “fall through” to
the next switch section, it is a compile-time error for the end point of the
statement list of a switch section to be reachable. If this error occurs, it is typically
an indication that a break statement is missing.
It is a compile-time error for the end point of the block of a function member or an
anonymous function that computes a value to be reachable. If this error occurs, it
typically is an indication that a return statement is missing ( §13.10.5 ).void F(int x)
{
Console.WriteLine( &quot;start&quot;);
if (x &lt; 0)
Console.WriteLine( &quot;negative&quot; );
}
13.3 BlocksA block  permits multiple statements to be written in contexts where a single statement
is allowed.
ANTLR
A block  consists of an optional statement_list  (§13.3.2 ), enclosed in braces. If the
statement list is omitted, the block is said to be empty.
A block may contain declaration statements ( §13.6 ). The scope of a local variable or
constant declared in a block is the block.
A block is executed as follows:
If the block is empty, control is transferred to the end point of the block.
If the block is not empty, control is transferred to the statement list. When and if
control reaches the end point of the statement list, control is transferred to the end
point of the block.
The statement list of a block is reachable if the block itself is reachable.
The end point of a block is reachable if the block is empty or if the end point of the
statement list is reachable.
A block  that contains one or more yield statements ( §13.15 ) is called an iterator block.
Iterator blocks are used to implement function members as iterators ( §15.14 ). Some
additional restrictions apply to iterator blocks:
It is a compile-time error for a return statement to appear in an iterator block (but
yield return statements are permitted).
It is a compile-time error for an iterator block to contain an unsafe context ( §23.2 ).
An iterator block always defines a safe context, even when its declaration is nested
in an unsafe context.
A statement list  consists of one or more statements written in sequence. S tatement lists
occur in block s (§13.3 ) and in switch_block s (§13.8.3 ).13.3.1 General
block
: '{' statement_list? '}'
;
13.3.2 Statement listsANTLR
A statement list is executed by transferring control to the first statement. When and if
control reaches the end point of a statement, control is transferred to the next
statement. When and if control reaches the end point of the last statement, control is
transferred to the end point of the statement list.
A statement in a statement list is reachable if at least one of the following is true:</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../C-sharp-docs/part6.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../C-sharp-docs/part8.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../C-sharp-docs/part6.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../C-sharp-docs/part8.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
