st is
four:
<a id="hevea_default737"></a>
<a id="hevea_default738"></a></p><pre class="verbatim">['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
</pre>
<h2 class="section" id="sec117">10.4&#XA0;&#XA0;List operations</h2>
<p>
<a id="hevea_default739"></a></p><p>The <span class="c004">+</span> operator concatenates lists:
<a id="hevea_default740"></a>
<a id="hevea_default741"></a></p><pre class="verbatim">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; c
[1, 2, 3, 4, 5, 6]
</pre><p>
The <span class="c004">*</span> operator repeats a list a given number of times:
<a id="hevea_default742"></a>
<a id="hevea_default743"></a></p><pre class="verbatim">&gt;&gt;&gt; [0] * 4
[0, 0, 0, 0]
&gt;&gt;&gt; [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
</pre><p>
The first example repeats <span class="c004">[0]</span> four times. The second example
repeats the list <span class="c004">[1, 2, 3]</span> three times.</p>
<h2 class="section" id="sec118">10.5&#XA0;&#XA0;List slices</h2>
<p>
<a id="hevea_default744"></a>
<a id="hevea_default745"></a>
<a id="hevea_default746"></a>
<a id="hevea_default747"></a>
<a id="hevea_default748"></a></p><p>The slice operator also works on lists:</p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3]
['b', 'c']
&gt;&gt;&gt; t[:4]
['a', 'b', 'c', 'd']
&gt;&gt;&gt; t[3:]
['d', 'e', 'f']
</pre><p>
If you omit the first index, the slice starts at the beginning.
If you omit the second, the slice goes to the end. So if you
omit both, the slice is a copy of the whole list.
<a id="hevea_default749"></a>
<a id="hevea_default750"></a>
<a id="hevea_default751"></a></p><pre class="verbatim">&gt;&gt;&gt; t[:]
['a', 'b', 'c', 'd', 'e', 'f']
</pre><p>
Since lists are mutable, it is often useful to make a copy
before performing operations that modify lists.
<a id="hevea_default752"></a></p><p>A slice operator on the left side of an assignment
can update multiple elements:
<a id="hevea_default753"></a>
<a id="hevea_default754"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; t[1:3] = ['x', 'y']
&gt;&gt;&gt; t
['a', 'x', 'y', 'd', 'e', 'f']
</pre>
<h2 class="section" id="sec119">10.6&#XA0;&#XA0;List methods</h2>
<p>
<a id="hevea_default755"></a>
<a id="hevea_default756"></a></p><p>Python provides methods that operate on lists. For example,
<span class="c004">append</span> adds a new element to the end of a list:
<a id="hevea_default757"></a>
<a id="hevea_default758"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.append('d')
&gt;&gt;&gt; t
['a', 'b', 'c', 'd']
</pre><p>
<span class="c004">extend</span> takes a list as an argument and appends all of
the elements:
<a id="hevea_default759"></a>
<a id="hevea_default760"></a></p><pre class="verbatim">&gt;&gt;&gt; t1 = ['a', 'b', 'c']
&gt;&gt;&gt; t2 = ['d', 'e']
&gt;&gt;&gt; t1.extend(t2)
&gt;&gt;&gt; t1
['a', 'b', 'c', 'd', 'e']
</pre><p>
This example leaves <span class="c004">t2</span> unmodified.</p><p><span class="c004">sort</span> arranges the elements of the list from low to high:
<a id="hevea_default761"></a>
<a id="hevea_default762"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['d', 'c', 'e', 'b', 'a']
&gt;&gt;&gt; t.sort()
&gt;&gt;&gt; t
['a', 'b', 'c', 'd', 'e']
</pre><p>
Most list methods are void; they modify the list and return <span class="c004">None</span>.
If you accidentally write <span class="c004">t = t.sort()</span>, you will be disappointed
with the result.
<a id="hevea_default763"></a>
<a id="hevea_default764"></a>
<a id="hevea_default765"></a>
<a id="hevea_default766"></a></p>
<h2 class="section" id="sec120">10.7&#XA0;&#XA0;Map, filter and reduce</h2>
<p>
<a id="filter"></a></p><p>To add up all the numbers in a list, you can use a loop like this:</p><pre class="verbatim">def add_all(t):
    total = 0
    for x in t:
        total += x
    return total
</pre><p>
<span class="c004">total</span> is initialized to 0. Each time through the loop,
<span class="c004">x</span> gets one element from the list. The <span class="c004">+=</span> operator
provides a short way to update a variable. This 
<span class="c010">augmented assignment statement</span>,
<a id="hevea_default767"></a>
<a id="hevea_default768"></a>
<a id="hevea_default769"></a>
<a id="hevea_default770"></a></p><pre class="verbatim">    total += x
</pre><p>
is equivalent to</p><pre class="verbatim">    total = total + x
</pre><p>
As the loop runs, <span class="c004">total</span> accumulates the sum of the
elements; a variable used this way is sometimes called an
<span class="c010">accumulator</span>.
<a id="hevea_default771"></a></p><p>Adding up the elements of a list is such a common operation
that Python provides it as a built-in function, <span class="c004">sum</span>:</p><pre class="verbatim">&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; sum(t)
6
</pre><p>
An operation like this that combines a sequence of elements into
a single value is sometimes called <span class="c010">reduce</span>.
<a id="hevea_default772"></a>
<a id="hevea_default773"></a>
<a id="hevea_default774"></a></p><p>Sometimes you want to traverse one list while building
another. For example, the following function takes a list of strings
and returns a new list that contains capitalized strings:</p><pre class="verbatim">def capitalize_all(t):
    res = []
    for s in t:
        res.append(s.capitalize())
    return res
</pre><p>
<span class="c004">res</span> is initialized with an empty list; each time through
the loop, we append the next element. So <span class="c004">res</span> is another
kind of accumulator.
<a id="hevea_default775"></a></p><p>An operation like <code>capitalize_all</code> is sometimes called a <span class="c010">map</span> because it &#X201C;maps&#X201D; a function (in this case the method <span class="c004">capitalize</span>) onto each of the elements in a sequence.
<a id="hevea_default776"></a>
<a id="hevea_default777"></a>
<a id="hevea_default778"></a>
<a id="hevea_default779"></a></p><p>Another common operation is to select some of the elements from
a list and return a sublist. For example, the following
function takes a list of strings and returns a list that contains
only the uppercase strings:</p><pre class="verbatim">def only_upper(t):
    res = []
    for s in t:
        if s.isupper():
            res.append(s)
    return res
</pre><p>
<span class="c004">isupper</span> is a string method that returns <span class="c004">True</span> if
the string contains only upper case letters.</p><p>An operation like <code>only_upper</code> is called a <span class="c010">filter</span> because
it selects some of the elements and filters out the others.</p><p>Most common list operations can be expressed as a combination
of map, filter and reduce.</p>
<h2 class="section" id="sec121">10.8&#XA0;&#XA0;Deleting elements</h2>
<p>
<a id="hevea_default780"></a>
<a id="hevea_default781"></a></p><p>There are several ways to delete elements from a list. If you
know the index of the element you want, you can use
<span class="c004">pop</span>:
<a id="hevea_default782"></a>
<a id="hevea_default783"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; x = t.pop(1)
&gt;&gt;&gt; t
['a', 'c']
&gt;&gt;&gt; x
'b'
</pre><p>
<span class="c004">pop</span> modifies the list and returns the element that was removed.
If you don&#X2019;t provide an index, it deletes and returns the
last element.</p><p>If you don&#X2019;t need the removed value, you can use the <span class="c004">del</span>
operator:
<a id="hevea_default784"></a>
<a id="hevea_default785"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; del t[1]
&gt;&gt;&gt; t
['a', 'c']
</pre><p>
If you know the element you want to remove (but not the index), you
can use <span class="c004">remove</span>:
<a id="hevea_default786"></a>
<a id="hevea_default787"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c']
&gt;&gt;&gt; t.remove('b')
&gt;&gt;&gt; t
['a', 'c']
</pre><p>
The return value from <span class="c004">remove</span> is <span class="c004">None</span>.
<a id="hevea_default788"></a>
<a id="hevea_default789"></a></p><p>To remove more than one element, you can use <span class="c004">del</span> with
a slice index:</p><pre class="verbatim">&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; del t[1:5]
&gt;&gt;&gt; t
['a', 'f']
</pre><p>
As usual, the slice selects all the elements up to but not
including the second index.</p>
<h2 class="section" id="sec122">10.9&#XA0;&#XA0;Lists and strings</h2>
<p>
<a id="hevea_default790"></a>
<a id="hevea_default791"></a>
<a id="hevea_default792"></a></p><p>A string is a sequence of characters and a list is a sequence
of values, but a list of characters is not the same as a
string. To convert from a string to a list of characters,
you can use <span class="c004">list</span>:
<a id="hevea_default793"></a>
<a id="hevea_default794"></a></p><pre class="verbatim">&gt;&gt;&gt; s = 'spam'
&gt;&gt;&gt; t = list(s)
&gt;&gt;&gt; t
['s', 'p', 'a', 'm']
</pre><p>
Because <span class="c004">list</span> is the name of a built-in function, you should
avoid using it as a variable name. I also avoid <span class="c004">l</span> because
it looks too much like <span class="c004">1</span>. So that&#X2019;s why I use <span class="c004">t</span>.</p><p>The <span class="c004">list</span> function breaks a string into individual letters. If
you want to break a string into words, you can use the <span class="c004">split</span>
method:
<a id="hevea_default795"></a>
<a id="hevea_default796"></a></p><pre class="verbatim">&gt;&gt;&gt; s = 'pining for the fjords'
&gt;&gt;&gt; t = s.split()
&gt;&gt;&gt; t
['pining', 'for', 'the', 'fjords']
</pre><p>
An optional argument called a <span class="c010">delimiter</span> specifies which
characters to use as word boundaries.
The following example
uses a hyphen as a delimiter:
<a id="hevea_default797"></a>
<a id="hevea_default798"></a>
<a id="hevea_default799"></a></p><pre class="verbatim">&gt;&gt;&gt; s = 'spam-spam-spam'
&gt;&gt;&gt; delimiter = '-'
&gt;&gt;&gt; t = s.split(delimiter)
&gt;&gt;&gt; t
['spam', 'spam', 'spam']
</pre><p>
<span class="c004">join</span> is the inverse of <span class="c004">split</span>. It
takes a list of strings and
concatenates the elements. <span class="c004">join</span> is a string method,
so you have to invoke it on the delimiter and pass the
list as a parameter:
<a id="hevea_default800"></a>
<a id="hevea_default801"></a>
<a id="hevea_default802"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ['pining', 'for', 'the', 'fjords']
&gt;&gt;&gt; delimiter = ' '
&gt;&gt;&gt; s = delimiter.join(t)
&gt;&gt;&gt; s
'pining for the fjords'
</pre><p>
In this case the delimiter is a space character, so
<span class="c004">join</span> puts a space between words. To concatenate
strings without spaces, you can use the empty string,
<code>''</code>, as a delimiter. 
<a id="hevea_default803"></a>
<a id="hevea_default804"></a></p>
<h2 class="section" id="sec123">10.10&#XA0;&#XA0;Objects and values</h2>
<p>
<a id="equivalence"></a>
<a id="hevea_default805"></a>
<a id="hevea_default806"></a></p><p>If we run these assignment statements:</p><pre class="verbatim">a = 'banana'
b = 'banana'
</pre><p>
We know that <span class="c004">a</span> and <span class="c004">b</span> both refer to a
string, but we don&#X2019;t
know whether they refer to the <em>same</em> string.
There are two possible states, shown in Figure&#XA0;<a href="#fig.list1">10.2</a>.
<a id="hevea_default807"></a></p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython2012.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 10.2: State diagram.</td></tr>
</table></div>
<a id="fig.list1"></a>
<div class="center"><hr class="c019"></div></blockquote><p>In one case, <span class="c004">a</span> and <span class="c004">b</span> refer to two different objects that
have the same value. In the second case, they refer to the same
object.
<a id="hevea_default808"></a>
<a id="hevea_default809"></a></p><p>To check whether two variables refer to the same object, you can
use the <span class="c004">is</span> operator.</p><pre class="verbatim">&gt;&gt;&gt; a = 'banana'
&gt;&gt;&gt; b = 'banana'
&gt;&gt;&gt; a is b
True
</pre><p>
In this example, Python only created one string object, and both <span class="c004">a</span> and <span class="c004">b</span> refer to it. But when you create two lists, you get
two objects:</p><pre class="verbatim">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [1, 2, 3]
&gt;&gt;&gt; a is b
False
</pre><p>
So the state diagram looks like Figure&#XA0;<a href="#fig.list2">10.3</a>.
<a id="hevea_default810"></a>
<a id="hevea_default811"></a></p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython2013.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 10.3: State diagram.</td></tr>
</table></div>
<a id="fig.list2"></a>
<div class="center"><hr class="c019"></div></blockquote><p>In this case we would say that the two lists are <span class="c010">equivalent</span>,
because they have the same elements, but not <span class="c010">identical</span>, because
they are not the same object. If two objects are identical, they are
also equivalent, but if they are equivalent, they are not necessarily
identical.
<a id="hevea_default812"></a>
<a id="hevea_default813"></a></p><p>Until now, we have been using &#X201C;object&#X201D; and &#X201C;value&#X201D;
interchangeably, but it is more precise to say that an object has a
value. If you evaluate <span class="c004">[1, 2, 3]</span>, you get a list
object whose value is a sequence of integers. If another
list has the same elements, we say it has the same value, but
it is not the same object.
<a id="hevea_default814"></a>
<a id="hevea_default815"></a></p>
<h2 class="section" id="sec124">10.11&#XA0;&#XA0;Aliasing</h2>
<p>
<a id="hevea_default816"></a>
<a id="hevea_default817"></a></p><p>If <span class="c004">a</span> refers to an object and you assign <span class="c004">b = a</span>,
then both variables refer to the same object:</p><pre class="verbatim">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b is a
True
</pre><p>
The state diagram looks like Figure&#XA0;<a href="#fig.list3">10.4</a>.
<a id="hevea_default818"></a>
<a id="hevea_default819"></a></p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython2014.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 10.4: State diagram.</td></tr>
</table></div>
<a id="fig.list3"></a>
<div class="center"><hr class="c019"></div></blockquote><p>The association of a variable with an object is called a <span class="c010">reference</span>. In this example, there are two references to the same
object.
<a id="hevea_default820"></a></p><p>An object with more than one reference has more
than one name, so we say that the object is <span class="c010">aliased</span>.
<a id="hevea_default821"></a></p><p>If the aliased object is mutable, changes made with one alias affect
the other:</p><pre class="verbatim">&gt;&gt;&gt; b[0] = 42
&gt;&gt;&gt; a
[42, 2, 3]
</pre><p>
Although this behavior can be useful, it is error-prone. In general,
it is safer to avoid aliasing when you are working with mutable
objects.
<a id="hevea_default822"></a></p><p>For immutable objects like strings, aliasing is not as much of a
problem. In this example:</p><pre class="verbatim">a = 'banana'
b = 'banana'
</pre><p>
It almost never makes a difference whether <span class="c004">a</span> and <span class="c004">b</span> refer
to the same string or not.</p>
<h2 class="section" id="sec125">10.12&#XA0;&#XA0;List arguments</h2>
<p>
<a id="list.arguments"></a>
<a id="hevea_default823"></a>
<a id="hevea_default824"></a>
<a id="hevea_default825"></a>
<a id="hevea_default826"></a>
<a id="hevea_default827"></a></p><p>When you pass a list to a function, the function gets a reference to
the list. If the function modifies the list, the caller sees
the change. For example, <code>delete_head</code> removes the first element
from a list:</p><pre class="verbatim">def delete_head(t):
    del t[0]
</pre><p>
Here&#X2019;s how it is used:</p><pre class="verbatim">&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; delete_head(letters)
&gt;&gt;&gt; letters
['b', 'c']
</pre><p>
The parameter <span class="c004">t</span> and the variable <span class="c004">letters</span> are
aliases for the same object. The stack diagram looks like
Figure&#XA0;<a href="#fig.stack5">10.5</a>.
<a id="hevea_default828"></a>
<a id="hevea_default829"></a></p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython2015.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 10.5: Stack diagram.</td></tr>
</table></div>
<a id="fig.stack5"></a>
<div class="center"><hr class="c019"></div></blockquote><p>Since the list is shared by two frames, I drew
it between them.</p><p>It is important to distinguish between operations that
modify lists and operations that create new lists. For
example, the <span class="c004">append</span> method modifies a list, but the
<span class="c004">+</span> operator creates a new list.
<a id="hevea_default830"></a>
<a id="hevea_default831"></a>
<a id="hevea_default832"></a>
<a id="hevea_default833"></a></p><p>Here&#X2019;s an example using <span class="c004">append</span>:
</p><pre class="verbatim">&gt;&gt;&gt; t1 = [1, 2]
&gt;&gt;&gt; t2 = t1.append(3)
&gt;&gt;&gt; t1
[1, 2, 3]
&gt;&gt;&gt; t2
None
</pre><p>
The return value from <span class="c004">append</span> is <span class="c004">None</span>.</p><p>Here&#X2019;s an example using the <span class="c004">+</span> operator:
</p><pre class="verbatim">&gt;&gt;&gt; t3 = t1 + [4]
&gt;&gt;&gt; t1
[1, 2, 3]
&gt;&gt;&gt; t3
[1, 2, 3, 4]
</pre><p>
The result of the operator is a new list, and the original list is
unchanged.</p><p>This difference is important when you write functions that
are supposed to modify lists. For example, this function
<em>does not</em> delete the head of a list:
</p><pre class="verbatim">def bad_delete_head(t):
    t = t[1:]              # WRONG!
</pre><p>
The slice operator creates a new list and the assignment
makes <span class="c004">t</span> refer to it, but that doesn&#X2019;t affect the caller.
<a id="hevea_default834"></a>
<a id="hevea_default835"></a>
</p><pre class="verbatim">&gt;&gt;&gt; t4 = [1, 2, 3]
&gt;&gt;&gt; bad_delete_head(t4)
&gt;&gt;&gt; t4
[1, 2, 3]
</pre><p>
At the beginning of <code>bad_delete_head</code>, <span class="c004">t</span> and <span class="c004">t4</span>
refer to the same list. At the end, <span class="c004">t</span> refers to a new list,
but <span class="c004">t4</span> still refers to the original, unmodified list.</p><p>An alternative is to write a function that creates and
returns a new list. For
example, <span class="c004">tail</span> returns all but the first
element of a list:</p><pre class="verbatim">def tail(t):
    return t[1:]
</pre><p>
This function leaves the original list unmodified.
Here&#X2019;s how it is used:</p><pre class="verbatim">&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; rest = tail(letters)
&gt;&gt;&gt; rest
['b', 'c']
</pre>
<h2 class="section" id="sec126">10.13&#XA0;&#XA0;Debugging</h2>
<p>
<a id="hevea_default836"></a></p><p>Careless use of lists (and other mutable objects)
can lead to long hours of debugging. Here are some common
pitfalls and ways to avoid them:</p><ol class="enumerate" type=1><li class="li-enumerate">Most list methods modify the argument and
return <span class="c004">None</span>. This is the opposite of the string methods,
which return a new string and leave the original alone.<p>If you are used to writing string code like this:</p><pre class="verbatim">word = word.strip()
</pre><p>It is tempting to write list code like this:</p><pre class="verbatim">t = t.sort()           # WRONG!
</pre><p>
<a id="hevea_default837"></a>
<a id="hevea_default838"></a></p><p>Because <span class="c004">sort</span> returns <span class="c004">None</span>, the
next operation you perform with <span class="c004">t</span> is likely to fail.</p><p>Before using list methods and operators, you should read the
documentation carefully and then test them in interactive mode.</p></li><li class="li-enumerate">Pick an idiom and stick with it.<p>Part of the problem with lists is that there are too many
ways to do things. For example, to remove an element from
a list, you can use <span class="c004">pop</span>, <span class="c004">remove</span>, <span class="c004">del</span>,
or even a slice assignment.</p><p>To add an element, you can use the <span class="c004">append</span> method or
the <span class="c004">+</span> operator. Assuming that <span class="c004">t</span> is a list and
<span class="c004">x</span> is a list element, these are correct: </p><pre class="verbatim">t.append(x)
t = t + [x]
t += [x]
</pre><p>And these are wrong:</p><pre class="verbatim">t.append([x])          # WRONG!
t = t.append(x)        # WRONG!
t + [x]                # WRONG!
t = t + x              # WRONG!
</pre><p>Try out each of these examples in interactive mode to make sure
you understand what they do. Notice that only the last
one causes a runtime error; the other three are legal, but they
do the wrong thing.</p></li><li class="li-enumerate">Make copies to avoid aliasing.
<a id="hevea_default839"></a>
<a id="hevea_default840"></a><p>If you want to use a method like <span class="c004">sort</span> that modifies
the argument, but you need to keep the original list as
well, you can make a copy.</p><pre class="verbatim">&gt;&gt;&gt; t = [3, 1, 2]
&gt;&gt;&gt; t2 = t[:]
&gt;&gt;&gt; t2.sort()
&gt;&gt;&gt; t
[3, 1, 2]
&gt;&gt;&gt; t2
[1, 2, 3]
</pre><p>In this example you could also use the built-in function <span class="c004">sorted</span>,
which returns a new, sorted list and leaves the original alone.
<a id="hevea_default841"></a>
<a id="hevea_default842"></a></p><pre class="verbatim">&gt;&gt;&gt; t2 = sorted(t)
&gt;&gt;&gt; t
[3, 1, 2]
&gt;&gt;&gt; t2
[1, 2, 3]
</pre></li></ol>
<h2 class="section" id="sec127">10.14&#XA0;&#XA0;Glossary</h2>
<dl class="description"><dt class="dt-description"><span class="c010">list:</span></dt><dd class="dd-description"> A sequence of values.
<a id="hevea_default843"></a></dd><dt class="dt-description"><span class="c010">element:</span></dt><dd class="dd-description"> One of the values in a list (or other sequence),
also called items.
<a id="hevea_default844"></a></dd><dt class="dt-description"><span class="c010">nested list:</span></dt><dd class="dd-description"> A list that is an element of another list.
<a id="hevea_default845"></a></dd><dt class="dt-description"><span class="c010">accumulator:</span></dt><dd class="dd-description"> A variable used in a loop to add up or
accumulate a result.
<a id="hevea_default846"></a></dd><dt class="dt-description"><span class="c010">augmented assignment:</span></dt><dd class="dd-description"> A statement that updates the value
of a variable using an operator like <code>+=</code>.
<a id="hevea_default847"></a>
<a id="hevea_default848"></a>
<a id="hevea_default849"></a></dd><dt class="dt-description"><span class="c010">reduce:</span></dt><dd class="dd-description"> A processing pattern that traverses a sequence 
and accumulates the elements into a single result.
<a id="hevea_default850"></a>
<a id="hevea_default851"></a></dd><dt class="dt-description"><span class="c010">map:</span></dt><dd class="dd-description"> A processing pattern that traverses a sequence and
performs an operation on each element.
<a id="hevea_default852"></a>
<a id="hevea_default853"></a></dd><dt class="dt-description"><span class="c010">filter:</span></dt><dd class="dd-description"> A processing pattern that traverses a list and
selects the elements that satisfy some criterion.
<a id="hevea_default854"></a>
<a id="hevea_default855"></a></dd><dt class="dt-description"><span class="c010">object:</span></dt><dd class="dd-description"> Something a variable can refer to. An object
has a type and a value.
<a id="hevea_default856"></a></dd><dt class="dt-description"><span class="c010">equivalent:</span></dt><dd class="dd-description"> Having the same value.
<a id="hevea_default857"></a></dd><dt class="dt-description"><span class="c010">identical:</span></dt><dd class="dd-description"> Being the same object (which implies equivalence).
<a id="hevea_default858"></a></dd><dt class="dt-description"><span class="c010">reference:</span></dt><dd class="dd-description"> The association between a variable and its value.
<a id="hevea_default859"></a></dd><dt class="dt-description"><span class="c010">aliasing:</span></dt><dd class="dd-description"> A circumstance where two or more variables refer to the same
object.
<a id="hevea_default860"></a></dd><dt class="dt-description"><span class="c010">delimiter:</span></dt><dd class="dd-description"> A character or string used to indicate where a
string should be split.
<a id="hevea_default861"></a></dd></dl>
<h2 class="section" id="sec128">10.15&#XA0;&#XA0;Exercises</h2>
<p>You can download solutions to these exercises from
<a href="https://thinkpython.com/code/list_exercises.py"><span class="c004">https://thinkpython.com/code/list_exercises.py</span></a>.</p><div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#XA0;&#XA0;<p><em>Write a function called <code>nested_sum</code> that takes a list of lists
of integers and adds up the elements from all of the nested lists.
For example:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = [[1, 2], [3], [4, 5, 6]]
&gt;&gt;&gt; nested_sum(t)
21
</em></pre></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#XA0;&#XA0;
<a id="cumulative"></a>
<a id="hevea_default862"></a><p><em>Write a function called <span class="c004">cumsum</span> that takes a list of numbers and
returns the cumulative sum; that is, a new list where the </em><span class="c009">i</span><em>th
element is the sum of the first </em><span class="c009">i</span>+1<em> elements from the original list.
For example:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; cumsum(t)
[1, 3, 6]
</em></pre></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#XA0;&#XA0;<p><em>Write a function called <code>middle</code> that takes a list and
returns a new list that contains all but the first and last
elements. For example:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = [1, 2, 3, 4]
&gt;&gt;&gt; middle(t)
[2, 3]
</em></pre></div><div class="theorem"><span class="c010">Exercise&#XA0;4</span>&#XA0;&#XA0;<p><em>Write a function called <code>chop</code> that takes a list, modifies it
by removing the first and last elements, and returns <span class="c004">None</span>.
For example:</em></p><pre class="verbatim"><em>&gt;&gt;&gt; t = [1, 2, 3, 4]
&gt;&gt;&gt; chop(t)
&gt;&gt;&gt; t
[2, 3]
</em></pre></div><div class="theorem"><span class="c010">Exercise&#XA0;5</span>&#XA0;&#XA0;<em>
Write a function called <code>is_sorted</code> that takes a list as a
parameter and returns <span class="c004">True</span> if the list is sorted in ascending
order and <span class="c004">False</span> otherwise. For example:</em><pre class="verbatim"><em>&gt;&gt;&gt; is_sorted([1, 2, 2])
True
&gt;&gt;&gt; is_sorted(['b', 'a'])
False
</em></pre></div><div class="theorem"><span class="c010">Exercise&#XA0;6</span>&#XA0;&#XA0;
<a id="anagram"></a>
<a id="hevea_default863"></a><p><em>Two words are anagrams if you can rearrange the letters from one
to spell the other. Write a function called <code>is_anagram</code>
that takes two strings and returns <span class="c004">True</span> if they are anagrams.
</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;7</span>&#XA0;&#XA0;
<a id="duplicate"></a>
<a id="hevea_default864"></a>
<a id="hevea_default865"></a><p><em>Write a function called <code>has_duplicates</code> that takes
a list and returns <span class="c004">True</span> if there is any element that
appears more than once. It should not modify the original
list.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;8</span>&#XA0;&#XA0;<p><em>This exercise pertains to the so-called Birthday Paradox, which you
can read about at </em><a href="http://en.wikipedia.org/wiki/Birthday_paradox"><em><span class="c004">http://en.wikipedia.org/wiki/Birthday_paradox</span></em></a><em>.
</em><a id="hevea_default866"></a></p><p><em>If there are 23 students in your class, what are the chances
that two of them have the same birthday? You can estimate this
probability by generating random samples of 23 birthdays
and checking for matches. Hint: you can generate random birthdays
with the <span class="c004">randint</span> function in the <span class="c004">random</span> module.
</em><a id="hevea_default867"></a>
<a id="hevea_default868"></a>
<a id="hevea_default869"></a>
<a id="hevea_default870"></a></p><p><em>You can download my
solution from </em><a href="https://thinkpython.com/code/birthday.py"><em><span class="c004">https://thinkpython.com/code/birthday.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;9</span>&#XA0;&#XA0;
<a id="hevea_default871"></a>
<a id="hevea_default872"></a>
<a id="hevea_default873"></a>
<a id="hevea_default874"></a><p><em>Write a function that reads the file <span class="c004">words.txt</span> and builds
a list with one element per word. Write two versions of
this function, one using the <span class="c004">append</span> method and the
other using the idiom <span class="c004">t = t + [x]</span>. Which one takes
longer to run? Why?</em></p><p><em>Solution: </em><a href="https://thinkpython.com/code/wordlist.py"><span class="c004"><em>https://thinkpython.com/code/wordlist.py</em></span></a><em>.
</em><a id="hevea_default875"></a>
<a id="hevea_default876"></a></p></div><div class="theorem"><span class="c010">Exercise&#XA0;10</span>&#XA0;&#XA0;
<a id="wordlist1"></a>
<a id="bisection"></a>
<a id="hevea_default877"></a>
<a id="hevea_default878"></a>
<a id="hevea_default879"></a>
<a id="hevea_default880"></a>
<a id="hevea_default881"></a>
<a id="hevea_default882"></a><p><em>To check whether a word is in the word list, you could use
the <span class="c004">in</span> operator, but it would be slow because it searches
through the words in order.</em></p><p><em>Because the words are in alphabetical order, we can speed things up
with a bisection search (also known as binary search), which is
similar to what you do when you look a word up in the dictionary (the book, not the data structure). You
start in the middle and check to see whether the word you are looking
for comes before the word in the middle of the list. If so, you
search the first half of the list the same way. Otherwise you search
the second half.</em></p><p><em>Either way, you cut the remaining search space in half. If the
word list has 113,809 words, it will take about 17 steps to
find the word or conclude that it&#X2019;s not there.</em></p><p><em>Write a function called <code>in_bisect</code> that takes a sorted list
and a target value and returns <span class="c004">True</span> if the word is
in the list and <span class="c004">False</span> if it&#X2019;s not.
</em><a id="hevea_default883"></a>
<a id="hevea_default884"></a></p><p><em>Or you could read the documentation of the <span class="c004">bisect</span> module
and use that! Solution: </em><a href="https://thinkpython.com/code/inlist.py"><span class="c004"><em>https://thinkpython.com/code/inlist.py</em></span></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;11</span>&#XA0;&#XA0;
<a id="hevea_default885"></a><p><em>Two words are a &#X201C;reverse pair&#X201D; if each is the reverse of the
other. Write a program that finds all the reverse pairs in the
word list. Solution: </em><a href="https://thinkpython.com/code/reverse_pair.py"><em><span class="c004">https://thinkpython.com/code/reverse_pair.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;12</span>&#XA0;&#XA0;
<a id="hevea_default886"></a><p><em>Two words &#X201C;interlock&#X201D; if taking alternating letters from each forms
a new word. For example, &#X201C;shoe&#X201D; and &#X201C;cold&#X201D;
interlock to form &#X201C;schooled&#X201D;.
Solution: </em><a href="https://thinkpython.com/code/interlock.py"><em><span class="c004">https://thinkpython.com/code/interlock.py</span></em></a><em>.
Credit: This exercise is inspired by an example at </em><a href="http://puzzlers.org"><em><span class="c004">http://puzzlers.org</span></em></a><em>.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Write a program that finds all pairs of words that interlock.
Hint: don&#X2019;t enumerate all pairs!</em></li><li class="li-enumerate"><em>Can you find any words that are three-way interlocked; that is,
every third letter forms a word, starting from the first, second or
third?</em></li></ol></div>
<p>
<a href="http://amzn.to/1VUYQUU">Buy this book at Amazon.com</a>

</td>

<td width=130 valign="top">

<h4>Contribute</h4>
If you would like to make a contribution to support my books,
you can use the button below and pay with PayPal.  Thank you!

<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="hosted_button_id" value="RAAYAZ7Y48S2A">
<table>
<tr><td><input type="hidden" name="on0" value="Pay what you want!">Pay what you want:</td></tr><tr><td><select name="os0">
	<option value="Small">Small $1.00 USD</option>
	<option value="Medium">Medium $5.00 USD</option>
	<option value="Large">Large $10.00 USD</option>
	<option value="X-Large">X-Large $20.00 USD</option>
	<option value="XX-Large">XX-Large $50.00 USD</option>
</select> </td></tr>
</table>
<input type="hidden" name="currency_code" value="USD">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_paynow_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
<img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>

  
<p>
<h4>Are you using one of our books in a class?</h4>  We'd like to know
about it.  Please consider filling out <a href="http://spreadsheets.google.com/viewform?formkey=dC0tNUZkMjBEdXVoRGljNm9FRmlTMHc6MA" onClick="javascript: pageTracker._trackPageview('/outbound/survey');">this short survey</a>.

<p>
<br>

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491938455/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491938455&linkCode=as2&tag=greenteapre01-20&linkId=2JJH4SWCAVVYSQHO">Think DSP</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491938455" width="1" height="1" border="0" alt="">

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491938455/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491938455&linkCode=as2&tag=greenteapre01-20&linkId=CTV7PDT7E5EGGJUM"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=1491938455&Format=_SL160_&ID=AsinImage&MarketPlace=US&ServiceVersion=20070822&WS=1&tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491938455" width="1" height="1" border="0" alt="">

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491929561/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491929561&linkCode=as2&tag=greenteapre01-20&linkId=ZY6MAYM33ZTNSCNZ">Think Java</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491929561" width="1" height="1" border="0" alt="">

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491929561/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491929561&linkCode=as2&tag=greenteapre01-20&linkId=PT77ANWARUNNU3UK"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=1491929561&Format=_SL160_&ID=AsinImage&MarketPlace=US&ServiceVersion=20070822&WS=1&tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491929561" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1449370780/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449370780&linkCode=as2&tag=greenteapre01-20">Think Bayes</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1449370780" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1449370780/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449370780&linkCode=as2&tag=greenteapre01-20"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=1449370780&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1449370780" width="1" height="1" border="0" alt="">

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491939362/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491939362&linkCode=as2&tag=greenteapre01-20&linkId=FJKSQ3IHEMY2F2VA">Think Python 2e</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491939362" width="1" height="1" border="0" alt="">


<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491939362/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491939362&linkCode=as2&tag=greenteapre01-20&linkId=ZZ454DLQ3IXDHNHX"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=1491939362&Format=_SL160_&ID=AsinImage&MarketPlace=US&ServiceVersion=20070822&WS=1&tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491939362" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1491907339/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491907339&linkCode=as2&tag=greenteapre01-20&linkId=O7WYM6H6YBYUFNWU">Think Stats 2e</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491907339" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1491907339/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491907339&linkCode=as2&tag=greenteapre01-20&linkId=JVSYKQHYSUIEYRHL"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=1491907339&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491907339" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1449314635/ref=as_li_tf_tl?ie=UTF8&tag=greenteapre01-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1449314635">Think Complexity</a><img class="c003" src="http://www.assoc-amazon.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1449314635" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1449314635/ref=as_li_tf_il?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449314635&linkCode=as2&tag=greenteapre01-20"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=1449314635&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=greenteapre01-20"></a><img class="c003" src="http://www.assoc-amazon.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1449314635" width="1" height="1" border="0" alt="">


</td>
</tr>
</table>
<hr>
<a href="thinkpython2010.html"><img src="back.png" ALT="Previous"></a>
<a href="index.html"><img src="up.png" ALT="Up"></a>
<a href="thinkpython2012.html"><img src="next.png" ALT="Next"></a>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="generator" content="hevea 2.32">
<link rel="stylesheet" type="text/css" href="thinkpython2.css">
<title>Dictionaries</title>
</head>
<body>
<a href="thinkpython2011.html"><img src="back.png" ALT="Previous"></a>
<a href="index.html"><img src="up.png" ALT="Up"></a>
<a href="thinkpython2013.html"><img src="next.png" ALT="Next"></a>
<hr>
<table>

<tr>

<td valign="top" width="100" bgcolor="#b6459a">
</td>

<td valign="top" width="600" style="padding: 20px 20px;">

<p>
<a href="http://amzn.to/1VUYQUU">Buy this book at Amazon.com</a>

<h1 class="chapter" id="sec129">Chapter&#XA0;11&#XA0;&#XA0;Dictionaries</h1>
<p>This chapter presents another built-in type called a dictionary.
Dictionaries are one of Python&#X2019;s best features; they are the
building blocks of many efficient and elegant algorithms.</p>
<h2 class="section" id="sec130">11.1&#XA0;&#XA0;A dictionary is a mapping</h2>
<p><a id="hevea_default887"></a>
<a id="hevea_default888"></a>
<a id="hevea_default889"></a>
<a id="hevea_default890"></a>
<a id="hevea_default891"></a>
<a id="hevea_default892"></a>
A <span class="c010">dictionary</span> is like a list, but more general. In a list,
the indices have to be integers; in a dictionary they can
be (almost) any type.</p><p>A dictionary contains a collection of indices, which are called <span class="c010">keys</span>, and a collection of values. Each key is associated with a
single value. The association of a key and a value is called a <span class="c010">key-value pair</span> or sometimes an <span class="c010">item</span>. <a id="hevea_default893"></a></p><p>In mathematical language, a dictionary represents a <span class="c010">mapping</span>
from keys to values, so you can also say that each key
&#X201C;maps to&#X201D; a value.
As an example, we&#X2019;ll build a dictionary that maps from English
to Spanish words, so the keys and the values are all strings.</p><p>The function <span class="c004">dict</span> creates a new dictionary with no items.
Because <span class="c004">dict</span> is the name of a built-in function, you
should avoid using it as a variable name.
<a id="hevea_default894"></a>
<a id="hevea_default895"></a></p><pre class="verbatim">&gt;&gt;&gt; eng2sp = dict()
&gt;&gt;&gt; eng2sp
{}
</pre><p>The squiggly-brackets, <code>{}</code>, represent an empty dictionary.
To add items to the dictionary, you can use square brackets:
<a id="hevea_default896"></a>
<a id="hevea_default897"></a></p><pre class="verbatim">&gt;&gt;&gt; eng2sp['one'] = 'uno'
</pre><p>
This line creates an item that maps from the key
<code>'one'</code> to the value <code>'uno'</code>. If we print the
dictionary again, we see a key-value pair with a colon
between the key and value:</p><pre class="verbatim">&gt;&gt;&gt; eng2sp
{'one': 'uno'}
</pre><p>
This output format is also an input format. For example,
you can create a new dictionary with three items:</p><pre class="verbatim">&gt;&gt;&gt; eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}
</pre><p>
But if you print <span class="c004">eng2sp</span>, you might be surprised:</p><pre class="verbatim">&gt;&gt;&gt; eng2sp
{'one': 'uno', 'three': 'tres', 'two': 'dos'}
</pre><p>
The order of the key-value pairs might not be the same. If
you type the same example on your computer, you might get a
different result. In general, the order of items in
a dictionary is unpredictable.</p><p>But that&#X2019;s not a problem because
the elements of a dictionary are never indexed with integer indices.
Instead, you use the keys to look up the corresponding values:</p><pre class="verbatim">&gt;&gt;&gt; eng2sp['two']
'dos'
</pre><p>
The key <code>'two'</code> always maps to the value <code>'dos'</code> so the order
of the items doesn&#X2019;t matter.</p><p>If the key isn&#X2019;t in the dictionary, you get an exception:
<a id="hevea_default898"></a>
<a id="hevea_default899"></a></p><pre class="verbatim">&gt;&gt;&gt; eng2sp['four']
KeyError: 'four'
</pre><p>
The <span class="c004">len</span> function works on dictionaries; it returns the
number of key-value pairs:
<a id="hevea_default900"></a>
<a id="hevea_default901"></a></p><pre class="verbatim">&gt;&gt;&gt; len(eng2sp)
3
</pre><p>
The <span class="c004">in</span> operator works on dictionaries, too; it tells you whether
something appears as a <em>key</em> in the dictionary (appearing
as a value is not good enough).
<a id="hevea_default902"></a>
<a id="hevea_default903"></a>
<a id="hevea_default904"></a></p><pre class="verbatim">&gt;&gt;&gt; 'one' in eng2sp
True
&gt;&gt;&gt; 'uno' in eng2sp
False
</pre><p>
To see whether something appears as a value in a dictionary, you
can use the method <span class="c004">values</span>, which returns a collection of
values, and then use the <span class="c004">in</span> operator:
<a id="hevea_default905"></a>
<a id="hevea_default906"></a></p><pre class="verbatim">&gt;&gt;&gt; vals = eng2sp.values()
&gt;&gt;&gt; 'uno' in vals
True
</pre><p>
The <span class="c004">in</span> operator uses different algorithms for lists and
dictionaries. For lists, it searches the elements of the list in
order, as in Section&#XA0;<a href="thinkpython2009.html#find">8.6</a>. As the list gets longer, the search
time gets longer in direct proportion.</p><p>Python dictionaries use a data structure
called a <span class="c010">hashtable</span> that has a remarkable property: the
<span class="c004">in</span> operator takes about the same amount of time no matter how
many items are in the dictionary. I explain how that&#X2019;s possible
in Section&#XA0;<a href="thinkpython2022.html#hashtable">B.4</a>, but the explanation might not make
sense until you&#X2019;ve read a few more chapters.</p>
<h2 class="section" id="sec131">11.2&#XA0;&#XA0;Dictionary as a collection of counters</h2>
<p>
<a id="histogram"></a>
<a id="hevea_default907"></a></p><p>Suppose you are given a string and you want to count how many
times each letter appears. There are several ways you could do it:</p><ol class="enumerate" type=1><li class="li-enumerate">You could create 26 variables, one for each letter of the
alphabet. Then you could traverse the string and, for each
character, increment the corresponding counter, probably using
a chained conditional.</li><li class="li-enumerate">You could create a list with 26 elements. Then you could
convert each character to a number (using the built-in function
<span class="c004">ord</span>), use the number as an index into the list, and increment
the appropriate counter.</li><li class="li-enumerate">You could create a dictionary with characters as keys
and counters as the corresponding values. The first time you
see a character, you would add an item to the dictionary. After
that you would increment the value of an existing item.</li></ol><p>Each of these options performs the same computation, but each
of them implements that computation in a different way.
<a id="hevea_default908"></a></p><p>An <span class="c010">implementation</span> is a way of performing a computation;
some implementations are better than others. For example,
an advantage of the dictionary implementation is that we don&#X2019;t
have to know ahead of time which letters appear in the string
and we only have to make room for the letters that do appear.</p><p>Here is what the code might look like:</p><pre class="verbatim">def histogram(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] += 1
    return d
</pre><p>
The name of the function is <span class="c004">histogram</span>, which is a statistical
term for a collection of counters (or frequencies).
<a id="hevea_default909"></a>
<a id="hevea_default910"></a>
<a id="hevea_default911"></a></p><p>The first line of the
function creates an empty dictionary. The <span class="c004">for</span> loop traverses
the string. Each time through the loop, if the character <span class="c004">c</span> is
not in the dictionary, we create a new item with key <span class="c004">c</span> and the
initial value 1 (since we have seen this letter once). If <span class="c004">c</span> is
already in the dictionary we increment <span class="c004">d[c]</span>.
<a id="hevea_default912"></a></p><p>Here&#X2019;s how it works:</p><pre class="verbatim">&gt;&gt;&gt; h = histogram('brontosaurus')
&gt;&gt;&gt; h
{'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1}
</pre><p>
The histogram indicates that the letters <code>'a'</code> and <code>'b'</code>
appear once; <code>'o'</code> appears twice, and so on.</p><p><a id="hevea_default913"></a>
<a id="hevea_default914"></a>
Dictionaries have a method called <span class="c004">get</span> that takes a key
and a default value. If the key appears in the dictionary,
<span class="c004">get</span> returns the corresponding value; otherwise it returns
the default value. For example:</p><pre class="verbatim">&gt;&gt;&gt; h = histogram('a')
&gt;&gt;&gt; h
{'a': 1}
&gt;&gt;&gt; h.get('a', 0)
1
&gt;&gt;&gt; h.get('c', 0)
0
</pre><p>
As an exercise, use <span class="c004">get</span> to write <span class="c004">histogram</span> more concisely. You
should be able to eliminate the <span class="c004">if</span> statement.</p>
<h2 class="section" id="sec132">11.3&#XA0;&#XA0;Looping and dictionaries</h2>
<p>
<a id="hevea_default915"></a>
<a id="hevea_default916"></a>
<a id="hevea_default917"></a></p><p>If you use a dictionary in a <span class="c004">for</span> statement, it traverses
the keys of the dictionary. For example, <code>print_hist</code>
prints each key and the corresponding value:</p><pre class="verbatim">def print_hist(h):
    for c in h:
        print(c, h[c])
</pre><p>
Here&#X2019;s what the output looks like:</p><pre class="verbatim">&gt;&gt;&gt; h = histogram('parrot')
&gt;&gt;&gt; print_hist(h)
a 1
p 1
r 2
t 1
o 1
</pre><p>
Again, the keys are in no particular order. To traverse the keys
in sorted order, you can use the built-in function <span class="c004">sorted</span>:
<a id="hevea_default918"></a>
<a id="hevea_default919"></a></p><pre class="verbatim">&gt;&gt;&gt; for key in sorted(h):
...     print(key, h[key])
a 1
o 1
p 1
r 2
t 1
</pre>
<h2 class="section" id="sec133">11.4&#XA0;&#XA0;Reverse lookup</h2>
<p>
<a id="raise"></a>
<a id="hevea_default920"></a>
<a id="hevea_default921"></a>
<a id="hevea_default922"></a>
<a id="hevea_default923"></a></p><p>Given a dictionary <span class="c004">d</span> and a key <span class="c004">k</span>, it is easy to
find the corresponding value <span class="c004">v = d[k]</span>. This operation
is called a <span class="c010">lookup</span>.</p><p>But what if you have <span class="c004">v</span> and you want to find <span class="c004">k</span>?
You have two problems: first, there might be more than one
key that maps to the value <span class="c004">v</span>. Depending on the application,
you might be able to pick one, or you might have to make
a list that contains all of them. Second, there is no
simple syntax to do a <span class="c010">reverse lookup</span>; you have to search.</p><p>Here is a function that takes a value and returns the first
key that maps to that value:</p><pre class="verbatim">def reverse_lookup(d, v):
    for k in d:
        if d[k] == v:
            return k
    raise LookupError()
</pre><p>
This function is yet another example of the search pattern, but it
uses a feature we haven&#X2019;t seen before, <span class="c004">raise</span>. The 
<span class="c010">raise statement</span> causes an exception; in this case it causes a
<span class="c004">LookupError</span>, which is a built-in exception used to indicate
that a lookup operation failed.
<a id="hevea_default924"></a>
<a id="hevea_default925"></a> <a id="hevea_default926"></a> <a id="hevea_default927"></a>
<a id="hevea_default928"></a> <a id="hevea_default929"></a></p><p>If we get to the end of the loop, that means <span class="c004">v</span>
doesn&#X2019;t appear in the dictionary as a value, so we raise an
exception.</p><p>Here is an example of a successful reverse lookup:</p><pre class="verbatim">&gt;&gt;&gt; h = histogram('parrot')
&gt;&gt;&gt; key = reverse_lookup(h, 2)
&gt;&gt;&gt; key
'r'
</pre><p>
And an unsuccessful one:</p><pre class="verbatim">&gt;&gt;&gt; key = reverse_lookup(h, 3)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 5, in reverse_lookup
LookupError
</pre><p>
The effect when you raise an exception is the same as when
Python raises one: it prints a traceback and an error message.
<a id="hevea_default930"></a>
<a id="hevea_default931"></a>
<a id="hevea_default932"></a></p><p>When you raise an exception, you can provide a detailed error message as an optional argument. For example:</p><pre class="verbatim">&gt;&gt;&gt; raise LookupError('value does not appear in the dictionary')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
LookupError: value does not appear in the dictionary
</pre><p>
A reverse lookup is much slower than a forward lookup; if you
have to do it often, or if the dictionary gets big, the performance
of your program will suffer.</p>
<h2 class="section" id="sec134">11.5&#XA0;&#XA0;Dictionaries and lists</h2>
<p>
<a id="invert"></a></p><p>Lists can appear as values in a dictionary. For example, if you
are given a dictionary that maps from letters to frequencies, you
might want to invert it; that is, create a dictionary that maps
from frequencies to letters. Since there might be several letters
with the same frequency, each value in the inverted dictionary
should be a list of letters.
<a id="hevea_default933"></a>
<a id="hevea_default934"></a></p><p>Here is a function that inverts a dictionary:</p><pre class="verbatim">def invert_dict(d):
    inverse = dict()
    for key in d:
        val = d[key]
        if val not in inverse:
            inverse[val] = [key]
        else:
            inverse[val].append(key)
    return inverse
</pre><p>
Each time through the loop, <span class="c004">key</span> gets a key from <span class="c004">d</span> and 
<span class="c004">val</span> gets the corresponding value. If <span class="c004">val</span> is not in <span class="c004">inverse</span>, that means we haven&#X2019;t seen it before, so we create a new
item and initialize it with a <span class="c010">singleton</span> (a list that contains a
single element). Otherwise we have seen this value before, so we
append the corresponding key to the list. <a id="hevea_default935"></a></p><p>Here is an example:</p><pre class="verbatim">&gt;&gt;&gt; hist = histogram('parrot')
&gt;&gt;&gt; hist
{'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1}
&gt;&gt;&gt; inverse = invert_dict(hist)
&gt;&gt;&gt; inverse
{1: ['a', 'p', 't', 'o'], 2: ['r']}
</pre><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython2016.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 11.1: State diagram.</td></tr>
</table></div>
<a id="fig.dict1"></a>
<div class="center"><hr class="c019"></div></blockquote><p>Figure&#XA0;<a href="#fig.dict1">11.1</a> is a state diagram showing <span class="c004">hist</span> and <span class="c004">inverse</span>.
A dictionary is represented as a box with the type <span class="c004">dict</span> above it
and the key-value pairs inside. If the values are integers, floats or
strings, I draw them inside the box, but I usually draw lists
outside the box, just to keep the diagram simple.
<a id="hevea_default936"></a>
<a id="hevea_default937"></a></p><p>Lists can be values in a dictionary, as this example shows, but they
cannot be keys. Here&#X2019;s what happens if you try:
<a id="hevea_default938"></a>
<a id="hevea_default939"></a></p><pre class="verbatim">&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; d = dict()
&gt;&gt;&gt; d[t] = 'oops'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: list objects are unhashable
</pre><p>
I mentioned earlier that a dictionary is implemented using
a hashtable and that means that the keys have to be <span class="c010">hashable</span>.
<a id="hevea_default940"></a>
<a id="hevea_default941"></a></p><p>A <span class="c010">hash</span> is a function that takes a value (of any kind)
and returns an integer. Dictionaries use these integers,
called hash values, to store and look up key-value pairs.
<a id="hevea_default942"></a></p><p>This system works fine if the keys are immutable. But if the
keys are mutable, like lists, bad things happen. For example,
when you create a key-value pair, Python hashes the key and 
stores it in the corresponding location. If you modify the
key and then hash it again, it would go to a different location.
In that case you might have two entries for the same key,
or you might not be able to find a key. Either way, the
dictionary wouldn&#X2019;t work correctly.</p><p>That&#X2019;s why keys have to be hashable, and why mutable types like
lists aren&#X2019;t. The simplest way to get around this limitation is to
use tuples, which we will see in the next chapter.</p><p>Since dictionaries are mutable, they can&#X2019;t be used as keys,
but they <em>can</em> be used as values.</p>
<h2 class="section" id="sec135">11.6&#XA0;&#XA0;Memos</h2>
<p>
<a id="memoize"></a></p><p>If you played with the <span class="c004">fibonacci</span> function from
Section&#XA0;<a href="thinkpython2007.html#one.more.example">6.7</a>, you might have noticed that the bigger
the argument you provide, the longer the function takes to run.
Furthermore, the run time increases quickly.
<a id="hevea_default943"></a>
<a id="hevea_default944"></a></p><p>To understand why, consider Figure&#XA0;<a href="#fig.fibonacci">11.2</a>, which shows
the <span class="c010">call graph</span> for <span class="c004">fibonacci</span> with <span class="c004">n=4</span>:</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython2017.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 11.2: Call graph.</td></tr>
</table></div>
<a id="fig.fibonacci"></a>
<div class="center"><hr class="c019"></div></blockquote><p>A call graph shows a set of function frames, with lines connecting each
frame to the frames of the functions it calls. At the top of the
graph, <span class="c004">fibonacci</span> with <span class="c004">n=4</span> calls <span class="c004">fibonacci</span> with <span class="c004">n=3</span> and <span class="c004">n=2</span>. In turn, <span class="c004">fibonacci</span> with <span class="c004">n=3</span> calls
<span class="c004">fibonacci</span> with <span class="c004">n=2</span> and <span class="c004">n=1</span>. And so on.
<a id="hevea_default945"></a>
<a id="hevea_default946"></a>
<a id="hevea_default947"></a></p><p>Count how many times <span class="c004">fibonacci(0)</span> and <span class="c004">fibonacci(1)</span> are
called. This is an inefficient solution to the problem, and it gets
worse as the argument gets bigger.
<a id="hevea_default948"></a></p><p>One solution is to keep track of values that have already been
computed by storing them in a dictionary. A previously computed value
that is stored for later use is called a <span class="c010">memo</span>. Here is a
&#X201C;memoized&#X201D; version of <span class="c004">fibonacci</span>:</p><pre class="verbatim">known = {0:0, 1:1}

def fibonacci(n):
    if n in known:
        return known[n]

    res = fibonacci(n-1) + fibonacci(n-2)
    known[n] = res
    return res
</pre><p>
<span class="c004">known</span> is a dictionary that keeps track of the Fibonacci
numbers we already know. It starts with
two items: 0 maps to 0 and 1 maps to 1.</p><p>Whenever <span class="c004">fibonacci</span> is called, it checks <span class="c004">known</span>.
If the result is already there, it can return
immediately. Otherwise it has to 
compute the new value, add it to the dictionary, and return it.</p><p>If you run this version of <span class="c004">fibonacci</span> and compare it with
the original, you will find that it is much faster.</p>
<h2 class="section" id="sec136">11.7&#XA0;&#XA0;Global variables</h2>
<p>
<a id="hevea_default949"></a>
<a id="hevea_default950"></a></p><p>In the previous example, <span class="c004">known</span> is created outside the function,
so it belongs to the special frame called <code>__main__</code>.
Variables in <code>__main__</code> are sometimes called <span class="c010">global</span>
because they can be accessed from any function. Unlike local
variables, which disappear when their function ends, global variables
persist from one function call to the next.
<a id="hevea_default951"></a>
<a id="hevea_default952"></a></p><p>It is common to use global variables for <span class="c010">flags</span>; that is, 
boolean variables that indicate (&#X201C;flag&#X201D;) whether a condition
is true. For example, some programs use
a flag named <span class="c004">verbose</span> to control the level of detail in the
output:</p><pre class="verbatim">verbose = True

def example1():
    if verbose:
        print('Running example1')
</pre><p>
If you try to reassign a global variable, you might be surprised.
The following example is supposed to keep track of whether the
function has been called:
<a id="hevea_default953"></a></p><pre class="verbatim">been_called = False

def example2():
    been_called = True         # WRONG
</pre><p>
But if you run it you will see that the value of <code>been_called</code>
doesn&#X2019;t change. The problem is that <span class="c004">example2</span> creates a new local
variable named <code>been_called</code>. The local variable goes away when
the function ends, and has no effect on the global variable.
<a id="hevea_default954"></a>
<a id="hevea_default955"></a>
<a id="hevea_default956"></a></p><p>To reassign a global variable inside a function you have to
<span class="c010">declare</span> the global variable before you use it:</p><pre class="verbatim">been_called = False

def example2():
    global been_called 
    been_called = True
</pre><p>
The <span class="c010">global statement</span> tells the interpreter
something like, &#X201C;In this function, when I say <code>been_called</code>, I
mean the global variable; don&#X2019;t create a local one.&#X201D;
<a id="hevea_default957"></a>
<a id="hevea_default958"></a></p><p>Here&#X2019;s an example that tries to update a global variable:</p><pre class="verbatim">count = 0

def example3():
    count = count + 1          # WRONG
</pre><p>
If you run it you get:
<a id="hevea_default959"></a>
<a id="hevea_default960"></a></p><pre class="verbatim">UnboundLocalError: local variable 'count' referenced before assignment
</pre><p>
Python assumes that <span class="c004">count</span> is local, and under that assumption
you are reading it before writing it. The solution, again,
is to declare <span class="c004">count</span> global.
<a id="hevea_default961"></a></p><pre class="verbatim">def example3():
    global count
    count += 1
</pre><p>
If a global variable refers to a mutable value, you can modify
the value without declaring the variable:
<a id="hevea_default962"></a></p><pre class="verbatim">known = {0:0, 1:1}

def example4():
    known[2] = 1
</pre><p>
So you can add, remove and replace elements of a global list or
dictionary, but if you want to reassign the variable, you
have to declare it:</p><pre class="verbatim">def example5():
    global known
    known = dict()
</pre><p>
Global variables can be useful, but if you have a lot of them,
and you modify them frequently, they can make programs
hard to debug.</p>
<h2 class="section" id="sec137">11.8&#XA0;&#XA0;Debugging</h2>
<p>
<a id="hevea_default963"></a></p><p>As you work with bigger datasets it can become unwieldy to
debug by printing and checking the output by hand. Here are some
suggestions for debugging large datasets:</p><dl class="description"><dt class="dt-description"><span class="c010">Scale down the input:</span></dt><dd class="dd-description"> If possible, reduce the size of the
dataset. For example if the program reads a text file, start with
just the first 10 lines, or with the smallest example you can find.
You can either edit the files themselves, or (better) modify the
program so it reads only the first <span class="c004">n</span> lines.<p>If there is an error, you can reduce <span class="c004">n</span> to the smallest
value that manifests the error, and then increase it gradually
as you find and correct errors.</p></dd><dt class="dt-description"><span class="c010">Check summaries and types:</span></dt><dd class="dd-description"> Instead of printing and checking the
entire dataset, consider printing summaries of the data: for example,
the number of items in a dictionary or the total of a list of numbers.<p>A common cause of runtime errors is a value that is not the right
type. For debugging this kind of error, it is often enough to print
the type of a value.</p></dd><dt class="dt-description"><span class="c010">Write self-checks:</span></dt><dd class="dd-description"> Sometimes you can write code to check
for errors automatically. For example, if you are computing the
average of a list of numbers, you could check that the result is
not greater than the largest element in the list or less than
the smallest. This is called a &#X201C;sanity check&#X201D; because it detects
results that are &#X201C;insane&#X201D;.
<a id="hevea_default964"></a>
<a id="hevea_default965"></a><p>Another kind of check compares the results of two different
computations to see if they are consistent. This is called a
&#X201C;consistency check&#X201D;.</p></dd><dt class="dt-description"><span class="c010">Format the output:</span></dt><dd class="dd-description"> Formatting debugging output
can make it easier to spot an error. We saw an example in
Section&#XA0;<a href="thinkpython2007.html#factdebug">6.9</a>. Another tool you might find useful is the <span class="c004">pprint</span> module, which provides
a <span class="c004">pprint</span> function that displays built-in types in
a more human-readable format (<span class="c004">pprint</span> stands for
&#X201C;pretty print&#X201D;).
<a id="hevea_default966"></a>
<a id="hevea_default967"></a>
<a id="hevea_default968"></a></dd></dl><p>Again, time you spend building scaffolding can reduce
the time you spend debugging.
<a id="hevea_default969"></a></p>
<h2 class="section" id="sec138">11.9&#XA0;&#XA0;Glossary</h2>
<dl class="description"><dt class="dt-description"><span class="c010">mapping:</span></dt><dd class="dd-description"> A relationship in which each element of one set
corresponds to an element of another set.
<a id="hevea_default970"></a></dd><dt class="dt-description"><span class="c010">dictionary:</span></dt><dd class="dd-description"> A mapping from keys to their
corresponding values.
<a id="hevea_default971"></a></dd><dt class="dt-description"><span class="c010">key-value pair:</span></dt><dd class="dd-description"> The representation of the mapping from
a key to a value.
<a id="hevea_default972"></a></dd><dt class="dt-description"><span class="c010">item:</span></dt><dd class="dd-description"> In a dictionary, another name for a key-value
pair.
<a id="hevea_default973"></a></dd><dt class="dt-description"><span class="c010">key:</span></dt><dd class="dd-description"> An object that appears in a dictionary as the
first part of a key-value pair.
<a id="hevea_default974"></a></dd><dt class="dt-description"><span class="c010">value:</span></dt><dd class="dd-description"> An object that appears in a dictionary as the
second part of a key-value pair. This is more specific than
our previous use of the word &#X201C;value&#X201D;.
<a id="hevea_default975"></a></dd><dt class="dt-description"><span class="c010">implementation:</span></dt><dd class="dd-description"> A way of performing a computation.
<a id="hevea_default976"></a></dd><dt class="dt-description"><span class="c010">hashtable:</span></dt><dd class="dd-description"> The algorithm used to implement Python
dictionaries.
<a id="hevea_default977"></a></dd><dt class="dt-description"><span class="c010">hash function:</span></dt><dd class="dd-description"> A function used by a hashtable to compute the
location for a key.
<a id="hevea_default978"></a></dd><dt class="dt-description"><span class="c010">hashable:</span></dt><dd class="dd-description"> A type that has a hash function. Immutable
types like integers,
floats and strings are hashable; mutable types like lists and
dictionaries are not.
<a id="hevea_default979"></a></dd><dt class="dt-description"><span class="c010">lookup:</span></dt><dd class="dd-description"> A dictionary operation that takes a key and finds
the corresponding value.
<a id="hevea_default980"></a></dd><dt class="dt-description"><span class="c010">reverse lookup:</span></dt><dd class="dd-description"> A dictionary operation that takes a value and finds
one or more keys that map to it.
<a id="hevea_default981"></a></dd><dt class="dt-description"><span class="c010">raise statement:</span></dt><dd class="dd-description"> A statement that (deliberately) raises an exception.
<a id="hevea_default982"></a>
<a id="hevea_default983"></a></dd><dt class="dt-description"><span class="c010">singleton:</span></dt><dd class="dd-description"> A list (or other sequence) with a single element.
<a id="hevea_default984"></a></dd><dt class="dt-description"><span class="c010">call graph:</span></dt><dd class="dd-description"> A diagram that shows every frame created during
the execution of a program, with an arrow from each caller to
each callee. 
<a id="hevea_default985"></a>
<a id="hevea_default986"></a></dd><dt class="dt-description"><span class="c010">memo:</span></dt><dd class="dd-description"> A computed value stored to avoid unnecessary future 
computation.
<a id="hevea_default987"></a></dd><dt class="dt-description"><span class="c010">global variable:</span></dt><dd class="dd-description"> A variable defined outside a function. Global
variables can be accessed from any function.
<a id="hevea_default988"></a></dd><dt class="dt-description"><span class="c010">global statement:</span></dt><dd class="dd-description"> A statement that declares a variable name
global.
<a id="hevea_default989"></a>
<a id="hevea_default990"></a></dd><dt class="dt-description"><span class="c010">flag:</span></dt><dd class="dd-description"> A boolean variable used to indicate whether a condition
is true.
<a id="hevea_default991"></a></dd><dt class="dt-description"><span class="c010">declaration:</span></dt><dd class="dd-description"> A statement like <span class="c004">global</span> that tells the
interpreter something about a variable.
<a id="hevea_default992"></a></dd></dl>
<h2 class="section" id="sec139">11.10&#XA0;&#XA0;Exercises</h2>
<div class="theorem"><span class="c010">Exercise&#XA0;1</span>&#XA0;&#XA0;
<a id="wordlist2"></a>
<a id="hevea_default993"></a>
<a id="hevea_default994"></a><p><em>Write a function that reads the words in <span class="c004">words.txt</span> and
stores them as keys in a dictionary. It doesn&#X2019;t matter what the
values are. Then you can use the <span class="c004">in</span> operator
as a fast way to check whether a string is in
the dictionary.</em></p><p><em>If you did Exercise&#XA0;</em><a href="thinkpython2011.html#wordlist1"><em>10</em></a><em>, you can compare the speed
of this implementation with the list <span class="c004">in</span> operator and the
bisection search.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;2</span>&#XA0;&#XA0;
<a id="setdefault"></a><p><em>Read the documentation of the dictionary method <span class="c004">setdefault</span>
and use it to write a more concise version of <code>invert_dict</code>.
Solution: </em><a href="https://thinkpython.com/code/invert_dict.py"><span class="c004"><em>https://thinkpython.com/code/invert_dict.py</em></span></a><em>.
</em><a id="hevea_default995"></a>
<a id="hevea_default996"></a></p></div><div class="theorem"><span class="c010">Exercise&#XA0;3</span>&#XA0;&#XA0;<em>
Memoize the Ackermann function from Exercise&#XA0;</em><a href="thinkpython2007.html#ackermann"><em>2</em></a><em> and see if
memoization makes it possible to evaluate the function with bigger
arguments. Hint: no.
Solution: </em><a href="https://thinkpython.com/code/ackermann_memo.py"><span class="c004"><em>https://thinkpython.com/code/ackermann_memo.py</em></span></a><em>.
</em><a id="hevea_default997"></a>
<a id="hevea_default998"></a></div><div class="theorem"><span class="c010">Exercise&#XA0;4</span>&#XA0;&#XA0;
<a id="hevea_default999"></a><p><em>If you did Exercise&#XA0;</em><a href="thinkpython2011.html#duplicate"><em>7</em></a><em>, you already have
a function named <code>has_duplicates</code> that takes a list
as a parameter and returns <span class="c004">True</span> if there is any object
that appears more than once in the list.</em></p><p><em>Use a dictionary to write a faster, simpler version of
<code>has_duplicates</code>. 
Solution: </em><a href="https://thinkpython.com/code/has_duplicates.py"><span class="c004"><em>https://thinkpython.com/code/has_duplicates.py</em></span></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;5</span>&#XA0;&#XA0;
<a id="exrotatepairs"></a>
<a id="hevea_default1000"></a>
<a id="hevea_default1001"></a><p><em>Two words are &#X201C;rotate pairs&#X201D; if you can rotate one of them
and get the other (see <code>rotate_word</code> in Exercise&#XA0;</em><a href="thinkpython2009.html#exrotate"><em>5</em></a><em>).</em></p><p><em>Write a program that reads a wordlist and finds all the rotate
pairs. Solution: </em><a href="https://thinkpython.com/code/rotate_pairs.py"><em><span class="c004">https://thinkpython.com/code/rotate_pairs.py</span></em></a><em>.</em></p></div><div class="theorem"><span class="c010">Exercise&#XA0;6</span>&#XA0;&#XA0;
<a id="hevea_default1002"></a>
<a id="hevea_default1003"></a><p><em>Here&#X2019;s another Puzzler from </em>Car Talk<em> 
(</em><a href="http://www.cartalk.com/content/puzzlers"><em><span class="c004">http://www.cartalk.com/content/puzzlers</span></em></a><em>):</em></p><blockquote class="quote"><em>
This was sent in by a fellow named Dan O&#X2019;Leary. He came upon a common
one-syllable, five-letter word recently that has the following unique
property. When you remove the first letter, the remaining letters form
a homophone of the original word, that is a word that sounds exactly
the same. Replace the first letter, that is, put it back and remove
the second letter and the result is yet another homophone of the
original word. And the question is, what&#X2019;s the word?</em><p><em>Now I&#X2019;m going to give you an example that doesn&#X2019;t work. Let&#X2019;s look at
the five-letter word, &#X2018;wrack.&#X2019; W-R-A-C-K, you know like to &#X2018;wrack with
pain.&#X2019; If I remove the first letter, I am left with a four-letter
word, &#X2019;R-A-C-K.&#X2019; As in, &#X2018;Holy cow, did you see the rack on that buck!
It must have been a nine-pointer!&#X2019; It&#X2019;s a perfect homophone. If you
put the &#X2018;w&#X2019; back, and remove the &#X2018;r,&#X2019; instead, you&#X2019;re left with the
word, &#X2018;wack,&#X2019; which is a real word, it&#X2019;s just not a homophone of the
other two words.</em></p><p><em>But there is, however, at least one word that Dan and we know of,
which will yield two homophones if you remove either of the first two
letters to make two, new four-letter words. The question is, what&#X2019;s
the word?
</em></p></blockquote><p>
<a id="hevea_default1004"></a>
<a id="hevea_default1005"></a>
<a id="hevea_default1006"></a></p><p><em>You can use the dictionary from Exercise&#XA0;</em><a href="#wordlist2"><em>1</em></a><em> to check
whether a string is in the word list.</em></p><p><em>To check whether two words are homophones, you can use the CMU
Pronouncing Dictionary. You can download it from
</em><a href="http://www.speech.cs.cmu.edu/cgi-bin/cmudict"><span class="c004"><em>http://www.speech.cs.cmu.edu/cgi-bin/cmudict</em></span></a><em> or from
</em><a href="https://thinkpython.com/code/c06d"><span class="c004"><em>https://thinkpython.com/code/c06d</em></span></a><em> and you can also download
</em><a href="https://thinkpython.com/code/pronounce.py"><span class="c004"><em>https://thinkpython.com/code/pronounce.py</em></span></a><em>, which provides a function
named <code>read_dictionary</code> that reads the pronouncing dictionary and
returns a Python dictionary that maps from each word to a string that
describes its primary pronunciation.</em></p><p><em>Write a program that lists all the words that solve the Puzzler.
Solution: </em><a href="https://thinkpython.com/code/homophone.py"><em><span class="c004">https://thinkpython.com/code/homophone.py</span></em></a><em>.</em></p></div>
<p>
<a href="http://amzn.to/1VUYQUU">Buy this book at Amazon.com</a>

</td>

<td width=130 valign="top">

<h4>Contribute</h4>
If you would like to make a contribution to support my books,
you can use the button below and pay with PayPal.  Thank you!

<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="hosted_button_id" value="RAAYAZ7Y48S2A">
<table>
<tr><td><input type="hidden" name="on0" value="Pay what you want!">Pay what you want:</td></tr><tr><td><select name="os0">
	<option value="Small">Small $1.00 USD</option>
	<option value="Medium">Medium $5.00 USD</option>
	<option value="Large">Large $10.00 USD</option>
	<option value="X-Large">X-Large $20.00 USD</option>
	<option value="XX-Large">XX-Large $50.00 USD</option>
</select> </td></tr>
</table>
<input type="hidden" name="currency_code" value="USD">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_paynow_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
<img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>

  
<p>
<h4>Are you using one of our books in a class?</h4>  We'd like to know
about it.  Please consider filling out <a href="http://spreadsheets.google.com/viewform?formkey=dC0tNUZkMjBEdXVoRGljNm9FRmlTMHc6MA" onClick="javascript: pageTracker._trackPageview('/outbound/survey');">this short survey</a>.

<p>
<br>

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491938455/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491938455&linkCode=as2&tag=greenteapre01-20&linkId=2JJH4SWCAVVYSQHO">Think DSP</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491938455" width="1" height="1" border="0" alt="">

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491938455/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491938455&linkCode=as2&tag=greenteapre01-20&linkId=CTV7PDT7E5EGGJUM"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=1491938455&Format=_SL160_&ID=AsinImage&MarketPlace=US&ServiceVersion=20070822&WS=1&tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491938455" width="1" height="1" border="0" alt="">

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491929561/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491929561&linkCode=as2&tag=greenteapre01-20&linkId=ZY6MAYM33ZTNSCNZ">Think Java</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491929561" width="1" height="1" border="0" alt="">

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491929561/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491929561&linkCode=as2&tag=greenteapre01-20&linkId=PT77ANWARUNNU3UK"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=1491929561&Format=_SL160_&ID=AsinImage&MarketPlace=US&ServiceVersion=20070822&WS=1&tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491929561" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1449370780/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449370780&linkCode=as2&tag=greenteapre01-20">Think Bayes</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1449370780" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1449370780/ref=as_li_qf_sp_asin_il?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449370780&linkCode=as2&tag=greenteapre01-20"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=1449370780&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1449370780" width="1" height="1" border="0" alt="">

<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491939362/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491939362&linkCode=as2&tag=greenteapre01-20&linkId=FJKSQ3IHEMY2F2VA">Think Python 2e</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491939362" width="1" height="1" border="0" alt="">


<p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491939362/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491939362&linkCode=as2&tag=greenteapre01-20&linkId=ZZ454DLQ3IXDHNHX"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=1491939362&Format=_SL160_&ID=AsinImage&MarketPlace=US&ServiceVersion=20070822&WS=1&tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491939362" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1491907339/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491907339&linkCode=as2&tag=greenteapre01-20&linkId=O7WYM6H6YBYUFNWU">Think Stats 2e</a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491907339" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1491907339/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1491907339&linkCode=as2&tag=greenteapre01-20&linkId=JVSYKQHYSUIEYRHL"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=1491907339&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=greenteapre01-20"></a><img class="c003" src="http://ir-na.amazon-adsystem.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1491907339" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1449314635/ref=as_li_tf_tl?ie=UTF8&tag=greenteapre01-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1449314635">Think Complexity</a><img class="c003" src="http://www.assoc-amazon.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1449314635" width="1" height="1" border="0" alt="">

<p>
<a href="http://www.amazon.com/gp/product/1449314635/ref=as_li_tf_il?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449314635&linkCode=as2&tag=greenteapre01-20"><img border="0" src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=1449314635&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=greenteapre01-20"></a><img class="c003" src="http://www.assoc-amazon.com/e/ir?t=greenteapre01-20&l=as2&o=1&a=1449314635" width="1" height="1" border="0" alt="">


</td>
</tr>
</table>
<hr>
<a href="thinkpython2011.html"><img src="back.png" ALT="Previous"></a>
<a href="index.html"><img src="up.png" ALT="Up"></a>
<a href="thinkpython2013.html"><img src="next.png" ALT="Next"></a>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="generator" content="hevea 2.32">
<link rel="stylesheet" type="text/css" href="thinkpython2.css">
<title>Tuples</title>
</head>
<body>
<a href="thinkpython2012.html"><img src="back.png" ALT="Previous"></a>
<a href="index.html"><img src="up.png" ALT="Up"></a>
<a href="thinkpython2014.html"><img src="next.png" ALT="Next"></a>
<hr>
<table>

<tr>

<td valign="top" width="100" bgcolor="#b6459a">
</td>

<td valign="top" width="600" style="padding: 20px 20px;">

<p>
<a href="http://amzn.to/1VUYQUU">Buy this book at Amazon.com</a>

<h1 class="chapter" id="sec140">Chapter&#XA0;12&#XA0;&#XA0;Tuples</h1>
<p>
<a id="tuplechap"></a></p><p>This chapter presents one more built-in type, the tuple, and then
shows how lists, dictionaries, and tuples work together.
I also present a useful feature for variable-length argument lists,
the gather and scatter operators.</p><p>One note: there is no consensus on how to pronounce &#X201C;tuple&#X201D;.
Some people say &#X201C;tuh-ple&#X201D;, which rhymes with &#X201C;supple&#X201D;. But
in the context of programming, most people say &#X201C;too-ple&#X201D;, which
rhymes with &#X201C;quadruple&#X201D;.</p>
<h2 class="section" id="sec141">12.1&#XA0;&#XA0;Tuples are immutable</h2>
<p>
<a id="hevea_default1007"></a>
<a id="hevea_default1008"></a>
<a id="hevea_default1009"></a></p><p>A tuple is a sequence of values. The values can be any type, and
they are indexed by integers, so in that respect tuples are a lot
like lists. The important difference is that tuples are immutable.
<a id="hevea_default1010"></a>
<a id="hevea_default1011"></a></p><p>Syntactically, a tuple is a comma-separated list of values:</p><pre class="verbatim">&gt;&gt;&gt; t = 'a', 'b', 'c', 'd', 'e'
</pre><p>
Although it is not necessary, it is common to enclose tuples in
parentheses:
<a id="hevea_default1012"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ('a', 'b', 'c', 'd', 'e')
</pre><p>
To create a tuple with a single element, you have to include a final
comma:
<a id="hevea_default1013"></a>
<a id="hevea_default1014"></a></p><pre class="verbatim">&gt;&gt;&gt; t1 = 'a',
&gt;&gt;&gt; type(t1)
&lt;class 'tuple'&gt;
</pre><p>
A value in parentheses is not a tuple:</p><pre class="verbatim">&gt;&gt;&gt; t2 = ('a')
&gt;&gt;&gt; type(t2)
&lt;class 'str'&gt;
</pre><p>
Another way to create a tuple is the built-in function <span class="c004">tuple</span>.
With no argument, it creates an empty tuple:
<a id="hevea_default1015"></a>
<a id="hevea_default1016"></a></p><pre class="verbatim">&gt;&gt;&gt; t = tuple()
&gt;&gt;&gt; t
()
</pre><p>
If the argument is a sequence (string, list or tuple), the result
is a tuple with the elements of the sequence:</p><pre class="verbatim">&gt;&gt;&gt; t = tuple('lupins')
&gt;&gt;&gt; t
('l', 'u', 'p', 'i', 'n', 's')
</pre><p>
Because <span class="c004">tuple</span> is the name of a built-in function, you should
avoid using it as a variable name.</p><p>Most list operators also work on tuples. The bracket operator
indexes an element:
<a id="hevea_default1017"></a>
<a id="hevea_default1018"></a></p><pre class="verbatim">&gt;&gt;&gt; t = ('a', 'b', 'c', 'd', 'e')
&gt;&gt;&gt; t[0]
'a'
</pre><p>
And the slice operator selects a range of elements.
<a id="hevea_default1019"></a>
<a id="hevea_default1020"></a>
<a id="hevea_default1021"></a>
<a id="hevea_default1022"></a></p><pre class="verbatim">&gt;&gt;&gt; t[1:3]
('b', 'c')
</pre><p>
But if you try to modify one of the elements of the tuple, you get
an error:
<a id="hevea_default1023"></a>
<a id="hevea_default1024"></a>
<a id="hevea_default1025"></a>
<a id="hevea_default1026"></a></p><pre class="verbatim">&gt;&gt;&gt; t[0] = 'A'
TypeError: object doesn't support item assignment
</pre><p>
Because tuples are immutable, you can&#X2019;t modify the elements. But you
can replace one tuple with another:</p><pre class="verbatim">&gt;&gt;&gt; t = ('A',) + t[1:]
&gt;&gt;&gt; t
('A', 'b', 'c', 'd', 'e')
</pre><p>
This statement makes a new tuple and then makes <span class="c004">t</span> refer to it.</p><p>The relational operators work with tuples and other sequences;
Python starts by comparing the first element from each
sequence. If they are equal, it goes on to the next elements,
and so on, until it finds elements that differ. Subsequent
elements are not considered (even if they are really big).
<a id="hevea_default1027"></a>
<a id="hevea_default1028"></a></p><pre class="verbatim">&gt;&gt;&gt; (0, 1, 2) &lt; (0, 3, 4)
True
&gt;&gt;&gt; (0, 1, 2000000) &lt; (0, 3, 4)
True
</pre>
<h2 class="section" id="sec142">12.2&#XA0;&#XA0;Tuple assignment</h2>
<p>
<a id="tuple.assignment"></a>
<a id="hevea_default1029"></a>
<a id="hevea_default1030"></a>
<a id="hevea_default1031"></a>
<a id="hevea_default1032"></a></p><p>It is often useful to swap the values of two variables.
With conventional assignments, you have to use a temporary
variable. For example, to swap <span class="c004">a</span> and <span class="c004">b</span>:</p><pre class="verbatim">&gt;&gt;&gt; temp = a
&gt;&gt;&gt; a = b
&gt;&gt;&gt; b = temp
</pre><p>
This solution is cumbersome; <span class="c010">tuple assignment</span> is more elegant:</p><pre class="verbatim">&gt;&gt;&gt; a, b = b, a
</pre><p>
The left side is a tuple of variables; the right side is a tuple of
expressions. Each value is assigned to its respective variable. 
All the expressions on the right side are evaluated before any
of the assignments.</p><p>The number of variables on the left and the number of
values on the right have to be the same:
<a id="hevea_default1033"></a>
<a id="hevea_default1034"></a></p><pre class="verbatim">&gt;&gt;&gt; a, b = 1, 2, 3
ValueError: too many values to unpack
</pre><p>
More generally, the right side can be any kind of sequence
(string, list or tuple). For example, to split an email address
into a user name and a domain, you could write:
<a id="hevea_default1035"></a>
<a id="hevea_default1036"></a>
<a id="hevea_default1037"></a></p><pre class="verbatim">&gt;&gt;&gt; addr = 'monty@python.org'
&gt;&gt;&gt; uname, domain = addr.split('@')
</pre><p>
The return value from <span class="c004">split</span> is a list with two elements;
the first element is assigned to <span class="c004">uname</span>, the second to
<span class="c004">domain</span>.</p><pre class="verbatim">&gt;&gt;&gt; uname
'monty'
&gt;&gt;&gt; domain
'python.org'
</pre>
<h2 class="section" id="sec143">12.3&#XA0;&#XA0;Tuples as return values</h2>
<p>
<a id="hevea_default1038"></a>
<a id="hevea_default1039"></a>
<a id="hevea_default1040"></a>
<a id="hevea_default1041"></a></p><p>Strictly speaking, a function can only return one value, but
if the value is a tuple, the effect is the same as returning
multiple values. For example, if you want to divide two integers
and compute the quotient and remainder, it is inefficient to
compute <span class="c004">x//y</span> and then <span class="c004">x%y</span>. It is better to compute
them both at the same time.
<a id="hevea_default1042"></a></p><p>The built-in function <span class="c004">divmod</span> takes two arguments and
returns a tuple of two values, the quotient and remainder.
You can store the result as a tuple:</p><pre class="verbatim">&gt;&gt;&gt; t = divmod(7, 3)
&gt;&gt;&gt; t
(2, 1)
</pre><p>
Or use tuple assignment to store the elements separately:
<a id="hevea_default1043"></a>
<a id="hevea_default1044"></a></p><pre class="verbatim">&gt;&gt;&gt; quot, rem = divmod(7, 3)
&gt;&gt;&gt; quot
2
&gt;&gt;&gt; rem
1
</pre><p>
Here is an example of a function that returns a tuple:</p><pre class="verbatim">def min_max(t):
    return min(t), max(t)
</pre><p>
<span class="c004">max</span> and <span class="c004">min</span> are built-in functions that find
the largest and smallest elements of a sequence. <code>min_max</code>
computes both and returns a tuple of two values.
<a id="hevea_default1045"></a>
<a id="hevea_default1046"></a>
<a id="hevea_default1047"></a>
<a id="hevea_default1048"></a></p>
<h2 class="section" id="sec144">12.4&#XA0;&#XA0;Variable-length argument tuples</h2>
<p>
<a id="gather"></a>
<a id="hevea_default1049"></a>
<a id="hevea_default1050"></a>
<a id="hevea_default1051"></a>
<a id="hevea_default1052"></a>
<a id="hevea_default1053"></a></p><p>Functions can take a variable number of arguments. A parameter
name that begins with <span class="c004">*</span> <span class="c010">gathers</span> arguments into
a tuple. For example, <span class="c004">printall</span>
takes any number of arguments and prints them:</p><pre class="verbatim">def printall(*args):
    print(args)
</pre><p>
The gather parameter can have any name you like, but <span class="c004">args</span> is
conventional. Here&#X2019;s how the function works:</p><pre class="verbatim">&gt;&gt;&gt; printall(1, 2.0, '3')
(1, 2.0, '3')
</pre><p>
The complement of gather is <span class="c010">scatter</span>. If you have a
sequence of values and you want to pass it to a function
as multiple arguments, you can use the <span class="c004">*</span> operator.
For example, <span class="c004">divmod</span> takes exactly two arguments; it
doesn&#X2019;t work with a tuple:
<a id="hevea_default1054"></a>
<a id="hevea_default1055"></a>
<a id="hevea_default1056"></a>
<a id="hevea_default1057"></a></p><pre class="verbatim">&gt;&gt;&gt; t = (7, 3)
&gt;&gt;&gt; divmod(t)
TypeError: divmod expected 2 arguments, got 1
</pre><p>
But if you scatter the tuple, it works:</p><pre class="verbatim">&gt;&gt;&gt; divmod(*t)
(2, 1)
</pre><p>
Many of the built-in functions use
variable-length argument tuples. For example, <span class="c004">max</span>
and <span class="c004">min</span> can take any number of arguments:
<a id="hevea_default1058"></a>
<a id="hevea_default1059"></a>
<a id="hevea_default1060"></a>
<a id="hevea_default1061"></a></p><pre class="verbatim">&gt;&gt;&gt; max(1, 2, 3)
3
</pre><p>
But <span class="c004">sum</span> does not.
<a id="hevea_default1062"></a>
<a id="hevea_default1063"></a></p><pre class="verbatim">&gt;&gt;&gt; sum(1, 2, 3)
TypeError: sum expected at most 2 arguments, got 3
</pre><p>
As an exercise, write a function called <code>sum_all</code> that takes any number
of arguments and returns their sum.</p>
<h2 class="section" id="sec145">12.5&#XA0;&#XA0;Lists and tuples</h2>
<p>
<a id="hevea_default1064"></a>
<a id="hevea_default1065"></a></p><p><span class="c004">zip</span> is a built-in function that takes two or more sequences and
interleaves them. The name of the function refers to
a zipper, which interleaves two rows of teeth.</p><p>This example zips a string and a list:</p><pre class="verbatim">&gt;&gt;&gt; s = 'abc'
&gt;&gt;&gt; t = [0, 1, 2]
&gt;&gt;&gt; zip(s, t)
&lt;zip object at 0x7f7d0a9e7c48&gt;
</pre><p>
The result is a <span class="c010">zip object</span> that knows how to iterate through
the pairs. The most common use of <span class="c004">zip</span> is in a <span class="c004">for</span> loop:</p><pre class="verbatim">&gt;&gt;&gt; for pair in zip(s, t):
...     print(pair)
...
('a', 0)
('b', 1)
('c', 2)
</pre><p>
A zip object is a kind of <span class="c010">iterator</span>, which is any object
that iterates through a sequence. Iterators are similar to lists in some
ways, but unlike lists, you can&#X2019;t use an index to select an element from
an iterator.
<a id="hevea_default1066"></a></p><p>If you want to use list operators and methods, you can
use a zip object to make a list:</p><pre class="verbatim">&gt;&gt;&gt; list(zip(s, t))
[('a', 0), ('b', 1), ('c', 2)]
</pre><p>
The result is a list of tuples; in this example, each tuple contains
a character from the string and the corresponding element from
the list.
<a id="hevea_default1067"></a></p><p>If the sequences are not the same length, the result has the
length of the shorter one.</p><pre class="verbatim">&gt;&gt;&gt; list(zip('Anne', 'Elk'))
[('A', 'E'), ('n', 'l'), ('n', 'k')]
</pre><p>
You can use tuple assignment in a <span class="c004">for</span> loop to traverse a list of
tuples:
<a id="hevea_default1068"></a>
<a id="hevea_default1069"></a>
<a id="hevea_default1070"></a></p><pre class="verbatim">t = [('a', 0), ('b', 1), ('c', 2)]
for letter, number in t:
    print(number, letter)
</pre><p>
Each time through the loop, Python selects the next tuple in
the list and assigns the elements to <span class="c004">letter</span> and 
<span class="c004">number</span>. The output of this loop is:
<a id="hevea_default1071"></a></p><pre class="verbatim">0 a
1 b
2 c
</pre><p>
If you combine <span class="c004">zip</span>, <span class="c004">for</span> and tuple assignment, you get a
useful idiom for traversing two (or more) sequences at the same
time. For example, <code>has_match</code> takes two sequences, <span class="c004">t1</span> and
<span class="c004">t2</span>, and returns <span class="c004">True</span> if there is an index <span class="c004">i</span>
such that <span class="c004">t1[i] == t2[i]</span>:
<a id="hevea_default1072"></a></p><pre class="verbatim">def has_match(t1, t2):
    for x, y in zip(t1, t2):
        if x == y:
            return True
    return False
</pre><p>
If you need to traverse the elements of a sequence and their
indices, you can use the built-in function <span class="c004">enumerate</span>:
<a id="hevea_default1073"></a>
<a id="hevea_default1074"></a>
<a id="hevea_default1075"></a></p><pre class="verbatim">for index, element in enumerate('abc'):
    print(index, element)
</pre><p>
The result from <span class="c004">enumerate</span> is an enumerate object, which
iterates a sequence of pairs; each pair contains an index (starting
from 0) and an element from the given sequence.
In this example, the output is</p><pre class="verbatim">0 a
1 b
2 c
</pre><p>
Again.
<a id="hevea_default1076"></a>
<a id="hevea_default1077"></a>
<a id="hevea_default1078"></a></p>
<h2 class="section" id="sec146">12.6&#XA0;&#XA0;Dictionaries and tuples</h2>
<p>
<a id="dictuple"></a>
<a id="hevea_default1079"></a>
<a id="hevea_default1080"></a>
<a id="hevea_default1081"></a>
<a id="hevea_default1082"></a></p><p>Dictionaries have a method called <span class="c004">items</span> that returns a sequence of
tuples, where each tuple is a key-value pair.</p><pre class="verbatim">&gt;&gt;&gt; d = {'a':0, 'b':1, 'c':2}
&gt;&gt;&gt; t = d.items()
&gt;&gt;&gt; t
dict_items([('c', 2), ('a', 0), ('b', 1)])
</pre><p>
The result is a <code>dict_items</code> object, which is an iterator that
iterates the key-value pairs. You can use it in a <span class="c004">for</span> loop
like this:
<a id="hevea_default1083"></a></p><pre class="verbatim">&gt;&gt;&gt; for key, value in d.items():
...     print(key, value)
...
c 2
a 0
b 1
</pre><p>
As you should expect from a dictionary, the items are in no
particular order.</p><p>Going in the other direction, you can use a list of tuples to
initialize a new dictionary: <a id="hevea_default1084"></a></p><pre class="verbatim">&gt;&gt;&gt; t = [('a', 0), ('c', 2), ('b', 1)]
&gt;&gt;&gt; d = dict(t)
&gt;&gt;&gt; d
{'a': 0, 'c': 2, 'b': 1}
</pre><p>Combining <span class="c004">dict</span> with <span class="c004">zip</span> yields a concise way
to create a dictionary:
<a id="hevea_default1085"></a></p><pre class="verbatim">&gt;&gt;&gt; d = dict(zip('abc', range(3)))
&gt;&gt;&gt; d
{'a': 0, 'c': 2, 'b': 1}
</pre><p>
The dictionary method <span class="c004">update</span> also takes a list of tuples
and adds them, as key-value pairs, to an existing dictionary.
<a id="hevea_default1086"></a>
<a id="hevea_default1087"></a>
<a id="hevea_default1088"></a>
<a id="hevea_default1089"></a></p><p>It is common to use tuples as keys in dictionaries (primarily because
you can&#X2019;t use lists). For example, a telephone directory might map
from last-name, first-name pairs to telephone numbers. Assuming
that we have defined <span class="c004">last</span>, <span class="c004">first</span> and <span class="c004">number</span>, we
could write:
<a id="hevea_default1090"></a>
<a id="hevea_default1091"></a></p><pre class="verbatim">directory[last, first] = number
</pre><p>
The expression in brackets is a tuple. We could use tuple
assignment to traverse this dictionary.
<a id="hevea_default1092"></a></p><pre class="verbatim">for last, first in directory:
    print(first, last, directory[last,first])
</pre><p>
This loop traverses the keys in <span class="c004">directory</span>, which are tuples. It
assigns the elements of each tuple to <span class="c004">last</span> and <span class="c004">first</span>, then
prints the name and corresponding telephone number.</p><p>There are two ways to represent tuples in a state diagram. The more
detailed version shows the indices and elements just as they appear in
a list. For example, the tuple <code>('Cleese', 'John')</code> would appear
as in Figure&#XA0;<a href="#fig.tuple1">12.1</a>.
<a id="hevea_default1093"></a>
<a id="hevea_default1094"></a></p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython2018.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 12.1: State diagram.</td></tr>
</table></div>
<a id="fig.tuple1"></a>
<div class="center"><hr class="c019"></div></blockquote><p>But in a larger diagram you might want to leave out the
details. For example, a diagram of the telephone directory might
appear as in Figure&#XA0;<a href="#fig.dict2">12.2</a>.</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython2019.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c018">Figure 12.2: State diagram.</td></tr>
</table></div>
<a id="fig.dict2"></a>
<div class="center"><hr class="c019"></div></blockquote><p>Here the tuples are shown using Python syntax as a graphical
shorthand. The telephone number in the diagram is the complaints line
for the BBC, so please don&#X2019;t call it.</p>
<h2 class="section" id="sec147">12.7&#XA0;&#XA0;Sequences of sequences</h2>
<p>
<a id="hevea_default1095"></a></p><p>I have focused on lists of tuples, but almost all of the examples in
this chapter also work with lists of lists, tuples of tuples, and
tuples of lists. To avoid enumerating the possible combinations, it
is sometimes easier to talk about sequences of sequences.</p><p>In many contexts, the different kinds of sequences (strings, lists and
tuples) can be used interchangeably. So how should you choose one
over the others?
<a id="hevea_default1096"></a>
<a id="hevea_default1097"></a>
<a id="hevea_default1098"></a>
<a id="hevea_default1099"></a>
<a id="hevea_default1100"></a></p><p>To start with the obvious, strings are more limited than othe